<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>渴望力量吗？少年！流的原理 | Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="流(stream)，看一个人流不流逼，就看你对流的理解了
学习本无底，前进莫徬徨

今天跟大家分享的是node.js中的流(stream)。它的作用大家应该都在平常使用node的时候看到过，比如：

gulp中的pipe就是流的一种方法，通过可写流和可读流的配合，达到不占用多余缓存的一种读写方式。
express和koa中的res和req也是流，res是可写流，req是可读流，他们都是通过封装no">
<meta property="og:type" content="article">
<meta property="og:title" content="渴望力量吗？少年！流的原理">
<meta property="og:url" content="http://shinemax1.github.io/2018/07/14/stream/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="流(stream)，看一个人流不流逼，就看你对流的理解了
学习本无底，前进莫徬徨

今天跟大家分享的是node.js中的流(stream)。它的作用大家应该都在平常使用node的时候看到过，比如：

gulp中的pipe就是流的一种方法，通过可写流和可读流的配合，达到不占用多余缓存的一种读写方式。
express和koa中的res和req也是流，res是可写流，req是可读流，他们都是通过封装no">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/7/13/16491e3c412fbd6f?w=300&h=217&f=gif&s=471574">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/7/13/164920492aaecdf9?w=419&h=233&f=gif&s=1680530">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/7/13/16491a2ce2f22b41?w=1976&h=1128&f=jpeg&s=170261">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/7/13/164920c158bb431a?w=198&h=130&f=jpeg&s=7736">
<meta property="og:updated_time" content="2018-07-14T04:04:44.567Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="渴望力量吗？少年！流的原理">
<meta name="twitter:description" content="流(stream)，看一个人流不流逼，就看你对流的理解了
学习本无底，前进莫徬徨

今天跟大家分享的是node.js中的流(stream)。它的作用大家应该都在平常使用node的时候看到过，比如：

gulp中的pipe就是流的一种方法，通过可写流和可读流的配合，达到不占用多余缓存的一种读写方式。
express和koa中的res和req也是流，res是可写流，req是可读流，他们都是通过封装no">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2018/7/13/16491e3c412fbd6f?w=300&h=217&f=gif&s=471574">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.25px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 13.75px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 16.25px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.25px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 17.5px;">Objective-C</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/ReactiveCocoa/" style="font-size: 12.5px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/SSR/" style="font-size: 10px;">SSR</a> <a href="/tags/Sublime-Text/" style="font-size: 11.25px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 13.75px;">Tools</a> <a href="/tags/Transition/" style="font-size: 12.5px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 18.75px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js/" style="font-size: 11.25px;">js</a> <a href="/tags/js基础/" style="font-size: 20px;">js基础</a> <a href="/tags/node-js/" style="font-size: 11.25px;">node.js</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/事件环/" style="font-size: 10px;">事件环</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/宏任务/" style="font-size: 10px;">宏任务</a> <a href="/tags/微任务/" style="font-size: 10px;">微任务</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/流/" style="font-size: 10px;">流</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/面试/" style="font-size: 11.25px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，全栈开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-stream" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/14/stream/" class="article-date">
  	<time datetime="2018-07-14T04:00:40.000Z" itemprop="datePublished">2018-07-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      渴望力量吗？少年！流的原理
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/">node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stream/">stream</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/流/">流</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="流-stream-，看一个人流不流逼，就看你对流的理解了"><a href="#流-stream-，看一个人流不流逼，就看你对流的理解了" class="headerlink" title="流(stream)，看一个人流不流逼，就看你对流的理解了"></a>流(stream)，看一个人流不流逼，就看你对流的理解了</h2><blockquote>
<p>学习本无底，前进莫徬徨</p>
</blockquote>
<p>今天跟大家分享的是node.js中的流(<code>stream</code>)。它的作用大家应该都在平常使用node的时候看到过，比如：</p>
<ul>
<li><code>gulp</code>中的pipe就是流的一种方法，通过可写流和可读流的配合，达到不占用多余缓存的一种读写方式。</li>
<li>express和koa中的res和req也是流，res是<code>可写流</code>，req是<code>可读流</code>，他们都是通过封装node中的net模块的socket(<code>双工流</code>，即可写、可读流)而来的。</li>
<li>。。。</li>
</ul>
<p>可能很多时候大家都知道怎么用，但不了解它的原理，很尴尬，就像这样</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16491e3c412fbd6f?w=300&amp;h=217&amp;f=gif&amp;s=471574" alt=""></p>
<h2 id="何谓流？"><a href="#何谓流？" class="headerlink" title="何谓流？"></a>何谓流？</h2><ul>
<li>流是一组有序的，有起点和终点的字节数据传输手段。</li>
<li>它不关心文件的整体内容，只关注是否从文件中读到了数据，以及读到数据之后的处理。</li>
<li>流是一个抽象接口，被 Node 中的很多对象所实现。比如HTTP 服务器request和response对象都是流。</li>
<li>流被分为<code>Readable</code>(可读流)、<code>Writable</code>(可写流)、<code>Duplex</code>(双工流)、<code>Transform</code>(转换流)</li>
</ul>
<h2 id="流中的是什么？"><a href="#流中的是什么？" class="headerlink" title="流中的是什么？"></a>流中的是什么？</h2><ul>
<li><code>二进制模式</code>:每个分块都是buffer、string对象。</li>
<li><code>对象模式</code>:流内部处理的是一系列普通对象。</li>
</ul>
<h2 id="可读流"><a href="#可读流" class="headerlink" title="可读流"></a>可读流</h2><blockquote>
<p>可读流分为<code>flowing</code>和<code>paused</code>两种模式</p>
</blockquote>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>path</code>:读取的文件的路径</li>
<li><code>option</code>:<ul>
<li><code>highWaterMark</code>:水位线，一次可读的字节，一般默认是<code>64k</code></li>
<li><code>flags</code>:标识，打开文件要做的操作，默认是<code>r</code></li>
<li><code>encoding</code>:编码，默认为buffer</li>
<li><code>start</code>:开始读取的索引位置</li>
<li><code>end</code>:结束读取的索引位置(包括结束位置)</li>
<li><code>autoClose</code>:读取完毕是否关闭，默认为true</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>)</div><div class="line"><span class="comment">//读取的时候默认读64k </span></div><div class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(<span class="string">'./a.txt'</span>,&#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">2</span>,<span class="comment">//一次读的字节 默认64k</span></div><div class="line">  flags: <span class="string">'r'</span>,      <span class="comment">//标示 r为读 w为写</span></div><div class="line">  autoClose: <span class="literal">true</span>, <span class="comment">//默认读取完毕后自动关闭</span></div><div class="line">  start: <span class="number">0</span>,</div><div class="line">  <span class="attr">end</span>: <span class="number">5</span>,          <span class="comment">//流是闭合区间包start，也包end 默认是读完</span></div><div class="line">  encoding: <span class="string">'utf8'</span> <span class="comment">//默认编码是buffer</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="data-切换到流动模式，可以流出数据"><a href="#data-切换到流动模式，可以流出数据" class="headerlink" title="data:切换到流动模式，可以流出数据"></a><code>data</code>:切换到流动模式，可以流出数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="open-流打开文件的时候会触发此监听"><a href="#open-流打开文件的时候会触发此监听" class="headerlink" title="open:流打开文件的时候会触发此监听"></a><code>open</code>:流打开文件的时候会触发此监听</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'文件被打开'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="error-流出错的时候，监听错误信息"><a href="#error-流出错的时候，监听错误信息" class="headerlink" title="error:流出错的时候，监听错误信息"></a><code>error</code>:流出错的时候，监听错误信息</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="end-流读取完成，触发end"><a href="#end-流读取完成，触发end" class="headerlink" title="end:流读取完成，触发end"></a><code>end</code>:流读取完成，触发end</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'读取完成'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="close-关闭流，触发"><a href="#close-关闭流，触发" class="headerlink" title="close:关闭流，触发"></a><code>close</code>:关闭流，触发</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'关闭'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="pause-暂停流-改变流的flowing，不读取数据了-；resume-恢复流-改变流的flowing-继续读取数据"><a href="#pause-暂停流-改变流的flowing，不读取数据了-；resume-恢复流-改变流的flowing-继续读取数据" class="headerlink" title="pause:暂停流(改变流的flowing，不读取数据了)；resume:恢复流(改变流的flowing,继续读取数据)"></a><code>pause</code>:暂停流(改变流的flowing，不读取数据了)；<code>resume</code>:恢复流(改变流的flowing,继续读取数据)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//流通过一次后，停止流动，过了2s后再动</span></div><div class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    rs.pause();</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    rs.resume();</div><div class="line">&#125;,<span class="number">2000</span>);</div></pre></td></tr></table></figure>
<h4 id="fs-read-可读流底层调用的就是这个方法，最原生的读方法"><a href="#fs-read-可读流底层调用的就是这个方法，最原生的读方法" class="headerlink" title="fs.read():可读流底层调用的就是这个方法，最原生的读方法"></a><code>fs.read()</code>:可读流底层调用的就是这个方法，最原生的读方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//fd文件描述符，一般通过fs.open中获取</span></div><div class="line"><span class="comment">//buffer是读取后的数据放入的缓存目标</span></div><div class="line"><span class="comment">//0，从buffer的0位置开始放入</span></div><div class="line"><span class="comment">//BUFFER_SIZE，每次放BUFFER_SIZE这么长的长度</span></div><div class="line"><span class="comment">//index，每次从文件的index的位置开始读</span></div><div class="line"><span class="comment">//bytesRead，真实读到的个数</span></div><div class="line">fs.read(fd,buffer,<span class="number">0</span>,BUFFER_SIZE,index,<span class="function"><span class="keyword">function</span>(<span class="params">err,bytesRead</span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="那让我们自己来实现一个可爱的读流吧！"><a href="#那让我们自己来实现一个可爱的读流吧！" class="headerlink" title="那让我们自己来实现一个可爱的读流吧！"></a>那让我们自己来实现一个<code>可爱</code>的读流吧！</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/164920492aaecdf9?w=419&amp;h=233&amp;f=gif&amp;s=1680530" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(path,options = &#123;&#125;)&#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.path = path</div><div class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span>*<span class="number">1024</span></div><div class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span></div><div class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span></div><div class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start     <span class="comment">//会随着读取的位置改变</span></div><div class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.end = options.end || <span class="literal">null</span></div><div class="line">    <span class="comment">//默认null就是buffer</span></div><div class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">//参数的问题</span></div><div class="line">    <span class="keyword">this</span>.flowing = <span class="literal">null</span> <span class="comment">//非流动模式</span></div><div class="line">    <span class="comment">//创建个buffer用来存储每次读出来的数据</span></div><div class="line">    <span class="keyword">this</span>.buffer = Buffer.alloc(<span class="keyword">this</span>.highWaterMark)</div><div class="line">    <span class="comment">//打开这个文件</span></div><div class="line">    <span class="keyword">this</span>.open()</div><div class="line">    <span class="comment">//此方法默认同步调用 每次设置on监听事件时都会调用之前所有的newListener事件</span></div><div class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>,(type)=&gt;&#123;<span class="comment">// 等待着他监听data事件</span></div><div class="line">      <span class="keyword">if</span>(type === <span class="string">'data'</span>)&#123;</div><div class="line">        <span class="keyword">this</span>.flowing = <span class="literal">true</span></div><div class="line">        <span class="comment">//开始读取 客户已经监听的data事件</span></div><div class="line">        <span class="keyword">this</span>.read()</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//默认第一次调用read方法时fd还没获取 所以不能直接读</span></div><div class="line">  read()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="comment">//等待着触发open事件后fd肯定拿到了 再去执行read方法</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>,()=&gt;&#123;<span class="keyword">this</span>.read()&#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//每次读的时候都要判断一下下次读几个 如果没有end就根据highWaterMark来(读所有的) 如果有且大于highWaterMark就根据highWaterMark来 如果小于highWaterMark就根据end来</span></div><div class="line">    <span class="keyword">let</span> howMuchToRead = <span class="keyword">this</span>.end?<span class="built_in">Math</span>.min(<span class="keyword">this</span>.end - <span class="keyword">this</span>.pos + <span class="number">1</span>,<span class="keyword">this</span>.highWaterMark):<span class="keyword">this</span>.highWaterMark</div><div class="line">    fs.read(<span class="keyword">this</span>.fd,<span class="keyword">this</span>.buffer,<span class="number">0</span>,howMuchToRead,<span class="keyword">this</span>.pos,(err,byteRead)=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.pos += byteRead</div><div class="line">      <span class="keyword">let</span> b = <span class="keyword">this</span>.encoding?<span class="keyword">this</span>.buffer.slice(<span class="number">0</span>,byteRead).toString(<span class="keyword">this</span>.encoding):<span class="keyword">this</span>.buffer.slice(<span class="number">0</span>,byteRead)</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'data'</span>,b)</div><div class="line">      <span class="comment">//如果读取到的数量和highWaterMark一样 说明还得继续读</span></div><div class="line">      <span class="keyword">if</span>((byteRead === <span class="keyword">this</span>.highWaterMark)&amp;&amp;<span class="keyword">this</span>.flowing)&#123;</div><div class="line">        <span class="keyword">this</span>.read()</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(byteRead &lt; <span class="keyword">this</span>.highWaterMark)&#123;</div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'end'</span>)</div><div class="line">        <span class="keyword">this</span>.destory()</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  destory()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果文件被打开过 就关闭文件并且触发close事件</span></div><div class="line">    fs.close(<span class="keyword">this</span>.fd,()=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  pause()&#123;</div><div class="line">    <span class="keyword">this</span>.flowing = <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  resume()&#123;</div><div class="line">    <span class="keyword">this</span>.flowing = <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.read()</div><div class="line">  &#125;</div><div class="line">  open()&#123;</div><div class="line">    <span class="comment">//fd表示的就是当前this.path的这个文件，从3开始(number类型)</span></div><div class="line">    fs.open(<span class="keyword">this</span>.path,<span class="keyword">this</span>.flags,(err,fd)=&gt;&#123;</div><div class="line">      <span class="comment">//有可能fd这个文件不存在 需要做处理</span></div><div class="line">      <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="comment">//如果有自动关闭 则帮他销毁</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autoClose)&#123;</div><div class="line">          <span class="comment">//销毁（关闭文件，触发关闭文件事件）</span></div><div class="line">          <span class="keyword">this</span>.destory()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有错误 就会触发error事件</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'error'</span>,err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//保存文件描述符</span></div><div class="line">      <span class="keyword">this</span>.fd = fd</div><div class="line">      <span class="comment">//当文件打开成功时触发open事件</span></div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Readable"><a href="#Readable" class="headerlink" title="Readable"></a>Readable</h3><blockquote>
<p>这个方法是可读流的一种<code>暂停模式</code>，他的模式可以参考为读<code>流是往水杯倒水的人，Readable是喝水的人，他们之间存在着一种联系，只要Readable喝掉一点水，读流就会继续往里倒</code>。</p>
</blockquote>
<h4 id="Readable是什么？"><a href="#Readable是什么？" class="headerlink" title="Readable是什么？"></a>Readable是什么？</h4><ul>
<li>他会在刚开始监听Readable的时候就触发流的，此时流就会读取一次数据，之后<code>流会监听,如果有人读过流(喝过水)，并且减少，就会再去读一次(倒点水)</code></li>
<li>主要可以用来做<code>行读取器(LineReader)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> read = <span class="built_in">require</span>(<span class="string">'./ReadableStream'</span>)</div><div class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./a.txt'</span>, &#123;</div><div class="line">  <span class="comment">//每次读7个</span></div><div class="line">  highWaterMark: <span class="number">7</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">//如果读流第一次全部读下来并且小于highWaterMark，就会再读一次(再触发一次readable事件)</span></div><div class="line"><span class="comment">//如果rs.read()不加参数，一次性读完，会从缓存区再读一次，为null</span></div><div class="line"><span class="comment">//如果readable每次都刚好读完(即rs.read()的参数刚好和highWaterMark相等)，就会一直触发readable事件，如果最后不足他想喝的数，他就会先触发一次null，最后把剩下的喝完</span></div><div class="line"><span class="comment">//一开始缓存区为0的时候也会默认调一次readable事件</span></div><div class="line">rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> result = rs.read(<span class="number">2</span>)</div><div class="line">  <span class="built_in">console</span>.log(result)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>实战：行读取器(平常我们的文件可能有回车、换行，此时如果要每次想读一行的数据，就得用到<code>readable</code>)</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="comment">//如果要将内容全部读出就用on('data')，精确读取就用on('readable')</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineReader</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(path) &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.rs = fs.createReadStream(path)</div><div class="line">    <span class="comment">//回车符的十六进制</span></div><div class="line">    <span class="keyword">let</span> RETURN = <span class="number">0x0d</span></div><div class="line">    <span class="comment">//换行符的十六进制</span></div><div class="line">    <span class="keyword">let</span> LINE = <span class="number">0x0a</span></div><div class="line">    <span class="keyword">let</span> arr = []</div><div class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, (type) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (type === <span class="string">'newLine'</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</div><div class="line">          <span class="keyword">let</span> char</div><div class="line">          <span class="comment">//每次读一个，当读完的时候会返回null，终止循环</span></div><div class="line">          <span class="keyword">while</span> (char = <span class="keyword">this</span>.rs.read(<span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">switch</span> (char[<span class="number">0</span>]) &#123;</div><div class="line">              <span class="keyword">case</span> RETURN:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">              <span class="comment">//Mac下只有换行符，windows下是回车符和换行符，需要根据不同的转换。因为我这里是Mac</span></div><div class="line">              <span class="keyword">case</span> LINE:</div><div class="line">                <span class="comment">//如果是换行符就把数组转换为字符串</span></div><div class="line">                <span class="keyword">let</span> r = Buffer.from(arr).toString(<span class="string">'utf8'</span>)</div><div class="line">                <span class="comment">//把数组清空</span></div><div class="line">                arr.length = <span class="number">0</span></div><div class="line">                <span class="comment">//触发newLine事件，把得到的一行数据输出</span></div><div class="line">                <span class="keyword">this</span>.emit(<span class="string">'newLine'</span>, r)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">              <span class="keyword">default</span>:</div><div class="line">                <span class="comment">//如果不是换行符，就放入数组中</span></div><div class="line">                arr.push(char[<span class="number">0</span>])</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">//以上只能取出之前的换行符前的代码，最后一行的后面没有换行符，所以需要特殊处理。当读流读完需要触发end事件时</span></div><div class="line">    <span class="keyword">this</span>.rs.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">      <span class="comment">//取出最后一行数据，转成字符串</span></div><div class="line">      <span class="keyword">let</span> r = Buffer.from(arr).toString(<span class="string">'utf8'</span>)</div><div class="line">      arr.length = <span class="number">0</span></div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'newLine'</span>, r)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> lineReader = <span class="keyword">new</span> LineReader(<span class="string">'./a.txt'</span>)</div><div class="line">lineReader.on(<span class="string">'newLine'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>那么Readable到底是怎样的存在呢？我们接下来实现他的源码，看看内部到底怎么回事</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(path,options = &#123;&#125;)&#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.path = path</div><div class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span>*<span class="number">1024</span></div><div class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span></div><div class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span></div><div class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start     <span class="comment">//会随着读取的位置改变</span></div><div class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.end = options.end || <span class="literal">null</span></div><div class="line">    <span class="comment">//默认null就是buffer</span></div><div class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">//参数的问题</span></div><div class="line">    <span class="keyword">this</span>.reading = <span class="literal">false</span> <span class="comment">//非流动模式</span></div><div class="line">    <span class="comment">//创建个buffer用来存储每次读出来的数据</span></div><div class="line">    <span class="keyword">this</span>.buffers = []</div><div class="line">    <span class="comment">//缓存区长度</span></div><div class="line">    <span class="keyword">this</span>.len = <span class="number">0</span></div><div class="line">    <span class="comment">//是否要触发readable事件</span></div><div class="line">    <span class="keyword">this</span>.emittedReadable = <span class="literal">false</span></div><div class="line">    <span class="comment">//触发open获取文件的fd标识符</span></div><div class="line">    <span class="keyword">this</span>.open()</div><div class="line">    <span class="comment">//此方法默认同步调用 每次设置on监听事件时都会调用之前所有的newListener事件</span></div><div class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>,(type)=&gt;&#123;<span class="comment">// 等待着他监听data事件</span></div><div class="line">      <span class="keyword">if</span>(type === <span class="string">'readable'</span>)&#123;</div><div class="line">        <span class="comment">//开始读取 客户已经监听的data事件</span></div><div class="line">        <span class="keyword">this</span>.read()</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//readable真正的源码中的方法，计算出和n最接近的2的幂次数</span></div><div class="line">  computeNewHighWaterMark(n) &#123;</div><div class="line">    n--;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    n++;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">  &#125;</div><div class="line">  read(n)&#123;</div><div class="line">    <span class="comment">//当读的数量大于水平线，会通过取2的幂次取比他大和最接近的数</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.len &lt; n)&#123;</div><div class="line">      <span class="keyword">this</span>.highWaterMark = <span class="keyword">this</span>.computeNewHighWaterMark(n)</div><div class="line">      <span class="comment">//重新触发readbale的callback，所以第一次会触发null</span></div><div class="line">      <span class="keyword">this</span>.emittedReadable = <span class="literal">true</span></div><div class="line">      <span class="comment">//重新读新的水位线</span></div><div class="line">      <span class="keyword">this</span>._read()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//真正读取到的</span></div><div class="line">    <span class="keyword">let</span> buffer = <span class="literal">null</span></div><div class="line">    <span class="comment">//说明缓存里有这么多，取出来</span></div><div class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span> &amp;&amp; n&lt;=<span class="keyword">this</span>.len)&#123;</div><div class="line">      <span class="comment">//定义一个buffer</span></div><div class="line">      buffer = Buffer.alloc(n)</div><div class="line">      <span class="keyword">let</span> buf</div><div class="line">      <span class="keyword">let</span> flag = <span class="literal">true</span></div><div class="line">      <span class="keyword">let</span> index = <span class="number">0</span></div><div class="line">      <span class="comment">//[buffer&lt;1,2,3,4&gt;,buffer&lt;1,2,3,4&gt;,buffer&lt;1,2,3,4&gt;]</span></div><div class="line">      <span class="comment">//每次取出缓存前的第一个buffer</span></div><div class="line">      <span class="keyword">while</span>(flag &amp;&amp; (buf = <span class="keyword">this</span>.buffers.shift()))&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;buf.length;i++)&#123;</div><div class="line">          <span class="comment">//把取出的一个buffer中的数据放入新定义的buffer中</span></div><div class="line">          buffer[index++] = buf[i]</div><div class="line">          <span class="comment">//当buffer的长度和n(参数)长度一样时，停止循环</span></div><div class="line">          <span class="keyword">if</span>(index === n)&#123;</div><div class="line">            flag = <span class="literal">false</span></div><div class="line">            <span class="comment">//维护缓存，因为可能缓存中的buffer长度大于n，当取出n的长度时，还会剩下其余的buffer，我们需要切割buf并且放到缓存数组之前</span></div><div class="line">            <span class="keyword">this</span>.len -= n</div><div class="line">            <span class="keyword">let</span> r = buf.slice(i+<span class="number">1</span>)</div><div class="line">            <span class="keyword">if</span>(r.length)&#123;</div><div class="line">              <span class="keyword">this</span>.buffers.unshift(r)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果缓存区没有东西，等会读完需要触发readable事件</span></div><div class="line">    <span class="comment">//这里会有一种状况，就是如果每次Readable读取的数量正好等于highWaterMark(流读取到缓存的长度)，就会每次都等于0，每次都触发Readable事件，就会每次读，读到没有为止，最后还会触发一下null</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.len === <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">this</span>.emittedReadable = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.len &lt; <span class="keyword">this</span>.highWaterMark)&#123;</div><div class="line">      <span class="comment">//默认，一开始的时候开始读取</span></div><div class="line">      <span class="keyword">if</span>(!<span class="keyword">this</span>.reading)&#123;</div><div class="line">        <span class="keyword">this</span>.reading = <span class="literal">true</span></div><div class="line">        <span class="comment">//真正多读取操作</span></div><div class="line">        <span class="keyword">this</span>._read()</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> buffer&amp;&amp;buffer.toString()</div><div class="line">  &#125;</div><div class="line">  _read()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="comment">//等待着触发open事件后fd肯定拿到了 再去执行read方法</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>,()=&gt;&#123;<span class="keyword">this</span>._read()&#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//先读这么多buffer</span></div><div class="line">    <span class="keyword">let</span> buffer = Buffer.alloc(<span class="keyword">this</span>.highWaterMark)</div><div class="line">    fs.read(<span class="keyword">this</span>.fd,buffer,<span class="number">0</span>,buffer.length,<span class="keyword">this</span>.pos,(err,byteRead)=&gt;&#123;</div><div class="line">      <span class="keyword">if</span>(byteRead &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="comment">//当第一次读到数据后，改变reading的状态，如果触发read事件，可能还会在触发第二次_read</span></div><div class="line">        <span class="keyword">this</span>.reading = <span class="literal">false</span></div><div class="line">        <span class="comment">//每次读到数据增加缓存取得长度</span></div><div class="line">        <span class="keyword">this</span>.len += byteRead</div><div class="line">        <span class="comment">//每次读取之后，会增加读取的文件的读取开始位置</span></div><div class="line">        <span class="keyword">this</span>.pos += byteRead</div><div class="line">        <span class="comment">//将读到的buffer放入缓存区buffers中</span></div><div class="line">        <span class="keyword">this</span>.buffers.push(buffer.slice(<span class="number">0</span>,byteRead))</div><div class="line">        <span class="comment">//触发readable</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.emittedReadable)&#123;</div><div class="line">          <span class="keyword">this</span>.emittedReadable = <span class="literal">false</span></div><div class="line">          <span class="comment">//可以读取了，默认开始的时候杯子填满了</span></div><div class="line">          <span class="keyword">this</span>.emit(<span class="string">'readable'</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//没读到就出发end事件</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'end'</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  destory()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果文件被打开过 就关闭文件并且触发close事件</span></div><div class="line">    fs.close(<span class="keyword">this</span>.fd,()=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  open()&#123;</div><div class="line">    <span class="comment">//fd表示的就是当前this.path的这个文件，从3开始(number类型)</span></div><div class="line">    fs.open(<span class="keyword">this</span>.path,<span class="keyword">this</span>.flags,(err,fd)=&gt;&#123;</div><div class="line">      <span class="comment">//有可能fd这个文件不存在 需要做处理</span></div><div class="line">      <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="comment">//如果有自动关闭 则帮他销毁</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autoClose)&#123;</div><div class="line">          <span class="comment">//销毁（关闭文件，触发关闭文件事件）</span></div><div class="line">          <span class="keyword">this</span>.destory()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有错误 就会触发error事件</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'error'</span>,err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//保存文件描述符</span></div><div class="line">      <span class="keyword">this</span>.fd = fd</div><div class="line">      <span class="comment">//当文件打开成功时触发open事件</span></div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Readable和读流的data的区别就是，Readable可以控制自己从缓存区读多少和控制读的次数，而data是每次读取都清空缓存，读多少输出多少</li>
<li>我们可以看一下下面这个例子</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./a.txt'</span>)</div><div class="line">rs.on(<span class="string">'data'</span>,(data)=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(data)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//因为上面的data事件把数据读了，清空缓存区。所以导致下面的readable读出为null</span></div><div class="line">rs.on(<span class="string">'readable'</span>,()=&gt;&#123;</div><div class="line">  <span class="keyword">let</span> result = r.read(<span class="number">1</span>)</div><div class="line">  <span class="built_in">console</span>.log(result)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="自定义可读流"><a href="#自定义可读流" class="headerlink" title="自定义可读流"></a>自定义可读流</h3><p><strong>因为<code>createReadStream</code>内部调用了<code>ReadStream</code>类，<code>ReadStream</code>又实现了<code>Readable</code>接口,<code>ReadStream</code>实现了<code>_read()</code>方法,所以我们通过自定义一个类继承<code>stream</code>模块的<code>Readable</code>，并在<code>原型</code>上自定义一个<code>_read()</code>就可以自定义自己的可读流</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; Readable &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRead</span> <span class="keyword">extends</span> <span class="title">Readable</span></span>&#123;</div><div class="line">  <span class="comment">//流需要一个_read方法，方法中push什么，外面就接收什么</span></div><div class="line">  _read()&#123;</div><div class="line">    <span class="comment">//push方法就是上面_read方法中的push一样，把数据放入缓存区中</span></div><div class="line">    <span class="keyword">this</span>.push(<span class="string">'100'</span>)</div><div class="line">    <span class="comment">//如果push了null就表示没有东西可读了，停止(如果不写，就会一直push上面的值，死循环)</span></div><div class="line">    <span class="keyword">this</span>.push(<span class="literal">null</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="可写流"><a href="#可写流" class="headerlink" title="可写流"></a>可写流</h2><ul>
<li>如果文件不存在会创建，如果有内容会被清空</li>
<li>读取到highWaterMark的时候就会输出</li>
<li>第一次是真的写到文件 后面就是写入缓存区 再从缓存区里面去取</li>
</ul>
<h3 id="参数-和可读流的类似"><a href="#参数-和可读流的类似" class="headerlink" title="参数(和可读流的类似)"></a>参数(和可读流的类似)</h3><ul>
<li><code>path</code>:写入的文件的路径</li>
<li><code>option</code>:<ul>
<li><code>highWaterMark</code>:水位线，一次可写入缓存中的字节，一般默认是<code>64k</code></li>
<li><code>flags</code>:标识，写入文件要做的操作，默认是<code>w</code></li>
<li><code>encoding</code>:编码，默认为buffer</li>
<li><code>start</code>:开始写入的索引位置</li>
<li><code>end</code>:结束写入的索引位置(包括结束位置)</li>
<li><code>autoClose</code>:写入完毕是否关闭，默认为true</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>)</div><div class="line"><span class="comment">//读取的时候默认读64k </span></div><div class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(<span class="string">'./a.txt'</span>,&#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">2</span>,<span class="comment">//一次读的字节 默认64k</span></div><div class="line">  flags: <span class="string">'r'</span>,      <span class="comment">//标示 r为读 w为写</span></div><div class="line">  autoClose: <span class="literal">true</span>, <span class="comment">//默认读取完毕后自动关闭</span></div><div class="line">  start: <span class="number">0</span>,</div><div class="line">  <span class="attr">end</span>: <span class="number">5</span>,          <span class="comment">//流是闭合区间包start，也包end 默认是读完</span></div><div class="line">  encoding: <span class="string">'utf8'</span> <span class="comment">//默认编码是buffer</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="write"><a href="#write" class="headerlink" title="write"></a><code>write</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> ws = fs.createWriteStream(<span class="string">'./d.txt'</span>,&#123;</div><div class="line">  <span class="attr">flags</span>: <span class="string">'w'</span>,</div><div class="line">  <span class="attr">encoding</span>: <span class="string">'utf8'</span>,</div><div class="line">  <span class="attr">start</span>: <span class="number">0</span>,</div><div class="line">  <span class="comment">//write的highWaterMark只是用来触发是不是干了</span></div><div class="line">  highWaterMark: <span class="number">3</span> <span class="comment">//写是默认16k</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">//返回boolean 每当write一次都会在ws中吃下一个馒头 当吃下的馒头数量达到highWaterMark时 就会返回false 吃不下了会把其余放入缓存 其余状态返回true</span></div><div class="line"><span class="comment">//write只能放string或者buffer</span></div><div class="line">flag = ws.write(<span class="string">'1'</span>,<span class="string">'utf8'</span>,()=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(i)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="drain"><a href="#drain" class="headerlink" title="drain"></a><code>drain</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//drain只有嘴塞满了 吃完（包括内存中的，就是地下的）才会触发 这里是两个条件 一个是必须是吃下highWaterMark个馒头 并且在吃完的时候才会callback</span></div><div class="line">ws.on(<span class="string">'drain'</span>,()=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'干了'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16491a2ce2f22b41?w=1976&amp;h=1128&amp;f=jpeg&amp;s=170261" alt=""></p>
<h4 id="fs-write-可读流底层调用的就是这个方法，最原生的读方法"><a href="#fs-write-可读流底层调用的就是这个方法，最原生的读方法" class="headerlink" title="fs.write():可读流底层调用的就是这个方法，最原生的读方法"></a><code>fs.write()</code>:可读流底层调用的就是这个方法，最原生的读方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//wfd文件描述符，一般通过fs.open中获取</span></div><div class="line"><span class="comment">//buffer，要取数据的缓存源</span></div><div class="line"><span class="comment">//0，从buffer的0位置开始取</span></div><div class="line"><span class="comment">//BUFFER_SIZE，每次取BUFFER_SIZE这么长的长度</span></div><div class="line"><span class="comment">//index，每次写入文件的index的位置</span></div><div class="line"><span class="comment">//bytesRead，真实写入的个数</span></div><div class="line">fs.write(wfd,buffer,<span class="number">0</span>,bytesRead,index,<span class="function"><span class="keyword">function</span>(<span class="params">err,bytesWrite</span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="通过代码实现"><a href="#通过代码实现" class="headerlink" title="通过代码实现"></a>通过代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="comment">//只有第一次write的时候直接用_write写入文件 其余都是放到cache中 但是len超过了highWaterMark就会返回false告知需要drain 很占缓存</span></div><div class="line"><span class="comment">//从第一次的_write开始 回去一直通过clearBuffer递归_write写入文件 如果cache中没有了要写入的东西 会根据needDrain来判断是否触发干点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(path,options = &#123;&#125;)&#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.path = path</div><div class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span>*<span class="number">1024</span></div><div class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span></div><div class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span></div><div class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start</div><div class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="number">0o666</span></div><div class="line">    <span class="comment">//默认null就是buffer</span></div><div class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">//打开这个文件</span></div><div class="line">    <span class="keyword">this</span>.open()</div><div class="line"></div><div class="line">    <span class="comment">//写文件的时候需要哪些参数</span></div><div class="line">    <span class="comment">//第一次写入的时候 是给highWaterMark个馒头 他会硬着头皮写到文件中 之后才会把多余吃不下的放到缓存中</span></div><div class="line">    <span class="keyword">this</span>.writing = <span class="literal">false</span></div><div class="line">    <span class="comment">//缓存数组</span></div><div class="line">    <span class="keyword">this</span>.cache = []</div><div class="line">    <span class="keyword">this</span>.callbackList = []</div><div class="line">    <span class="comment">//数组长度</span></div><div class="line">    <span class="keyword">this</span>.len = <span class="number">0</span></div><div class="line">    <span class="comment">//是否触发drain事件</span></div><div class="line">    <span class="keyword">this</span>.needDrain = <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  clearBuffer()&#123;</div><div class="line">    <span class="comment">//取缓存中最上面的一个</span></div><div class="line">    <span class="keyword">let</span> buffer = <span class="keyword">this</span>.cache.shift()</div><div class="line">    <span class="keyword">if</span>(buffer)&#123;</div><div class="line">      <span class="comment">//有buffer的情况下</span></div><div class="line">      <span class="keyword">this</span>._write(buffer.chunk,buffer.encoding,()=&gt;<span class="keyword">this</span>.clearBuffer(),buffer.callback)</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">//没有的话 先看看需不需要drain</span></div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.needDrain)&#123;</div><div class="line">        <span class="comment">//触发drain 并初始化所有状态</span></div><div class="line">        <span class="keyword">this</span>.writing = <span class="literal">false</span></div><div class="line">        <span class="keyword">this</span>.needDrain = <span class="literal">false</span></div><div class="line">        <span class="keyword">this</span>.callbackList.shift()()</div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'drain'</span>)</div><div class="line">        </div><div class="line">      &#125;</div><div class="line">      <span class="keyword">this</span>.callbackList.map(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</div><div class="line">        v()</div><div class="line">      &#125;)</div><div class="line">      <span class="keyword">this</span>.callbackList.length = <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  _write(chunk,encoding,clearBuffer,callback)&#123;</div><div class="line">    <span class="comment">//因为write方法是同步调用的 所以可能还没获取到fd</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="comment">//直接在open的时间对象上注册一个一次性事件 当open被emit的时候会被调用</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>,()=&gt;<span class="keyword">this</span>._write(chunk,encoding,clearBuffer,callback))</div><div class="line">    &#125;</div><div class="line">    fs.write(<span class="keyword">this</span>.fd,chunk,<span class="number">0</span>,chunk.length,<span class="keyword">this</span>.pos,(err,byteWrite)=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.pos += byteWrite</div><div class="line">      <span class="comment">//每次写完 相应减少内存中的数量</span></div><div class="line">      <span class="keyword">this</span>.len -= byteWrite</div><div class="line">      <span class="keyword">if</span>(callback) <span class="keyword">this</span>.callbackList.push(callback)</div><div class="line">      <span class="comment">//第一次写完</span></div><div class="line">      clearBuffer()</div><div class="line">      </div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//写入方法</span></div><div class="line">  write(chunk,encoding=<span class="keyword">this</span>.encoding,callback)&#123;</div><div class="line">    <span class="comment">//判断chunk必须是字符串或者buffer 为了统一都变成buffer</span></div><div class="line">    chunk = Buffer.isBuffer(chunk)?chunk:Buffer.from(chunk,encoding)</div><div class="line">    <span class="comment">//维护缓存的长度 3</span></div><div class="line">    <span class="keyword">this</span>.len += chunk.length</div><div class="line">    <span class="keyword">let</span> ret = <span class="keyword">this</span>.len &lt; <span class="keyword">this</span>.highWaterMark</div><div class="line">    <span class="keyword">if</span>(!ret)&#123;</div><div class="line">      <span class="comment">//表示要触发drain事件</span></div><div class="line">      <span class="keyword">this</span>.needDrain = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//正在写入的应该放到内存中</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.writing)&#123;</div><div class="line">      <span class="keyword">this</span>.cache.push(&#123;</div><div class="line">        chunk,</div><div class="line">        encoding,</div><div class="line">        callback</div><div class="line">      &#125;)</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">//这里是第一次写的时候</span></div><div class="line">      <span class="keyword">this</span>.writing = <span class="literal">true</span></div><div class="line">      <span class="comment">//专门实现写的方法</span></div><div class="line">      <span class="keyword">this</span>._write(chunk,encoding,()=&gt;<span class="keyword">this</span>.clearBuffer(),callback)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// console.log(ret)</span></div><div class="line">    <span class="comment">//能不能继续写了 false代表下次写的时候更占内存</span></div><div class="line">    <span class="keyword">return</span> ret</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  destory()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果文件被打开过 就关闭文件并且触发close事件</span></div><div class="line">    fs.close(<span class="keyword">this</span>.fd,()=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  open()&#123;</div><div class="line">    <span class="comment">//fd表示的就是当前this.path的这个文件，从3开始(number类型)</span></div><div class="line">    fs.open(<span class="keyword">this</span>.path,<span class="keyword">this</span>.flags,(err,fd)=&gt;&#123;</div><div class="line">      <span class="comment">//有可能fd这个文件不存在 需要做处理</span></div><div class="line">      <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="comment">//如果有自动关闭 则帮他销毁</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autoClose)&#123;</div><div class="line">          <span class="comment">//销毁（关闭文件，出发关闭文件事件）</span></div><div class="line">          <span class="keyword">this</span>.destory()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有错误 就会触发error事件</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'error'</span>,err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//保存文件描述符</span></div><div class="line">      <span class="keyword">this</span>.fd = fd</div><div class="line">      <span class="comment">//当文件打开成功时触发open事件</span></div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自定义可写流"><a href="#自定义可写流" class="headerlink" title="自定义可写流"></a>自定义可写流</h3><p><strong>因为<code>createWriteStream</code>内部调用了<code>WriteStream</code>类，<code>WriteStream</code>又实现了<code>Writable</code>接口,<code>WriteStream</code>实现了<code>_write()</code>方法,所以我们通过自定义一个类继承<code>stream</code>模块的<code>Writable</code>，并在<code>原型</code>上自定义一个<code>_write()</code>就可以自定义自己的可写流</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; Writable &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWrite</span> <span class="keyword">extends</span> <span class="title">Writable</span></span>&#123;</div><div class="line">  _write(chunk,encoding,callback)&#123;</div><div class="line">    <span class="comment">//write()的第一个参数，写入的数据</span></div><div class="line">    <span class="built_in">console</span>.log(chunk)</div><div class="line">    <span class="comment">//这个callback，就相当于我们上面的clearBuffer方法，如果不执行callback就不会继续从缓存中取出写</span></div><div class="line">    callback()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> write = <span class="keyword">new</span> MyWrite()</div><div class="line">write.write(<span class="string">'1'</span>,<span class="string">'utf8'</span>,()=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><blockquote>
<p>管道流，是可读流上的方法，至于为什么放到这里，主要是因为需要2个流的基础知识，是可读流配合可写流的一种<code>传输方式</code>。如果用原来的读写，因为写比较<code>耗时</code>，所以会<code>多读少写</code>，<code>耗内存</code>，但用了<code>pipe</code>就不会了，始终用<code>规定</code>的内存。</p>
</blockquote>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="comment">//pipe方法叫管道 可以控制速率</span></div><div class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./d.txt'</span>,&#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">4</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">let</span> ws = fs.createWriteStream(<span class="string">'./e,txt'</span>,&#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">1</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">//会监听rs的on('data')将读取到的数据,通过ws.write的方法写入文件</span></div><div class="line"><span class="comment">//调用写的一个方法 返回boolean类型</span></div><div class="line"><span class="comment">//如果返回false就调用rs的pause方法 暂停读取</span></div><div class="line"><span class="comment">//等待可写流 写入完毕在监听drain resume rs</span></div><div class="line">rs.pipe(ws) <span class="comment">//会控制速率 防止淹没可用内存</span></div></pre></td></tr></table></figure>
<h3 id="自己实现一下"><a href="#自己实现一下" class="headerlink" title="自己实现一下"></a>自己实现一下</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="comment">//这两个是上面自己写的ReadStream和WriteStream</span></div><div class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>)</div><div class="line"><span class="keyword">let</span> WriteStream = <span class="built_in">require</span>(<span class="string">'./WriteStream'</span>)</div><div class="line"></div><div class="line"><span class="comment">//如果用原来的读写，因为写比较耗时，所以会多读少写，耗内存</span></div><div class="line">ReadStream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">'data'</span>,(data)=&gt;&#123;</div><div class="line">    <span class="keyword">let</span> flag = dest.write(data)</div><div class="line">    <span class="comment">//如果写入的时候嘴巴吃满了就不继续读了，暂停</span></div><div class="line">    <span class="keyword">if</span>(!flag)&#123;</div><div class="line">      <span class="keyword">this</span>.pause()</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="comment">//如果写的时候嘴巴里的吃完了，就会继续读</span></div><div class="line">  dest.on(<span class="string">'drain'</span>,()=&gt;&#123;</div><div class="line">    <span class="keyword">this</span>.resume()</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">'end'</span>,()=&gt;&#123;</div><div class="line">    <span class="keyword">this</span>.destory()</div><div class="line">    <span class="comment">//清空缓存中的数据</span></div><div class="line">    fs.fsync(dest.fd,()=&gt;&#123;</div><div class="line">      dest.destory()</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="双工流"><a href="#双工流" class="headerlink" title="双工流"></a>双工流</h2><blockquote>
<p>有了双工流，我们可以在同一个对象上<code>同时实现可读和可写</code>，就好像同时继承这两个接口。 重要的是双工流的可读性和可写性操作<code>完全独立</code>于彼此。这仅仅是将两个特性组合成一个对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; Duplex &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>)</div><div class="line"><span class="comment">//双工流，可读可写</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDuplex</span> <span class="keyword">extends</span> <span class="title">Duplex</span></span>&#123;</div><div class="line">  _read()&#123;</div><div class="line">    <span class="keyword">this</span>.push(<span class="string">'hello'</span>)</div><div class="line">    <span class="keyword">this</span>.push(<span class="literal">null</span>)</div><div class="line">  &#125;</div><div class="line">  _write(chunk,encoding,clearBuffer)&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk)</div><div class="line">    clearBuffer()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myDuplex = <span class="keyword">new</span> MyDuplex()</div><div class="line"><span class="comment">//process.stdin是node自带的process进程中的可读流，会监听命令行的输入</span></div><div class="line"><span class="comment">//process.stdout是node自带的process进程中的可写流，会监听并输出在命令行中</span></div><div class="line"><span class="comment">//所以这里的意思就是在命令行先输出hello，然后我们输入什么他就出来对应的buffer(先作为可读流出来)</span></div><div class="line">process.stdin.pipe(myDuplex).pipe(process.stdout)</div></pre></td></tr></table></figure>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><blockquote>
<p>转换流的输出是从输入中<code>计算</code>出来的。对于转换流，我们不必实现<code>read</code>或<code>write</code>的方法，我们只需要实现一个<code>transform</code>方法，将两者结合起来。它有<code>write</code>方法的意思，我们也可以用它来<code>push</code>数据。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; Transform &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span></span>&#123;</div><div class="line">  _transform(chunk,encoding,callback)&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk.toString().toUpperCase())</div><div class="line">    callback()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> myTransform = <span class="keyword">new</span> MyTransform()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform2</span> <span class="keyword">extends</span> <span class="title">Transform</span></span>&#123;</div><div class="line">  _transform(chunk,encoding,callback)&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk.toString().toUpperCase())</div><div class="line">    <span class="keyword">this</span>.push(<span class="string">'1'</span>)</div><div class="line">    <span class="comment">// this.push(null)</span></div><div class="line">    callback()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> myTransform2 = <span class="keyword">new</span> MyTransform2()</div><div class="line"></div><div class="line"><span class="comment">//此时myTransform2被作为可写流触发_transform，输出输入的大写字符后，会通过可读流push字符到下一个转换流中</span></div><div class="line"><span class="comment">//当写入的时候才会触发transform的值，此时才会push，所以后面的pipe拿到的chunk是前面的push的值</span></div><div class="line">process.stdin.pipe(myTransform2).pipe(myTransform)</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="可读流-1"><a href="#可读流-1" class="headerlink" title="可读流"></a>可读流</h3><ul>
<li>在 flowing 模式下， 可读流自动从系统底层读取数据，并通过 EventEmitter 接口的事件尽快将数据提供给应用。</li>
<li>在 paused 模式下，必须显式调用 stream.read() 方法来从流中读取数据片段。</li>
<li>所有初始工作模式为 paused 的 Readable 流，可以通过下面三种途径切换到 flowing 模式：<ul>
<li>监听 ‘data’ 事件</li>
<li>调用 stream.resume() 方法</li>
<li>调用 stream.pipe() 方法将数据发送到 Writable</li>
</ul>
</li>
<li>可读流可以通过下面途径切换到 paused 模式：<ul>
<li>如果不存在管道目标（pipe destination），可以通过调用 stream.pause() 方法实现。</li>
<li>如果存在管道目标，可以通过取消 ‘data’ 事件监听，并调用 stream.unpipe() 方法移除所有管道目标来实现。</li>
</ul>
</li>
</ul>
<h3 id="可写流-1"><a href="#可写流-1" class="headerlink" title="可写流"></a>可写流</h3><ul>
<li>需要知道只有在<code>嘴</code>真正的吃满了，并且等到把嘴里的和地上的馒头(缓存中的)都吃下了才会触发<code>drain</code>事件</li>
<li>第一次写入会直接写入文件中，后面会从缓存中一个个取</li>
</ul>
<h3 id="双工流-1"><a href="#双工流-1" class="headerlink" title="双工流"></a>双工流</h3><ul>
<li>只是对可写可读流的一种应用，既可作为可读流，也能作为可写流，并且作为可读或者可写时时<code>隔离</code>的</li>
</ul>
<h3 id="转换流-1"><a href="#转换流-1" class="headerlink" title="转换流"></a>转换流</h3><ul>
<li>一般转换流是边输入边输出的，而且一般只有触发了写入操作时才会进入<code>_transform</code>方法中。跟双工流的区别就是，他的可读可写是在<code>一起</code>的。</li>
</ul>
<p><strong>OK,讲完收工，从此你就是<code>流</code>魔王</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/13/164920c158bb431a?w=198&amp;h=130&amp;f=jpeg&amp;s=7736" alt=""></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/07/20/ReactSSR/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          React+Redux+socket.io+SSR+express+pm2+mongondb打造你的聊天app
        
      </div>
    </a>
  
  
    <a href="/2018/07/14/node事件环/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">node基础面试事件环？微任务、宏任务？一篇带你飞</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>








<section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'Shinemax'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>

</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>