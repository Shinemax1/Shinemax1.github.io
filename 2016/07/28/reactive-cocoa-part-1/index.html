<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>初识ReactiveCocoa | Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="关于ReactiveCocoaReactiveCocoa是iOS环境下的一个函数式响应式编程框架。函数式响应式编程（Functional Reactive Programming, FRP）这个概念由微软的牛X团队提出，ReactiveCocoa是受其启发而诞生的框架，应用范围非常广泛。
ReactiveCocoa至今已经发展出第4个版本了，而本文所针对的ReactiveCocoa版本是v2.5；">
<meta property="og:type" content="article">
<meta property="og:title" content="初识ReactiveCocoa">
<meta property="og:url" content="http://shinemax1.github.io/2016/07/28/reactive-cocoa-part-1/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="关于ReactiveCocoaReactiveCocoa是iOS环境下的一个函数式响应式编程框架。函数式响应式编程（Functional Reactive Programming, FRP）这个概念由微软的牛X团队提出，ReactiveCocoa是受其启发而诞生的框架，应用范围非常广泛。
ReactiveCocoa至今已经发展出第4个版本了，而本文所针对的ReactiveCocoa版本是v2.5；">
<meta property="og:updated_time" content="2016-08-08T12:02:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="初识ReactiveCocoa">
<meta name="twitter:description" content="关于ReactiveCocoaReactiveCocoa是iOS环境下的一个函数式响应式编程框架。函数式响应式编程（Functional Reactive Programming, FRP）这个概念由微软的牛X团队提出，ReactiveCocoa是受其启发而诞生的框架，应用范围非常广泛。
ReactiveCocoa至今已经发展出第4个版本了，而本文所针对的ReactiveCocoa版本是v2.5；">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.25px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 13.75px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 16.25px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.25px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 17.5px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 12.5px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.25px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 13.75px;">Tools</a> <a href="/tags/Transition/" style="font-size: 12.5px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 18.75px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js/" style="font-size: 11.25px;">js</a> <a href="/tags/js基础/" style="font-size: 20px;">js基础</a> <a href="/tags/node-js/" style="font-size: 11.25px;">node.js</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/事件环/" style="font-size: 10px;">事件环</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/宏任务/" style="font-size: 10px;">宏任务</a> <a href="/tags/微任务/" style="font-size: 10px;">微任务</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/流/" style="font-size: 10px;">流</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/面试/" style="font-size: 11.25px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，全栈开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-reactive-cocoa-part-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/28/reactive-cocoa-part-1/" class="article-date">
  	<time datetime="2016-07-28T14:31:28.000Z" itemprop="datePublished">2016-07-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      初识ReactiveCocoa
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ReactiveCocoa/">ReactiveCocoa</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关于ReactiveCocoa"><a href="#关于ReactiveCocoa" class="headerlink" title="关于ReactiveCocoa"></a>关于ReactiveCocoa</h2><p>ReactiveCocoa是iOS环境下的一个函数式响应式编程框架。<strong>函数式响应式编程</strong>（Functional Reactive Programming, FRP）这个概念由微软的牛X<a href="http://reactivex.io/" target="_blank" rel="external">团队</a>提出，ReactiveCocoa是受其<a href="https://msdn.microsoft.com/en-us/data/gg577609.aspx" target="_blank" rel="external">启发</a>而诞生的框架，应用范围非常广泛。</p>
<p>ReactiveCocoa至今已经发展出第4个版本了，而本文所针对的ReactiveCocoa版本是v2.5；照常例，下文将使用RAC代替ReactiveCocoa。</p>
<p>P.S: ReactiveCocoa 3.0已经放弃对iOS 7的支持，因此如果支持iOS 7，必须得使用更低的版本。因此，若想通过CocoaPods安装ReactiveCocoa v2.5，需要指明platform是低于v8.0的版本，譬如<code>platform :ios, &#39;7.0&#39;</code>。如果使用Swift语言，<a href="RxSwift">RxSwift</a>似乎是更好的选择。</p>
<p>在本文中，理解Signal是重头戏，个人认为，结合Sequence理解信号（Signal）比较容易一些，因此会花一些篇幅阐述Sequence；除此之外，还有必要介绍高阶函数和函数式编程。</p>
<p>P.S: Sequence在RAC中的地位越来越低，在Swift环境中，干脆被干掉了。</p>
<h2 id="高阶函数和函数式编程"><a href="#高阶函数和函数式编程" class="headerlink" title="高阶函数和函数式编程"></a>高阶函数和函数式编程</h2><p>从维基百科的<a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">解释</a>来看，一个高阶函数需要满足如下两个条件：</p>
<ul>
<li>一个或者多个函数作为输入；</li>
<li>有一个函数作为输出。</li>
</ul>
<p>P.S: 维基百科代表不了权威，至少在高阶函数这个问题上，网友存在分歧，有的人认为这两个条件满足一个即可；另一部分人认为二者皆不可缺。为了配合我所参考的资料 – <a href="https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details" target="_blank" rel="external">iOS的函数响应型编程</a> – 的说法，我只好选择后者。</p>
<p>有必要在了解ReactiveCocoa之前认识一下函数式编程，可以参考<a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="external">函数式编程初探</a>和<a href="https://kevinhm.gitbooks.io/functionalreactiveprogrammingonios/content/chapter3/functional_programming_with_RXCollections.html" target="_blank" rel="external">用RXCollections进行函数式编程</a>。</p>
<h2 id="流和序列"><a href="#流和序列" class="headerlink" title="流和序列"></a>流和序列</h2><p>RAC有一个核心概念叫<strong>流</strong>（Stream），它是data的序列化抽象。下文提到的<a href="http://limboy.me/" target="_blank" rel="external">LimBoy</a>把Signal比喻成水管，我认为完全可以把Stream也比喻成水管，data就好像流淌在水管中的玻璃球，玻璃球直径和水管内径相仿，只能依次流过。以我们当前的认知水平，data的序列化就好像是一个数组或者列表。Data在序列中依次被排好序，它们能像水管中的玻璃球一样流出来。</p>
<p>P.S: 「水管」和「玻璃球」比喻，我所知道的出处是<a href="http://limboy.me/" target="_blank" rel="external">LimBoy</a>，下文再解释Signal时会再次说明。</p>
<p>在RAC中，使用类<code>RACStream</code>抽象Stream，该类是个抽象类，本身不能被用来定义实例，用得更多的是它的两个子类：<code>RACSequence</code>和<code>RACSignal</code>。换句话说，在RAC中，有两种特定的流：序列（<code>RACSequence</code>）和信号（<code>RACSignal</code>）。</p>
<p>可以使用RAC为<code>NSArray</code>定义的category方法<code>rac_sequence</code>，将数组桥接为一个序列：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>];</div><div class="line">RACSequence *sequence1 = [array rac_sequence];</div></pre></td></tr></table></figure>
<p>可以对生成的<code>sequence1</code>进行map、filter等处理，得到一个新的序列，前者对序列中的每个data进行处理，后者将序列中的data进行匹配过滤。下面例子先进行map处理，对序列中的data进行平方处理，得到一个新的序列<code>sequence2</code>，然后再对新序列进行filter处理，将偶数给剔除掉，得到<code>sequence3</code>，最后，再将<code>sequence3</code>还原为<code>NSArray</code>，并将所有元素给打印出来：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">RACSequence *sequence2 = [sequence1 map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> * value) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSNumber</span> numberWithInteger:value.integerValue*value.integerValue];</div><div class="line">&#125;];</div><div class="line">RACSequence *sequence3 = [sequence2 filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span> * value) &#123;</div><div class="line">    <span class="keyword">return</span> value.integerValue % <span class="number">2</span> == <span class="number">1</span>;</div><div class="line">&#125;];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, sequence3.array);</div><div class="line"><span class="comment">// print: (1, 9)</span></div></pre></td></tr></table></figure>
<p>显然，上述的两个步骤其实可以链式串起来，这样至少可以将<code>sequence2</code>这个临时变量给省掉。</p>
<p>到了这里，应该对Sequence有了基本的理解了。</p>
<p>P.S: 文笔不佳，阅读《<a href="https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details" target="_blank" rel="external">iOS的函数响应型编程</a>》的前两章效果会更好。</p>
<p>P.S: 除了<code>NSArray</code>，还可以桥接为<code>RACSequence</code>的类型包括：<code>NSDictionary</code>、<code>NSEnumerator</code>、<code>NSIndexSet</code>、<code>NSSet</code>、<code>RACSequence</code>、<code>RACTuple</code>（RAC定义的一种类型，和其他语言譬如Swift中的<code>Tuple</code>类似）。</p>
<p>除了上面提到的map、filter，RAC的Stream还定义了其他很多基本操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)flattenMap:(RACStream * (^)(<span class="keyword">id</span> value))block;</div><div class="line">- (<span class="keyword">instancetype</span>)flatten;</div><div class="line">- (<span class="keyword">instancetype</span>)map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> value))block;</div><div class="line">- (<span class="keyword">instancetype</span>)filter:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> value))block;</div><div class="line">- (<span class="keyword">instancetype</span>)ignore:(<span class="keyword">id</span>)value;</div><div class="line">- (<span class="keyword">instancetype</span>)skip:(<span class="built_in">NSUInteger</span>)skipCount;</div><div class="line">- (<span class="keyword">instancetype</span>)take:(<span class="built_in">NSUInteger</span>)count;</div><div class="line">+ (<span class="keyword">instancetype</span>)zip:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams;</div></pre></td></tr></table></figure>
<p>如上只是其中一部分，更过基本操作详见<code>RACStream.h</code>。需要说明的是，上述的基本操作都是建立在如下API基础之上，<code>RACStream</code>并未实现这些API，得由子类（即<code>RACSequence</code>和<code>RACSignal</code>）自己实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)empty;</div><div class="line">+ (<span class="keyword">instancetype</span>)<span class="keyword">return</span>:(<span class="keyword">id</span>)value;</div><div class="line">- (<span class="keyword">instancetype</span>)bind:(RACStreamBindBlock (^)(<span class="keyword">void</span>))block;</div><div class="line">- (<span class="keyword">instancetype</span>)concat:(RACStream *)stream;</div><div class="line">- (<span class="keyword">instancetype</span>)zipWith:(RACStream *)stream;</div></pre></td></tr></table></figure>
<p>P.S: <code>RACStream</code>定义的如上5个抽象方法，sunnyxx在其博客<a href="http://blog.sunnyxx.com/2014/03/06/rac_2_racstream/]" target="_blank" rel="external">Reactive Cocoa Tutorial [2] = 百变RACStream</a>里已有比较好的说明，可以参考一下。</p>
<p>如何看待上述的基本方法呢？这些方法（无论是类方法还是实例方法）都返回<code>RACStream</code>对象，这意味着可以在它们的基础上进行<strong>链式调用</strong>，事实上达成了函数式编程的目的。</p>
<p>想想数学分支中的代数，最基础的运算无非是加减，在加减的基础上引出了乘除，然后有了各种各样更复杂的数学运算，譬如求导、微分、积分、卷积等等。对于Stream也一样，在理解这些基本操作后，我们就可以基于链式调用实现各种复杂的逻辑。</p>
<p>至于这些操作的具体意义及用法，本文先略过，以后再说。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>在RAC中，Signal也是一种Stream，可以被绑定和传递。把Sequence想象成Stream并不是很难，但把Signal理解成Stream还是蛮有挑战的。</p>
<p>如何理解Signal呢？能力有限，我也没有更好的表述。如下是一段在ReactiveCocoa的中文世界里被广泛传播的解释：</p>
<blockquote>
<p>可以把信号想象成水龙头，只不过里面不是水，而是玻璃球(data)，直径跟水管的内径一样，这样就能保证玻璃球是依次排列，不会出现并排的情况(数据都是线性处理的，不会出现并发情况)。水龙头的开关默认是关的，除非有了接收方(subscriber)，才会打开。这样只要有新的玻璃球进来，就会自动传送给接收方。可以在水龙头上加一个过滤嘴(filter)，不符合的不让通过，也可以加一个改动装置，把球改变成符合自己的需求(map)。也可以把多个水龙头合并成一个新的水龙头(combineLatest:reduce:)，这样只要其中的一个水龙头有玻璃球出来，这个新合并的水龙头就会得到这个球。</p>
</blockquote>
<p>P.S: 这段摘自LimBoy的博文<a href="http://limboy.me/tech/2013/06/19/frp-reactivecocoa.html" target="_blank" rel="external">ReactiveCocoa与Functional Reactive Programming</a>。</p>
<h3 id="Sequence-v-s-Signal"><a href="#Sequence-v-s-Signal" class="headerlink" title="Sequence v.s Signal"></a>Sequence v.s Signal</h3><p>Sequence和Signal都是Stream，但它们是不同类型的流。前者是pull-driven，后者是push-driven。所谓pull-driven，可以类比获取网页的方式，发起一个正确的HTTP请求，我们总会得到一些数据，因为数据就在服务端的数据库中躺着；而push-driven，可以类比推送（Push），数据并不是随时都有的，客户端也不知道什么时候该去获取，只能与服务端保持长连接，当服务端有新数据时，就主动推送（Push）过来。</p>
<p>对于初学者，理解pull-driven和push-driven这两个名词不是很容易，但理解Sequence和Signal的区别还是不难：对于Sequence而言，在它被创立之初，其中的data（玻璃球）是被确定的，可以从流中把它们一个一个查询出来；但对于Signal而言，在它（水管）被创立的时候，其中是没有data（玻璃球）的，data是之后在某个时刻（譬如notification发生时、网络请求完成时）才被放入的。</p>
<p>除了data驱动方式不同，Sequence和Signal所传递的data类型还不同，Sequence传递的是对象，Signal传递的是事件，无论是对象还是事件，在本文中都以data概述。</p>
<p>P.S: <code>RACSequence</code>和<code>RACSignal</code>可以互相转化，详见<a href="http://rcdp.io/Signal.html" target="_blank" rel="external">Signal</a>。</p>
<h3 id="Signal和Subscriber"><a href="#Signal和Subscriber" class="headerlink" title="Signal和Subscriber"></a>Signal和Subscriber</h3><p>对于Sequence而言，在其创立之初，其中的data就是确定的，经过一系列的操作（譬如map、filter）便可将同步将结果给取出来。</p>
<p>但对于Signal，不晓得什么时候才有data被放进去，显然不能同步等待处理结果。因而需要有一种机制来解决这个问题。</p>
<p>Subscription就是来解决这个问题的，Subscriber是Subscription中的核心概念，RAC定义<code>RACSubscriber</code>来描述它。关于Subscription和Subscriber，官方文档已经有非常清晰的表述，详见<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/FrameworkOverview.md#subscription" target="_blank" rel="external">这里</a>和<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/BasicOperators.md#subscription" target="_blank" rel="external">这里</a>。</p>
<p>P.S: 当把<strong>信号</strong>理解成<strong>流</strong>时，「signal」这个名词怎么看都觉得别扭，但当它和subscriber搭配时，却又显得那么和谐。</p>
<p>在描述signal和subscriber的关系时，<a href="http://limboy.me/tech/2013/12/27/reactivecocoa-2.html" target="_blank" rel="external">Limboy</a>使用插座和插头分别来类比它们，插座（signal）负责取电，插头（subscriber）负责使用电，一个插座可以插任意数量的插头。当一个插座没有插头时，什么都不会干，处于冷（cold）状态，只有插了插头才会去获取电，此时处于热（hot）状态。</p>
<p>上文已经提到Signal传递的data是event，它所传递的event包括3种：<strong>值事件</strong>、<strong>完成事件</strong>和<strong>错误事件</strong>。其中在传递值事件时，可以携带数据。</p>
<p>落实到代码层面，传递<strong>值事件</strong>、<strong>完成事件</strong>以及<strong>错误事件</strong>的本质就是向subscriber发送<code>sendNext:</code>、<code>sendComplete</code>以及<code>sendError:</code>消息，如下代码可以简单描述它们的关系：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 创建信号（冷信号）</span></div><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    <span class="comment">// block在什么时候被调用: 当信号被订阅时调用；</span></div><div class="line">  </div><div class="line">    <span class="comment">// 3. 模拟data（值事件）的产生</span></div><div class="line">    [subscriber sendNext:<span class="string">@"Hello"</span>];</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 2. 订阅信号（冷信号变热信号）</span></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="comment">// block什么时候被调用：当subscriber接收到sendNext:消息时；</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>上述代码中，步骤<code>2</code>在内部实现里创建一个<code>RACSubscriber</code>对象，该对象会被传入到步骤<code>3</code>所对应的block中。</p>
<h3 id="冷信号和热信号"><a href="#冷信号和热信号" class="headerlink" title="冷信号和热信号"></a>冷信号和热信号</h3><p>没有被订阅的信号被称为<strong>冷信号</strong>，冷信号默认情况下什么都不干，换句话说，冷信号的subscription block永远都不会被执行，譬如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RACSignal *coldSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"triggered"</span>);</div><div class="line">    [subscriber sendNext:<span class="string">@"hello, next"</span>];</div><div class="line">    [subscriber sendCompleted];</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这段代码创建了一个signal，但因为没有被subscribed，所以什么也不会发生。代码中使用类方法<code>createSignal:</code>创建一个<code>RACDynamicSignal</code>（<code>RACSignal</code>的子类）对象，后者有一个名为<code>didSubscribe</code>的Block属性，调用<code>createSignal:</code>传入的实参block被赋予该属性，当<code>RACDynamicSignal</code>被订阅（subscribe）时，会回调该block。</p>
<p>P.S: RAC中的<code>RACSignal</code>以类簇的方式实现，有点类似于Foundation中<code>NSString</code>、<code>NSArray</code>等，它定义了很多<code>RACSignal</code>子类，暂时不用理会这些子类，以后的博客中再详细介绍。</p>
<h3 id="Side-Effect"><a href="#Side-Effect" class="headerlink" title="Side Effect"></a>Side Effect</h3><p>如果某个<code>RACSignal</code>（以<code>RACDynamicSignal</code>为例）被多个subscriber订阅，那么它的<code>didSubscribe</code>会被多次调用吗？默认情况下是的，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    <span class="comment">// didSubscribe block</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"triggered"</span>);</div><div class="line">    [subscriber sendNext:<span class="string">@"test"</span>];</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscriber No.1: %@"</span>, x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"subscriber No.2: %@"</span>, x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">/* prints:</span></div><div class="line">triggered</div><div class="line">subscriber No.1: test</div><div class="line">triggered</div><div class="line">subscriber No.2: test</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>显然，<code>didSubscribe</code>被调用了两次。或许这是你想要的结果，或许不是；更多的时候这不是我们想要的结果，即所谓的<strong>副作用</strong>（side effect）。如果想要避免这种情况的发生，可以使用<code>reply</code>方法，它的作用是保证signal只被触发一次，然后把<code>sendNext:</code>的value给缓存起来，下一次再有新的subscriber时。直接发送缓存的value。如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    <span class="comment">// didSubscribe block</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"triggered"</span>);</div><div class="line">    [subscriber sendNext:<span class="string">@"test"</span>];</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">signal = [signal replay];</div><div class="line"></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscriber No.1: %@"</span>, x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscriber No.2: %@"</span>, x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">/* prints:</span></div><div class="line">triggered</div><div class="line">subscriber No.1: test</div><div class="line">subscriber No.2: test</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>P.S: 我对side effects的理解有问题，把它单纯想象成应该避免的负面东西，这是不对的。需要有更深刻的理解，得重写一下！还得思考「side effects里一般放什么样的代码？」。</p>
<p>To be continue…</p>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p>时至今日，ReactiveCocoa已经和AFNetWorking一样，变得非常大众了，关于它的学习资料也不像前两年那样稀缺，如下是我认为质量比较高的学习资料：</p>
<ul>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/tree/v2.5/Documentation" target="_blank" rel="external">ReactiveCocoa v2.5官方说明文档</a></li>
<li>LeeBoy的几篇ReactiveCocoa博文<ul>
<li><a href="http://limboy.me/tech/2013/06/19/frp-reactivecocoa.html" target="_blank" rel="external">ReactiveCocoa与Functional Reactive Programming</a></li>
<li><a href="http://limboy.me/tech/2013/12/27/reactivecocoa-2.html" target="_blank" rel="external">说说ReactiveCocoa 2</a></li>
<li><a href="http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html" target="_blank" rel="external">ReactiveCocoa2实战</a></li>
</ul>
</li>
<li><a href="https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details" target="_blank" rel="external">iOS的函数响应型编程</a>，非常浅显易懂。</li>
<li><a href="http://rcdp.io/" target="_blank" rel="external">ReactiveCocoa Design Patterns</a></li>
<li>美团点评技术团队分享的几篇关于冷信号和热信号的博客<ul>
<li><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1.html" target="_blank" rel="external">细说ReactiveCocoa的冷信号与热信号（一）</a></li>
<li><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-2.html" target="_blank" rel="external">细说ReactiveCocoa的冷信号与热信号（二）</a></li>
<li><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-3.html" target="_blank" rel="external">细说ReactiveCocoa的冷信号与热信号（三）</a></li>
</ul>
</li>
<li>Sunnyxx系列博客<ul>
<li><a href="http://blog.sunnyxx.com/2014/03/06/rac_0_overview/" target="_blank" rel="external">Reactive Cocoa Tutorial [0] = Overview</a></li>
<li><a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="external">Reactive Cocoa Tutorial [1] = 神奇的Macros</a></li>
<li><a href="http://blog.sunnyxx.com/2014/03/06/rac_2_racstream/" target="_blank" rel="external">Reactive Cocoa Tutorial [2] = 百变RACStream</a></li>
<li><a href="http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/" target="_blank" rel="external">Reactive Cocoa Tutorial [3] = RACSignal的巧克力工厂</a></li>
<li><a href="http://blog.sunnyxx.com/2014/04/19/rac_4_filters/" target="_blank" rel="external">Reactive Cocoa Tutorial [4] = 只取所需的Filters</a></li>
</ul>
</li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/07/28/reactive-cocoa-part-2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          RACSignal实践
        
      </div>
    </a>
  
  
    <a href="/2016/07/11/mvvm/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">mvvm</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>








<section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'Shinemax'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>

</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>