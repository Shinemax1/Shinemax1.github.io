<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/12/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.25px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 13.75px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 16.25px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.25px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 17.5px;">Objective-C</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/ReactiveCocoa/" style="font-size: 12.5px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/SSR/" style="font-size: 10px;">SSR</a> <a href="/tags/Sublime-Text/" style="font-size: 11.25px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 13.75px;">Tools</a> <a href="/tags/Transition/" style="font-size: 12.5px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 18.75px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js/" style="font-size: 11.25px;">js</a> <a href="/tags/js基础/" style="font-size: 20px;">js基础</a> <a href="/tags/node-js/" style="font-size: 11.25px;">node.js</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/事件环/" style="font-size: 10px;">事件环</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/宏任务/" style="font-size: 10px;">宏任务</a> <a href="/tags/微任务/" style="font-size: 10px;">微任务</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/流/" style="font-size: 10px;">流</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/面试/" style="font-size: 11.25px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，全栈开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-understanding-kvo" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/29/understanding-kvo/" class="article-date">
  	<time datetime="2015-04-29T02:00:01.000Z" itemprop="datePublished">2015-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/29/understanding-kvo/">深入理解KVO</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>程序设计语言中有各种各样的设计模式（pattern）和与此对应的反设计模式（anti-pattern），譬如singleton、factory、observer、MVC等等。对于基于Objective-C的iOS开发而言，有些设计模式几乎已经成为开发环境的一部分，譬如MVC，自打我们设计第一个页面开始就已经开始与之打交道了；KVO，即Key-Value Observing（根据我的理解它属于observer设计模式）也一样，只是它已经成为Objective-C事实标准了，作为一个iOS开发者，必须对它有相当的了解。</p>
<p>之前对KVO的了解仅限于使用层面，没有去想过它是如何实现的，更没有想过它会存在一些坑；甚至在刚接触它时，会尽可能创造机会使用它，譬如监听<code>UITextField#text</code>值的变化；但近几天接触了Objective-C的Runtime相关的知识，从Runtime层面了解到了KVO的实现原理（即KVO的消息转发机制），也通过阅读各位大神的博客了解到了它的坑。</p>
<p>本文首先分析KVO和Runtime的关系，阐述KVO的实现原理；然后结合大神们的博客整理KVO存在的坑以及避免掉坑的正确使用姿势。</p>
<h2 id="KVO和Runtime"><a href="#KVO和Runtime" class="headerlink" title="KVO和Runtime"></a>KVO和Runtime</h2><p>关于KVO，即Key-Value Observing，官方文档《Key-Value Observing Programming Guide》里的介绍比较简短明了：</p>
<blockquote>
<p>Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects.</p>
</blockquote>
<p><strong>KVO的实现</strong></p>
<p>KVO的实现也依赖于Objective-C的Runtime，官方文档《Key-Value Observing Programming Guide》中在《<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">Key-Value Observing Implementation Details</a>》部分简单提到它的实现：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling.<br>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.<br>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.<br>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
</blockquote>
<p>简单概述下KVO的实现：<br>当你观察一个对象（称该对象为<strong>被观察对象</strong>）时，一个新的类会动态被创建。这个类继承自<strong>被观察对象</strong>所对应类的，并重写该被观察属性的setter方法；针对setter方法的重写无非是在赋值语句前后加上相应的通知（或曰方法调用）；最后，把被观察对象的<code>isa</code>指针（<code>isa</code>指针告诉Runtime系统这个对象的类是什么）指向这个新创建的中间类，对象就神奇变成了新创建类的实例。</p>
<p>根据文档的描述，虽然被观察对象的<code>isa</code>指针被修改了，但是调用其<code>class</code>方法得到的类信息仍然是它之前所继承类的类信息，而不是这个新创建类的类信息。</p>
<p>补充：下面对<code>isa</code>指针和类方法<code>class</code>作以更多的说明。</p>
<p><code>isa</code>指针和类方法<code>class</code>的返回值都是<code>Class</code>类型，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">+ (Class)<span class="keyword">class</span>;</div></pre></td></tr></table></figure>
<p>根据我的理解，一般情况下，<code>isa</code>指针和<code>class</code>方法返回值都是一样的；但KVO底层实现时，动态创建的类只是重写了被观察属性的setter方法，并未重写类方法<code>class</code>，因此向被观察者发送<code>class</code>消息实际上仍然调用的是被观察者原先类的类方法<code>+(Class)class</code>，得到的类型信息当然是原先类的类信息，根据我的猜测，<code>isKindOfClass:</code>和<code>isMemberOfClass:</code>与<code>class</code>方法紧密相关。</p>
<p>国外的大神Mike Ash早在2009年就做了关于KVO的实现细节的探究，更多详细参考<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">这里</a>。</p>
<h2 id="KVO的槽点"><a href="#KVO的槽点" class="headerlink" title="KVO的槽点"></a>KVO的槽点</h2><p>AFNetworking作者Mattt Thompson在《<a href="http://nshipster.com/key-value-observing/" target="_blank" rel="external">Key-Value Observing</a>》中说：</p>
<blockquote>
<p>Ask anyone who’s been around the NSBlock a few times: Key-Value Observing has the worst API in all of Cocoa.</p>
</blockquote>
<p>另一位不认识的大神在《<a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a>》中也写道：</p>
<blockquote>
<p>KVO, or key-value observing, is a pattern that Cocoa provides for us for subscribing to changes to the properties of other objects. It’s hands down the most poorly designed API in all of Cocoa, and even when implemented perfectly, it’s still an incredibly dangerous tool to use, reserved only for when no other technique will suffice.</p>
</blockquote>
<p>总之，两位大神都认为KVO的API非常差劲！</p>
<p>其中《<a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a>》中对KVO的槽点有比较详细的阐述，这一部分内容就取材于此。</p>
<p>为了更好说明这些槽点，假设一个应用场景：<code>ZWTableViewController</code>继承自<code>UITableViewController</code>，它现在需要做一件事情，即监测<code>self.tableView.contentSize</code>的变化，现采用典型的方式（即KVO）处理这么个需求。</p>
<p><strong>所有的observe处理都放在一个方法里</strong></p>
<p>实现上述「监测<code>self.tableView.contentSize</code>的变化」的需求，最基本处理方式是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// register observer</span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    [_tableView addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"contentSize"</span> options:<span class="number">0</span> context:<span class="literal">NULL</span>];</div><div class="line">    <span class="comment">/* ... */</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// 处理observe</span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> configureView];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但考虑到<code>observeValueForKeyPath:ofObject:change:context:</code>中可能会很多其他的observe事务，所以<code>observeValueForKeyPath:ofObject:change:context:</code>更好的逻辑是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class="string">@"contentSize"</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> configureView];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但如果KVO处理的事情种类多且繁杂，这会造成<code>observeValueForKeyPath:ofObject:change:context:</code>代码特别长，极不优雅。</p>
<p><strong>严重依赖于string</strong></p>
<p>KVO严重依赖string，换句话说，KVO中的keyPath必须是<code>NSString</code>这个事实使得编译器没办法在编译阶段将错误的keyPath给找出来；譬如很容易将「contentSize」写成「contentsize」；</p>
<p><strong>需要自己处理superclass的observe事务</strong></p>
<p>对于Objective-C，很多时候Runtime系统都会自动帮助处理superclass的方法。譬如对于<code>dealloc</code>，假设类<code>Father</code>继承自<code>NSObject</code>，而类<code>Son</code>继承自<code>Father</code>，创建一个<code>Son</code>的实例<code>aSon</code>，在<code>aSon</code>被释放的时候，Runtime会先调用<code>Son#dealloc</code>，之后会自动调用<code>Father#dealloc</code>，而无需在<code>Son#dealloc</code>中显式执行<code>[super dealloc];</code>。但KVO不会这样，所以为了保证父类（父类可能也会自己observe事务要处理）的observe事务也能被处理，上述<code>observeValueForKeyPath:ofObject:change:context:</code>代码得改成这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class="string">@"contentSize"</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> configureView];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>多次相同的remove observer会导致crash</strong></p>
<p>写过KVO代码的人都知道，对同一个对象执行两次remove observer操作会导致程序crash。</p>
<p>在同一个文件中执行两次相同的remove observer属于粗心，比较容易debug出来；但是跨文件执行两次相同的remove observer就不是那么容易发现了。</p>
<p>我们一般会在<code>dealloc</code>中进行remove observer操作（这也是Apple所推荐的）。</p>
<p>譬如，假设上述的<code>ZWTableViewController</code>的父类<code>UITableViewController</code>也对<code>tableView.contentSize</code>注册了相同的监听；那么<code>UITableViewController#dealloc</code>中常常会写出如下这样的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[_tableView removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"contentSize"</span> context:<span class="literal">NULL</span>];</div></pre></td></tr></table></figure>
<p>按照一般习惯，<code>ZWTableViewController#dealloc</code>也会有相同的处理；那么当<code>ZWTableViewController</code>对象被释放时，<code>ZWTableViewController</code>的<code>dealloc</code>和其父类<code>UITableViewController</code>的<code>dealloc</code>都被调用，这样会导致相同的remove observer被执行两次，自然会导致crash。</p>
<p>《<a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a>》中还有很多其他的槽点，《<a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html" target="_blank" rel="external">Key-Value Observing Done Right</a>》也描述了一些，这里就不多说了，更多信息还是建议看原文。</p>
<p>不过好在上述的槽点「严重依赖于string」和「多次相同的remove observer会导致crash」有比较好的解决方案，如下会讲到。</p>
<h2 id="使用KVO"><a href="#使用KVO" class="headerlink" title="使用KVO"></a>使用KVO</h2><p>这一部分将阐述KVO的使用方法。</p>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>KVO中与订阅相关的API只有一个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure>
<p>对于这四个参数：</p>
<ul>
<li><strong>observer</strong>: The object to register for KVO notifications. The observer must implement the key-value observing method <code>observeValueForKeyPath:ofObject:change:context:</code>.</li>
<li><strong>keyPath</strong>: The key path, relative to the receiver, of the property to observe. This value must not be nil.</li>
<li><strong>options</strong>: A combination of the NSKeyValueObservingOptions values that specifies what is included in observation notifications. For possible values, see <code>NSKeyValueObservingOptions</code>.</li>
<li><strong>context</strong>: Arbitrary data that is passed to observer in <code>observeValueForKeyPath:ofObject:change:context:</code>.</li>
</ul>
<p>大神们认为这个API丑陋的重要原因是因为后面两个参数：options和context。</p>
<p>下面来对这两个参数进行详细介绍。</p>
<p>首先是<strong>options</strong>。options可选值是一个<code>NSKeyValueObservingOptions</code>枚举值，到目前为止，一共包括四个值，在介绍这四个值各自表示的意思之前，先得有一个概念，即KVO响应方法有一个<code>NSDictionary</code>类型参数change（下面<strong>响应</strong>中可以看到），这个字典中会有一个与被监听属性相关的值，譬如被改变之前的值、新值等，<code>NSDictionary</code>中有啥值由订阅时的options值决定，options可取值如下：</p>
<ul>
<li><code>NSKeyValueObservingOptionNew</code>: 指示change字典中包含新属性值；</li>
<li><code>NSKeyValueObservingOptionOld</code>: 指示change字典中包含旧属性值；</li>
<li><code>NSKeyValueObservingOptionInitial</code>: 相对复杂一些，NSKeyValueObserving.h文件中有详细说明，此处略过；</li>
<li><code>NSKeyValueObservingOptionPrior</code>: 相对复杂一些，NSKeyValueObserving.h文件中有详细说明，此处略过；</li>
</ul>
<p>现在细想，options这个参数也忒复杂了，难怪大神们觉得这个API丑陋（不过我等小民之前从未想过这个问题，=_=，没办法，Apple是个大帝国，我只是其中一个跪舔的小屁民）。</p>
<p>不过更糟心的是下面的context参数。</p>
<p>options信息量稍大，但其实蛮好理解的，然而对于context，在写这篇博客之前，一直不知道context参数有啥用（也没在意）。</p>
<p>context作用大了去了，在上面的<strong>KVO的槽点</strong>中提到一个槽点「多次相同的remove observer会导致crash」。导致「多次调用相同的remove observer」一个很重要的原因是我们经常在add observer时为context参数赋值<code>NULL</code>，关于如何使用context参数，下面会提到。</p>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>iOS的UI交互（譬如<code>UIButton</code>的一次点击）有一个非常不错的消息转发机制 – Target-Action模型，简单来说，为指定的event指定target和action处理方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span> *button = [<span class="built_in">UIButton</span> new];</div><div class="line">[button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buttonDidClicked:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>
<p>这种target-action模型逻辑非常清晰。作为对比，KVO的响应处理就非常糟糕了，所有的响应都对应是同一个方法<code>observeValueForKeyPath:ofObject:change:context:</code>，其原型如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure>
<p>除了<code>NSDictionary</code>类型参数change之外，其余几个参数都能在<code>addObserver:forKeyPath:options:context:</code>找到对应。</p>
<p>change参数上文已经讲过了，这里不多说了。下面将针对「严重依赖于string」和「多次相同的remove observer会导致crash」这两个槽点对keyPath和context参数进行阐述。</p>
<p><strong>keyPath</strong>。keyPath的类型是<code>NSString</code>，这导致了我们使用了错误的keyPath而不自知，譬如将<code>@&quot;contentSize&quot;</code>错误写成<code>@&quot;contentsize&quot;</code>，一个更好的方法是不直接使用<code>@&quot;xxxoo&quot;</code>，而是积极使用<code>NSStringFromSelector(SEL aSelector)</code>方法，即改<code>@&quot;contentSize&quot;</code>为<code>NSStringFromSelector(@selector(contentSize))</code>。</p>
<p><strong>context</strong>。对于context，上文已经提到一种场景：假如父类（设为<code>ClassA</code>）和子类（设为<code>ClassB</code>）都监听了同一个对象肿么办？是<code>ClassB</code>处理呢还是交给父类<code>ClassA</code>的<code>observeValueForKeyPath:ofObject:change:context:</code>处理呢？更复杂一点，如果子类的子类（设为<code>ClassC</code>）也监听了同一个对象，当<code>ClassB</code>接收到<code>ClassC</code>的<code>[super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</code>消息时又该如何处理呢？</p>
<p>这么一想，KVO的API还真的是设计非常糟糕。一般来说，比较靠谱的做法是自己的屁股自己擦。<code>ClassB</code>的observe事务在<code>ClassB</code>中处理，怎么知道是自己的事务还是<code>ClassC</code>传上来的事务呢？用context参数判断！</p>
<p>在add observer时为context参数设置一个独一无二的值即可，在responding处理时对这个context值进行检验。如此就解决了问题，但这需要靠用户（各个层级类的程序员用户）自觉遵守。</p>
<h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><p>和<strong>订阅</strong>以及<strong>响应</strong>不同，取消订阅有两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context;</div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div></pre></td></tr></table></figure>
<p>个人觉得应该尽可能使用第一个方法，保持「订阅-响应-取消订阅」的一致性嘛，养成好习惯！</p>
<p>此外，为了避免取消订阅时造成的crash，可以把取消订阅代码放在<code>@try-@catch</code>语句中，如下是一个比较全面的的KVO使用示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> * zwContentSize = &amp;zwContentSize;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">// 1. subscribe</span></div><div class="line">    [_tableView addObserver:<span class="keyword">self</span></div><div class="line">                 forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(contentSize))</div><div class="line">                    options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">                    context:zwContentSize];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// 2. responding</span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    <span class="keyword">if</span> (context == zwContentSize) &#123;</div><div class="line">        <span class="comment">// configure view</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    <span class="keyword">@try</span> &#123;</div><div class="line">        <span class="comment">// 3. unsubscribe</span></div><div class="line">        [_tableView removeObserver:<span class="keyword">self</span></div><div class="line">                        forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(contentSize))</div><div class="line">                           context:zwContentSize];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总之，KVO很强大，但也挺坑，使用它要养成好习惯，避免入坑！</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《Key-Value Observing Programming Guide》</li>
<li>《<a href="http://tech.glowing.com/cn/implement-kvo/" target="_blank" rel="external">如何自己动手实现KVO</a>》</li>
<li>《<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">KVO Implementation</a>》</li>
<li>《<a href="https://www.mikeash.com/pyblog/friday-qa-2010-11-6-creating-classes-at-runtime-in-objective-c.html" target="_blank" rel="external">Creating Classes at Runtime in Objective-C</a>》</li>
<li>《<a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html" target="_blank" rel="external">Key-Value Observing Done Right</a>》</li>
<li>《<a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a>》；</li>
<li>《<a href="http://nshipster.com/key-value-observing/" target="_blank" rel="external">Key-Value Observing</a>》</li>
<li>《<a href="http://objccn.io/issue-7-3/" target="_blank" rel="external">KVC和KVO</a>》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVO/">KVO</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-initialize-and-load-in-objective-c" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/28/initialize-and-load-in-objective-c/" class="article-date">
  	<time datetime="2015-04-28T06:14:13.000Z" itemprop="datePublished">2015-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/28/initialize-and-load-in-objective-c/">Objective-C中的+initialize和+load</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>近几天花了一些时间了解了一下Objective-C runtime相关的东西，其中涉及到了<code>+load</code>方法，譬如method swizzling通常在category的<code>+load</code>方法中完成。之前对initializer和load的使用就比较疑惑，但一直没有详细去对比了解，以此为契机，集各方资源，分析一下吧！</p>
<p>关于了解<code>+initialize</code>和<code>+load</code>，个人感觉参考官方文档《NSObject Class Reference》就够了。</p>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h2><p>关于<code>+initialize</code>方法，《NSObject Class Reference》的介绍如下：</p>
<blockquote>
<p>Initializes the class before it receives its first message.</p>
</blockquote>
<p>可以理解<code>+initialize</code>的作用是为了该Class在使用前创建合适的环境；</p>
<p>关于其使用，《NSObject Class Reference》的说明如下：</p>
<blockquote>
<p>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses. The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize].</p>
</blockquote>
<p>这上面这段话，可以得出如下这么一些意思：</p>
<ul>
<li><code>+initialize</code>方法是在runtime被调用的；</li>
<li>对于某个类，其类<code>+initialize</code>方法都会在该对象接受任何消息之前被调用；</li>
<li>如果父类和子类的<code>+initialize</code>方法都被调用，父类的调用一定在子类之前，这是系统自动完成的，子类<code>+initialize</code>中没必要显式调用<code>[super initialize];</code>；</li>
<li>runtime系统处理<code>+initialize</code>消息的方式是线程安全的，所以没必要在<code>+initialize</code>中为了保证线程安全而使用lock、mutex之类的线程安全工具；</li>
<li>某个类的<code>+initialize</code>的方法不一定只被调用一次，至少有两种情况会被调用多次：<ul>
<li>子类显式调用<code>[super initialize];</code>；</li>
<li>子类没有实现<code>+initialize</code>方法；</li>
</ul>
</li>
</ul>
<p>下面以示例演示某个类的<code>+initialize</code>被多次执行的现象。</p>
<p>定义三个类：<code>Person</code>、<code>Student</code>、<code>Teacher</code>，<code>Student</code>和<code>Teacher</code>继承自<code>Person</code>，<code>Person</code>继承自<code>NSObject</code>。<code>Person</code>和<code>Student</code>都实现了<code>+initialize</code>方法，<code>Teacher</code>没有实现该方法，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person的+initialize方法的实现</span></div><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Person initialize"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// Student的+initialize方法的实现</span></div><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Student initialize"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行效果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    Student *aStudent = [[Student alloc] init];</div><div class="line">    Teacher *aTeacher = [[Teacher alloc] init];</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/* 输出：</span></div><div class="line">Person initialize</div><div class="line">Student initialize</div><div class="line">Person initialize</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>可以看到，对于<code>Student</code>，在其<code>+initialize</code>方法被调用之前，其super class（<code>Person</code>）的<code>+initialize</code>方法被率先调用；对于<code>Teacher</code>，没有定义<code>+initialize</code>方法，所以它会直接调用super class（Person）的<code>+initialize</code>方法，这就导致了Person的<code>+initialize</code>方法被执行两次。</p>
<p>有没有办法避免<code>Person</code>的<code>+initialize</code>方法被多次调用？当然可以：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person的+initialize方法的实现</span></div><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">BOOL</span> b = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (!b) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Person initialize"</span>);</div><div class="line">        b = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person的+initialize方法的实现</span></div><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [Person <span class="keyword">class</span>]) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Person initialize"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>《NSObject Class Reference》中还对<code>+initialize</code>方法的使用做了一些警告：</p>
<blockquote>
<p>Because initialize is called in a thread-safe manner and the order of initialize being called on different classes is not guaranteed, it’s important to do the minimum amount of work necessary in initialize methods. Specifically, any code that takes locks that might be required by other classes in their initialize methods is liable to lead to deadlocks. Therefore you should not rely on initialize for complex initialization, and should instead limit it to straightforward, class local initialization.</p>
</blockquote>
<p>总结一下，就是这样：不要在<code>+initialize</code>中处理复杂的逻辑！</p>
<p>那么<code>+initialize</code>可以做些什么事情呢？可以做一些简单的初始化工作，譬如对于某个继承自<code>UICollectionViewCell</code>的自定义类<code>PhotoViewCell</code>，<code>PhotoViewCell</code>的对象可能会有一些公用资源，譬如label color，label font等等，没必要在<code>-initXXOO</code>方法中创建这些完全一样的资源，此时就可以放在<code>PhotoViewCell</code>中的<code>+initialize</code>中完成，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    titleFont       = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12</span>];</div><div class="line">    titleHeight     = <span class="number">20.0</span>f;</div><div class="line">    videoIcon       = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CTAssetsPickerVideo"</span>];</div><div class="line">    titleColor      = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">    checkedIcon     = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CTAssetsPickerChecked"</span>];</div><div class="line">    selectedColor   = [<span class="built_in">UIColor</span> colorWithWhite:<span class="number">1</span> alpha:<span class="number">0.3</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>+initialize</code>终究还是带来惊人的信息量，颇为失望。</p>
<h2 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h2><p>关于<code>+load</code>方法，《NSObject Class Reference》的介绍如下：</p>
<blockquote>
<p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>
</blockquote>
<p>关于其使用，《NSObject Class Reference》的说明如下：</p>
<blockquote>
<p>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p>
<p>The order of initialization is as follows:</p>
<blockquote>
<ol>
<li>All initializers in any framework you link to.</li>
<li>All +load methods in your image.</li>
<li>All C++ static initializers and C/C++ <strong>attribute</strong>(constructor) functions in your image.</li>
<li>All initializers in frameworks that link to you.</li>
</ol>
</blockquote>
<p>In addition:</p>
<ul>
<li>A class’s +load method is called after all of its superclasses’ +load methods.</li>
<li>A category +load method is called after the class’s own +load method.<br>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</li>
</ul>
</blockquote>
<p>从这段文字可以读出如下信息：</p>
<ul>
<li>在一个程序（main函数）运行之前，所用到的库被加载到runtime之后，被添加到的runtime系统的各种类和category的<code>+load</code>方法就被调用；（关于这点很容易通过打印语句来验证）；</li>
<li>如果父类和子类的<code>+load</code>方法都被调用，父类的调用一定在子类之前，这是系统自动完成的，子类<code>+load</code>中没必要显式调用<code>[super load];</code>；</li>
<li>文档没有讲明<code>+load</code>的执行是否是线程安全的，但考虑到它是在runtime之前就调用，所以谈论它是否是线程安全没啥必要，根据我的理解，多线程在runtime才有谈论意义；</li>
<li>若某个类由一个主类和多个category组成，则允许主类和category中各自有自己的<code>+load</code>方法，只是category中的<code>+load</code>的执行在主类的<code>+load</code>之后；</li>
</ul>
<p>关于<code>+load</code>的使用场景，笔者知道的至少有一个，method swizzling的处理一般都在category的<code>+load</code>中完成的，参考<a href="/unstanding-objective-c-runtime-part-4/">这里</a>。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《NSObject Class Reference》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-understanding-objective-c-runtime-part-4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/27/understanding-objective-c-runtime-part-4/" class="article-date">
  	<time datetime="2015-04-27T13:10:53.000Z" itemprop="datePublished">2015-04-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/27/understanding-objective-c-runtime-part-4/">理解Objective-C Runtime（四）Method Swizzling</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Objective-C对象收到消息之后，究竟会调用何种方法需要在运行期间才能解析出来。那你也许会问：与给定的选择子名称相应的方法是不是也可以在runtime改变呢？没错，就是这样。<strong>若能善用此特性，则可发挥出巨大优势，因为我们既不需要源代码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能</strong>。这样一来，新功能将在本类的所有实例中生效，而不仅限于覆写了相关方法的那些子类实例。此方案就是大名鼎鼎的<strong>method swizzling</strong>，中文常称之为「方法调配」或「方法调和」或「方法混合」。</p>
<h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h2><p><strong>类的方法列表会把选择子的名称映射到相关的方法实现之上</strong>，使得<strong>动态消息派发系统</strong>（dynamic message-dispatch system）能够据此找到应该调和的方法。这些方法均以函数指针的形式来表示，这种指针叫IMP（IMP在《<a href="/understanding-objective-c-runtime-part-1/">理解Objective-C Runtime（一）预备知识</a>》已有说明）。</p>
<p>举个栗子，<code>NSString</code>类可以响应<code>lowercaseString</code>、<code>uppercaseString</code>、<code>capitalizedString</code>等选择子。这张映射表（selector table，也常称为<strong>选择器表</strong>）中的每个选择子都映射到不同的IMP之上，如下图所示：</p>
<div class="imagediv" style="width: 500px; height: 200px"></div>

<p>Objective-C runtime系统提供的几个方法都能够用来操作这张表。开发者可以向其中新增selector，也可以改变某个selector所对应的方法实现，还可以交换两个selector所映射到的指针。经过几次操作之后，类的方法就会变成如下图所示：</p>
<div class="imagediv" style="width: 500px; height: 250px"></div>

<p>在新的映射表中，多了一个名为newSelector的选择子，lowercaseString和uppercaseString的实现则互换了。上述修改均无需编写子类，只要修改<strong>方法表</strong>的布局即可，就会反映到程序中所有的NSString实例之上。</p>
<h2 id="交换两个方法的实现"><a href="#交换两个方法的实现" class="headerlink" title="交换两个方法的实现"></a>交换两个方法的实现</h2><p>现在通过示例代码演绎「调换<code>NSString</code>的<code>lowercaseString</code>和<code>uppercaseString</code>的方法实现」，具体实现操作是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *aString = <span class="string">@"AbcDEfg"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// lowercaseString和uppercaseString交换前：</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"lowercaseString和uppercaseString交换前："</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"lowercase of the string : %@"</span>, [aString lowercaseString]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"uppercase of the string : %@"</span>, [aString uppercaseString]);</div><div class="line">    </div><div class="line">    <span class="comment">// class_getInstanceMethod方法得到Method类型</span></div><div class="line">    Method originalMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(lowercaseString));</div><div class="line">    Method swappedMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(uppercaseString));</div><div class="line">    </div><div class="line">    <span class="comment">// method_exchangeImplementations交换映射指针</span></div><div class="line">    method_exchangeImplementations(originalMethod, swappedMethod);</div><div class="line">    </div><div class="line">    <span class="comment">// lowercaseString和uppercaseString交换后：</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"lowercaseString和uppercaseString交换后："</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"lowercase of the string : %@"</span>, [aString lowercaseString]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"uppercase of the string : %@"</span>, [aString uppercaseString]);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/* 输出结果：</span></div><div class="line">lowercaseString和uppercaseString交换前：</div><div class="line">lowercase of the string : abcdefg</div><div class="line">uppercase of the string : ABCDEFG</div><div class="line">lowercaseString和uppercaseString交换后：</div><div class="line">lowercase of the string : ABCDEFG</div><div class="line">uppercase of the string : abcdefg</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>这演示了如何交换两个方法的实现，然而在实际应用中，像这样直接交换两个方法实现，其意义不大，除非闲得蛋疼。但是，可以通过这一手段来为既有的方法实现增添新功能。</p>
<h2 id="修改既有方法的行为"><a href="#修改既有方法的行为" class="headerlink" title="修改既有方法的行为"></a>修改既有方法的行为</h2><p>介绍一个技巧，最好的方式就是提出具体的需求，然后用它跟其他的解决方法做比较。</p>
<p>所以，先来看看我们的需求：对 App 的用户行为进行追踪和分析。简单说，就是当用户看到某个View或者点击某个Button的时候，就把这个事件记下来。</p>
<p><strong>手动添加</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyViewController</span> ()</span></div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</div><div class="line">    </div><div class="line">    <span class="comment">// Custom code </span></div><div class="line">    </div><div class="line">    <span class="comment">// Logging</span></div><div class="line">    [Logging logWithEventName:<span class="string">@"my view did appear"</span>];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)myButtonClicked:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Custom code </span></div><div class="line">    </div><div class="line">    <span class="comment">// Logging</span></div><div class="line">    [Logging logWithEventName:<span class="string">@"my button clicked"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式的缺点也很明显：它破坏了代码的干净整洁。因为Logging的代码本身并不属于View Controller里的主要逻辑。随着项目扩大、代码量增加，你的View Controller里会到处散布着Logging的代码。这时，要找到一段事件记录的代码会变得困难，也很容易忘记添加事件记录的代码。</p>
<p>你可能会想到用继承或类别，在重写的方法里添加事件记录的代码。代码可以是长的这个样子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)myViewDidAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</div><div class="line">    </div><div class="line">    <span class="comment">// Custom code </span></div><div class="line">    </div><div class="line">    <span class="comment">// Logging</span></div><div class="line">    [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)myButtonClicked:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Custom code </span></div><div class="line">    </div><div class="line">    <span class="comment">// Logging</span></div><div class="line">    <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithFormat:@“my button <span class="keyword">in</span> %@ is clicked”, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</div><div class="line">    [Logging logWithEventName:name];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Logging 的代码都很相似，通过继承或类别重写相关方法是可以把它从主要逻辑中剥离出来。但同时也带来新的问题：</p>
<ol>
<li>你需要继承<code>UIViewController</code>，<code>UITableViewController</code>，<code>UICollectionViewController</code>所有这些View Controller，或者给他们添加类别；</li>
<li>每个View Controller里的ButtonClick方法命名不可能都一样；</li>
<li>你不能控制别人如何去实例化你的子类；</li>
<li>对于类别，你没办法调用到原来的方法实现，大多时候，我们重写一个方法只是为了添加一些代码，而不是完全取代它；</li>
<li>如果有两个类别都实现了相同的方法，运行时没法保证哪一个类别的方法会给调用。</li>
</ol>
<p><strong>Method Swizzling的做法</strong></p>
<p>Method Swizzling的做法是新增一个方法<code>log_viewDidAppear:</code>，在这个方法体中调用<code>viewDidAppear:</code>的方法体；然后将<code>log_viewDidAppear:</code>和<code>viewDidAppear:</code>进行调换。呃，有些绕，看图吧：</p>
<div class="imagediv" style="width: 505px; height: 154px"></div>

<p>新增方法<code>log_viewDidAppear:</code>的实现代码可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)log_viewDidAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> log_viewDidAppear:animated];</div><div class="line">        </div><div class="line">    <span class="comment">// Logging</span></div><div class="line">    [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看起来，这段代码好像会陷入递归使用的死循环，不过要记住，此方法是准备和<code>viewDidAppear:</code>方法互换的。所以，在runtime，<code>log_viewDidAppear:</code>选择子对应的是原来<code>viewDidAppear:</code>方法的实现；同样，当向对象发送<code>viewDidAppear:</code>消息时，如上这段代码会被调用，而这段代码的第一句是<code>[self log_viewDidAppear:animated];</code>，这其实是调用原来<code>viewDidAppear:</code>方法的实现代码…</p>
<p>定义了<code>log_viewDidAppear:</code>的实现后，还得与<code>viewDidAppear:</code>进行交换：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// class_getInstanceMethod方法得到Method类型</span></div><div class="line">Method originalMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidAppear:));</div><div class="line">Method swappedMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(log_viewDidAppear:));</div><div class="line">    </div><div class="line"><span class="comment">// method_exchangeImplementations交换映射指针</span></div><div class="line">method_exchangeImplementations(originalMethod, swappedMethod);</div></pre></td></tr></table></figure>
<p>如何安排method swizzling相关的代码？</p>
<p>一般来说，runtime相关的代码都会以category的形式组织，所以上述<code>log_viewDidAppear:</code>方法的实现会写在一个UIViewController category中，比如<code>UIViewController+log.h</code>。而<strong>交换方法</strong>相关的代码会写在category的load中。因为load方法是在runtime之前就被执行的，只要category所在的头文件被引用，load方法就会被调用，并且同一个class在不同category之间允许有多个load方法，这些load方法都会被调用（唯一的问题是谁先谁后）。</p>
<p>通过method swizzling方案，开发者可以为那些完全不知道具体实现的（completely opaque，完全不透明）黑盒方法增加日志记录功能，这非常有助于程序调试，然而，此做法只在调试程序时有用。很少有人在调试程序之外的场合用上述<strong>方法调配技术</strong>来永久改变某个类的功能，因为如果使用不慎，它造成的破坏太大了，并且很难Debug。不能仅仅因为Objective-C语言里有这个特性就一定要用它。若是滥用，反而会令代码变得不易读懂且难于维护。</p>
<p>总之，Method Swizzling只一个挺有争议的技术，对此有很多分析的文章，底部的参考资料中有链接。</p>
<p><strong>补充</strong></p>
<p>后来终于有机会在实际项目中使用到method swizzling。应用场景是这样的，接手了一个完整的项目，我的任务是在该项目基础上添加一些功能，顺便将项目整理一下，尽可能清理没有用的内容和过时的技术。项目页面非常多，各种文件的命名非常糟糕，我首先需要做的事情是将页面逻辑给整理出来（各种View Controller之间的逻辑关系），简单来说，我需要结合所看到的运行页面（譬如首页），将它的View Controller类给找出来。</p>
<p>比较蠢的做法当然是去查看代码了。好在我比较机灵，决定使用method swizzling技术，让每个页面将它的View Controller类名自己喊出来。</p>
<p>我的思路：定义一个UIViewController category，添加一个方法，该方法调用<code>viewDidAppear:</code>，并且将该类的名字给打印出来，然后将该方法的SEL和<code>viewDidAppear:</code>方法的SEL调换，这样系统在回调<code>viewDidAppear:</code>时会定义该方法代码，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">sayHello</span>)</span></div><div class="line"> </div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">    SEL originalSelector = <span class="keyword">@selector</span>(viewDidAppear:);</div><div class="line">    SEL swizzledSelector = <span class="keyword">@selector</span>(swizzled_viewDidAppear:);</div><div class="line">    </div><div class="line">    <span class="comment">// class_getInstanceMethod方法得到Method类型</span></div><div class="line">    Method originalMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], originalSelector);</div><div class="line">    Method swizzledMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], swizzledSelector);</div><div class="line"> </div><div class="line">    <span class="comment">// method_exchangeImplementations交换映射指针</span></div><div class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)swizzled_viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">self</span> swizzled_viewDidAppear:animated];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hello, my name is %@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="AOP-Aspect-Oriented-Programming"><a href="#AOP-Aspect-Oriented-Programming" class="headerlink" title="AOP(Aspect Oriented Programming)"></a>AOP(Aspect Oriented Programming)</h2><p>在阅读博客《<a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">Method Swizzling和AOP实践</a>》时了解到了一个新概念 – <code>AOP</code>。</p>
<p>简单来说，在Objective-C世界中，AOP就是利用Runtime特性给指定的方法添加自定义代码，Method Swizzling是其中一种实现AOP的方式之一。</p>
<p>Mark一下，暂不多讲。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《Effective Objective-C 2.0》</li>
<li>《iOS开发进阶》</li>
<li>《<a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">Method Swizzling和AOP实践</a>》</li>
<li>大神Mattt Thompson（AFNetworking作者）的《<a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">Method Swizzling</a>》</li>
<li>《<a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="external">Objective-C的hook方案（一）: Method Swizzling</a>》</li>
<li><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="external">What are the Dangers of Method Swizzling in Objective C?</a>；</li>
<li>《<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/#Method_Swizzling" target="_blank" rel="external">Objective-C Runtime</a>》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Runtime/">Runtime</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-understanding-objective-c-runtime-part-3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/27/understanding-objective-c-runtime-part-3/" class="article-date">
  	<time datetime="2015-04-27T07:41:47.000Z" itemprop="datePublished">2015-04-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/27/understanding-objective-c-runtime-part-3/">理解Objective-C Runtime（三）消息转发机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="消息转发机制概述"><a href="#消息转发机制概述" class="headerlink" title="消息转发机制概述"></a>消息转发机制概述</h2><p>上一篇博客《<a href="/understanding-objective-c-runtime-part-2/">消息传递机制</a>》中讲解了Objective-C中对象的消息传递机制。本文需要讲解另外一个重要问题：<strong>当对象收到无法处理的消息会发生什么</strong>？</p>
<p>显然，若想让类能理解某条消息，我们必须以程序代码实现出对应的方法才行。但是，在编译期向类发送了其无法理解解读的消息并不会报错，因为在运行期间允许继续向类中添加方法，所以，编译器在编译期间还无法确知类中到底会不会有某个方法的实现。当对象接收到无法理解的消息后，就会启动<strong>消息转发</strong>（message forwarding）机制，用户（程序员）可经此过程告诉对象应该如何处理未知消息。</p>
<p>向对象发送它无法理解的后果在实际开发中我们会经常遇到，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">NSObject</span> *aObject = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [(<span class="built_in">NSString</span> *)aObject lowercaseString]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，这几行代码可以通过编译，但是在运行时会出现如下错误，并导致崩溃：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-[NSObject lowercaseString]: unrecognized selector sent to instance 0x7a8acba0</div><div class="line">*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[NSObject lowercaseString]: unrecognized selector sent to instance 0x7a8acba0&apos;</div><div class="line">*** First throw call stack:</div><div class="line">(</div><div class="line">    0   CoreFoundation                      0x008f4746 __exceptionPreprocess + 182</div><div class="line">    1   libobjc.A.dylib                     0x0057da97 objc_exception_throw + 44</div><div class="line">    2   CoreFoundation                      0x008fc705 -[NSObject(NSObject) doesNotRecognizeSelector:] + 277</div><div class="line">    3   CoreFoundation                      0x00843287 ___forwarding___ + 1047</div><div class="line">    4   CoreFoundation                      0x00842e4e _CF_forwarding_prep_0 + 14</div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure>
<p>上面这段异常信息是由<code>NSObject</code>的<code>doesNotRecognizeSelector:</code>方法抛出的，此异常表明：消息的接收者的类型是<code>NSObject</code>（即receiver是<code>NSObject</code>类型对象），而该接收者无法理解名为<code>lowercaseString</code>的选择子。</p>
<p>在本例中，消息转发过程以应用程序崩溃告终，不过，开发者在编写自己的类时，可于转发过程中设置挂钩，用于执行预定的逻辑，而不使得应用程序崩溃。</p>
<p>当对象接收到未知的选择子（unknown selector）时，开启消息转发，这分为两大阶段：</p>
<ul>
<li>第一阶段先与接收者所属的类打交道，看其是否能动态添加方法，以处理当前这个未知的选择子，这叫<strong>动态方法解析</strong>（dynamic method resolution）；</li>
<li>第二阶段涉及<strong>完整的消息转发机制</strong>（full forwarding mechanism）。如果runtime系统已经把第一阶段执行完了，那receiver自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。此时，运行期系统会请求receiver用其他手段来处理这条消息相关的方法调用了。这又细分为为两小步：<ul>
<li>请receiver看看有没有其他对象能处理这条消息，若有，则runtime系统会把消息转发给那个对象，消息转发结束；</li>
<li>若有没有<strong>备援的接收者</strong>（replacement receiver），则启动<strong>完整的消息转发机制</strong>，runtime系统会把与消息有关的全部细节封装到NSInvocation对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。</li>
</ul>
</li>
</ul>
<h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2><p>Receiver在收到unknown selector后，首先将调用其本类的<code>resolveInstanceMethod:</code>方法，该方法定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</div></pre></td></tr></table></figure>
<p>该方法的参数就是那个unknown selector，其返回值为<code>Boolean</code>类型，表示这个类是否能新增一个实例方法用以处理该unknown selector。在继续往下执行转发机制之前，本类有机会新增一个处理此selector的方法。所以<code>resolveInstanceMethod:</code>的一般使用套路是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSelector &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="comment">/* aSelector满足某个条件  */</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         调用class_addMethod为该类添加一个处理aSelector的方法，譬如：</div><div class="line">         class_addMethod(self, aSelector, aImp, @"v@:@");</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假如尚未实现的方法不是实例方法而是类方法，那么runtime系统会调用另外一个与<code>resolveInstanceMethod:</code>类似的方法<code>resolveClassMethod:</code>，其原型如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel;</div></pre></td></tr></table></figure>
<p>举个栗子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">getter</span>=name, <span class="keyword">setter</span>=setName:) <span class="built_in">NSString</span> *name;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div><div class="line">    </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@dynamic</span> name;</div><div class="line">    </div><div class="line"><span class="comment">// 注意，这是C语言函数（不是Objective-C方法）</span></div><div class="line"><span class="keyword">id</span> name(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">@"张不坏"</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// 注意，这是C语言函数（不是Objective-C方法）  </span></div><div class="line"><span class="keyword">void</span> setName(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"do nothing"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(name)) &#123;</div><div class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)name, <span class="string">"@@:"</span>);        <span class="comment">// 添加getter</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(setName:)) &#123;</div><div class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)setName, <span class="string">"v@:@:"</span>);   <span class="comment">// 添加setter</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>@@:</code>和<code>v@:@:</code>用来描述函数参数和返回值，更多内容参考《<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">Apple: Type Encodings</a>》和《<a href="http://nshipster.com/type-encodings/" target="_blank" rel="external">NSHipster: Type Encodings</a>》。</p>
<p>执行效果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Student *jason = [[Student alloc] init];</div><div class="line">jason.name = <span class="string">@"Jason"</span>;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"name of this student：%@"</span>, jason.name);</div><div class="line">    </div><div class="line"><span class="comment">/* 输出：</span></div><div class="line">do nothing</div><div class="line">name of this student：张不坏</div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h2><p>当前receiver还有第二次机会能处理unknown selector，在这一步中，runtime系统会问它：可否把这条消息转给其他对象处理？该步骤对应的处理方法是<code>forwardingTargetForSelector:</code>，定义于<code>&lt;objc/NSObject.h&gt;</code>中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector;</div></pre></td></tr></table></figure>
<p>方法参数代表unknown selector，若当前receiver能找到备援对象，则将其返回，若找不到，则返回<code>nil</code>。</p>
<p>通过此方案，我们可以通过组合（composition）来模拟出多继承（multiple inheritance）的某些特性。</p>
<p>所谓<strong>多继承</strong>指一个类可以继承自多个类，即该类对象具有多个类的属性和方法，譬如A继承自B和C，则A的类对象a同时具有了B和C的方法和属性。</p>
<p>而Objective-C是不支持多继承了。因此A只能继承自B，而不能同时也继承C。若想让A也具备C的方法，基于<strong>消息转发机制</strong>的实现过程是这样的：在A中定义一个C对象（假设为c），当向A对象发送C才能处理的消息时，在A的<code>-(id)forwardingTargetForSelector:</code>方法实现中返回c（C对象）即可。如此这般，在外界看来，就感觉A能够处理这些C中定义的方法。</p>
<p>为了更好的阐述「通过转发模拟多继承」，以下图举个例子：</p>
<div class="imagediv" style="width: 321px; height: 206px"></div>

<p>在上图中，Warrior（武士）和Diplomat（外交官）没有继承关系，所以它自然不能处理Diplomat才能做的事情negotiate（谈判）。但是，通过「消息转发」，可以让Warrior也能够接受negotiate消息。具体做法是在Warrior中定义一个Diplomat对象（内部变量，假设名为aDiplomat），当Warrior对象接收到negotiate消息时，就转发给aDiplomat。这让人感觉武士（Warrior）也兼具谈判（negotiate）能力。</p>
<h2 id="完整的消息转发机制"><a href="#完整的消息转发机制" class="headerlink" title="完整的消息转发机制"></a>完整的消息转发机制</h2><p>如果转发已经到了这一步的话，那么唯一能够做的就是启用<strong>完整的消息转发机制</strong>了。首先创建<code>NSInvocation</code>对象，将未知消息相关的全部细节都封装于其中。此对象包含选择子、目标（target）以及参数。在触发<code>NSInvocation</code>对象时，消息派发系统（message-dispatch system）将亲自出马，把消息派给目标对象。</p>
<p>此步骤会调用<code>forwardInvocation:</code>方法来转发消息，该方法定义于<code>&lt;objc/NSObject.h&gt;</code>中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</div></pre></td></tr></table></figure>
<p>这个方法可以实现得很简单：只要改变调用目标，是消息在新目标上得以调用即可。然而这样实现出来的方法与「备援接收者」方案所实现的方法等效，所以很少有人采用这种实现方式。比较有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或是改换选择子，等等。</p>
<p>实现此方法时，若发现某调用方法不应由本类处理，则需调用超类的同名方法。这样的话，集成体系中的每个类都有机会处理此调用请求，直至NSObject。如果最后调用了NSObject类的方法，那么该方法还有继而调用<code>doesNotRecognizeSelector:</code>以抛出异常，此异常表明选择子最终未能得到处理。</p>
<h2 id="消息转发全流程"><a href="#消息转发全流程" class="headerlink" title="消息转发全流程"></a>消息转发全流程</h2><p>下图是消息转发全流程图，描述了<strong>消息转发机制</strong>的各个步骤。</p>
<div class="imagediv" style="width: 464px; height: 220px"></div>

<p>Receiver在每一步中均有机会处理消息。步骤越往后，处理消息的代价就越大；最好能在第一步就处理完，这样的话，runtime系统就可以将此方法缓存起来，进而提高效率。若想在第三步里把消息转发给备援的receiver，那还不如把转发操作提前到第二步。因为第三步只是修改了调用目标，这项改动放在第二步会更为简单，不然的话，还得创建并处理完整的<code>NSInvocation</code>。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Runtime/">Runtime</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-understanding-objective-c-runtime-part-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/27/understanding-objective-c-runtime-part-2/" class="article-date">
  	<time datetime="2015-04-27T03:16:36.000Z" itemprop="datePublished">2015-04-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/27/understanding-objective-c-runtime-part-2/">理解Objective-C Runtime（二）消息传递机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在对象上调用方法是包括Objective-C的众多语言都具备的功能。但在Objective-C中，这个术语叫<strong>传递消息</strong>（pass a message）。消息有可以接受参数，也可能有返回值。</p>
<h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><p>由于Objective-C是C的超集，所以最好先理解C语言的函数调用方式。C语言使用<strong>静态绑定</strong>（static binding），也就是说，在编译期间就能决定运行时所应调用的函数。以下代码为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGoodbye</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTheThing</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</div><div class="line">        printHello();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        printGoodbye();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若不考虑内联（inline），那么编译器在编译代码时就已经知道程序中有printHello与printGoodbye这两个函数了，于是会直接生成调用这些函数的指令（站在汇编的角度，call命令）。而函数地址实际上是与硬编码在指令之中的。</p>
<p>如果将上述代码写成下面这样，会如何呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGoodbye</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTheThing</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> (*fnc)();</div><div class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</div><div class="line">        fnc = printHello;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fuc = printGoodbye;</div><div class="line">    &#125;</div><div class="line">    fnc();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是动态绑定（dynamic binding）！因为所要调用的函数知道运行期才能确定。编译器在这种情况下生成的指令与刚才的那个例子不同，在第一个例子（静态绑定）中，<code>if</code>与<code>else</code>语句里都有函数调用指令（汇编中的call命令）；而在第二个例子（动态绑定）中，只有一个函数调用指令，不过待调用的函数地址无法硬编码之中，而是要在运行期读出来。</p>
<h2 id="消息传递机制"><a href="#消息传递机制" class="headerlink" title="消息传递机制"></a>消息传递机制</h2><p>在OC中，如果向某对象传递消息，那就会使用<strong>动态绑定机制</strong>来决定需要调用的方法。在底层，所有方法都是普通的C语言函数，然而对象收到消息之后，究竟该调用哪个方法则完全在runtime决定，甚至可以在程序运行时改变，这些特性使得<strong>Objective-C成为一门真正的动态语言</strong>。</p>
<p>给对象发生消息可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> returnValue = [someObject messageName:parameter];</div></pre></td></tr></table></figure>
<p><code>someObject</code>是接收者（receiver），<code>messageName</code>叫做选择子（selector）。二者合起来称为消息（message）。</p>
<p>P.S: 「选择子」和「方法」这两个名词经常交替使用，都是一个意思。</p>
<p>编译器看到此消息后，将其转换为一条标准的C语言函数调用，所调用的函数乃是「消息传递机制」中的核心函数，即鼎鼎有名的<code>objc_msgSend</code>，其原型可以在<code>&lt;objc/message.h&gt;</code>中找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">id <span class="title">objc_msgSend</span><span class="params">(id self, SEL op, ...)</span></span></div></pre></td></tr></table></figure>
<p><code>id returnValue = [someObject messageName:parameter];</code>会被编译器翻译成如下形式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> returnValue = objc_msgSend(someObject, <span class="keyword">@selector</span>(messageName:), parameter);</div></pre></td></tr></table></figure>
<p>在runtime，<code>objc_msgSend</code>会依据receiver（即上述对象someObject）和选择子类型来调用适当的方法。为了完成此操作，该方法需要在接收者所属的类中搜寻其「方法列表」（关于方法列表，详见<a href="/understanding-objective-c-runtime-part-1/#objc_class和isa">methodLists</a>），如果能找到与选择子匹配的方法，就调至其实现的代码。若找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果最终还找不到相匹配的方法，那就执行<strong>消息转发</strong>（message forwarding）操作，这会在下一篇<a href="/understanding-objective-c-runtime-part-3/">博客</a>中阐述。</p>
<p>如此看来，Objective-C在runtime调用一个方法似乎需要很多步骤。所幸的是，<code>objc_msgSend</code>会将匹配结果缓存在快速映射表（fast map）里面，每个类都有这样一块缓存，若是稍后还想该类发送与选择子相同的方法，那么查找起来就很快了。</p>
<p>P.S: 上一篇博客《<a href="/understanding-objective-c-runtime-part-1/">理解Objective-C Runtime（一）预备知识</a>》中在介绍<code>objc_class</code>结构体时谈到了其中一个变量<code>cache</code>，但简单忽略飘过；其实，根据我的理解，这里的快速映射表所对应的就是<code>objc_class</code>中的变量<code>cache</code>。</p>
<p>诚然，即便有这种快速映射表机制，执行速度还是不如静态绑定。实际上，对于当前这种硬件平台，这点速度差根本不值一提。</p>
<p>在<code>&lt;objc/message.h&gt;</code>中，除了<code>objc_msgSend</code>函数原型之外，还可以看到其他的<code>objc_msgSendXXOO</code>函数，这些方法的详细作用，《Effective Objective-C 2.0》item 11中有详细说明，本文就不赘述了。</p>
<p>只要理解了Objective-C的对象模型，理解「消息传递机制」还是非常容易的。</p>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li>《Effective Objective-C 2.0》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Runtime/">Runtime</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/11/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/13/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>