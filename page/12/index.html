<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/12/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.25px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 13.75px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 16.25px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.25px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 17.5px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 12.5px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.25px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 13.75px;">Tools</a> <a href="/tags/Transition/" style="font-size: 12.5px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 18.75px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js/" style="font-size: 11.25px;">js</a> <a href="/tags/js基础/" style="font-size: 20px;">js基础</a> <a href="/tags/node-js/" style="font-size: 11.25px;">node.js</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/事件环/" style="font-size: 10px;">事件环</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/宏任务/" style="font-size: 10px;">宏任务</a> <a href="/tags/微任务/" style="font-size: 10px;">微任务</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/流/" style="font-size: 10px;">流</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/面试/" style="font-size: 11.25px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，全栈开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-initialize-and-load-in-objective-c" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/28/initialize-and-load-in-objective-c/" class="article-date">
  	<time datetime="2015-04-28T06:14:13.000Z" itemprop="datePublished">2015-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/28/initialize-and-load-in-objective-c/">Objective-C中的+initialize和+load</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>近几天花了一些时间了解了一下Objective-C runtime相关的东西，其中涉及到了<code>+load</code>方法，譬如method swizzling通常在category的<code>+load</code>方法中完成。之前对initializer和load的使用就比较疑惑，但一直没有详细去对比了解，以此为契机，集各方资源，分析一下吧！</p>
<p>关于了解<code>+initialize</code>和<code>+load</code>，个人感觉参考官方文档《NSObject Class Reference》就够了。</p>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h2><p>关于<code>+initialize</code>方法，《NSObject Class Reference》的介绍如下：</p>
<blockquote>
<p>Initializes the class before it receives its first message.</p>
</blockquote>
<p>可以理解<code>+initialize</code>的作用是为了该Class在使用前创建合适的环境；</p>
<p>关于其使用，《NSObject Class Reference》的说明如下：</p>
<blockquote>
<p>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses. The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize].</p>
</blockquote>
<p>这上面这段话，可以得出如下这么一些意思：</p>
<ul>
<li><code>+initialize</code>方法是在runtime被调用的；</li>
<li>对于某个类，其类<code>+initialize</code>方法都会在该对象接受任何消息之前被调用；</li>
<li>如果父类和子类的<code>+initialize</code>方法都被调用，父类的调用一定在子类之前，这是系统自动完成的，子类<code>+initialize</code>中没必要显式调用<code>[super initialize];</code>；</li>
<li>runtime系统处理<code>+initialize</code>消息的方式是线程安全的，所以没必要在<code>+initialize</code>中为了保证线程安全而使用lock、mutex之类的线程安全工具；</li>
<li>某个类的<code>+initialize</code>的方法不一定只被调用一次，至少有两种情况会被调用多次：<ul>
<li>子类显式调用<code>[super initialize];</code>；</li>
<li>子类没有实现<code>+initialize</code>方法；</li>
</ul>
</li>
</ul>
<p>下面以示例演示某个类的<code>+initialize</code>被多次执行的现象。</p>
<p>定义三个类：<code>Person</code>、<code>Student</code>、<code>Teacher</code>，<code>Student</code>和<code>Teacher</code>继承自<code>Person</code>，<code>Person</code>继承自<code>NSObject</code>。<code>Person</code>和<code>Student</code>都实现了<code>+initialize</code>方法，<code>Teacher</code>没有实现该方法，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person的+initialize方法的实现</span></div><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Person initialize"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// Student的+initialize方法的实现</span></div><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Student initialize"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行效果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    Student *aStudent = [[Student alloc] init];</div><div class="line">    Teacher *aTeacher = [[Teacher alloc] init];</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/* 输出：</span></div><div class="line">Person initialize</div><div class="line">Student initialize</div><div class="line">Person initialize</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>可以看到，对于<code>Student</code>，在其<code>+initialize</code>方法被调用之前，其super class（<code>Person</code>）的<code>+initialize</code>方法被率先调用；对于<code>Teacher</code>，没有定义<code>+initialize</code>方法，所以它会直接调用super class（Person）的<code>+initialize</code>方法，这就导致了Person的<code>+initialize</code>方法被执行两次。</p>
<p>有没有办法避免<code>Person</code>的<code>+initialize</code>方法被多次调用？当然可以：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person的+initialize方法的实现</span></div><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">BOOL</span> b = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (!b) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Person initialize"</span>);</div><div class="line">        b = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person的+initialize方法的实现</span></div><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [Person <span class="keyword">class</span>]) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Person initialize"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>《NSObject Class Reference》中还对<code>+initialize</code>方法的使用做了一些警告：</p>
<blockquote>
<p>Because initialize is called in a thread-safe manner and the order of initialize being called on different classes is not guaranteed, it’s important to do the minimum amount of work necessary in initialize methods. Specifically, any code that takes locks that might be required by other classes in their initialize methods is liable to lead to deadlocks. Therefore you should not rely on initialize for complex initialization, and should instead limit it to straightforward, class local initialization.</p>
</blockquote>
<p>总结一下，就是这样：不要在<code>+initialize</code>中处理复杂的逻辑！</p>
<p>那么<code>+initialize</code>可以做些什么事情呢？可以做一些简单的初始化工作，譬如对于某个继承自<code>UICollectionViewCell</code>的自定义类<code>PhotoViewCell</code>，<code>PhotoViewCell</code>的对象可能会有一些公用资源，譬如label color，label font等等，没必要在<code>-initXXOO</code>方法中创建这些完全一样的资源，此时就可以放在<code>PhotoViewCell</code>中的<code>+initialize</code>中完成，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    titleFont       = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12</span>];</div><div class="line">    titleHeight     = <span class="number">20.0</span>f;</div><div class="line">    videoIcon       = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CTAssetsPickerVideo"</span>];</div><div class="line">    titleColor      = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">    checkedIcon     = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CTAssetsPickerChecked"</span>];</div><div class="line">    selectedColor   = [<span class="built_in">UIColor</span> colorWithWhite:<span class="number">1</span> alpha:<span class="number">0.3</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>+initialize</code>终究还是带来惊人的信息量，颇为失望。</p>
<h2 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h2><p>关于<code>+load</code>方法，《NSObject Class Reference》的介绍如下：</p>
<blockquote>
<p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>
</blockquote>
<p>关于其使用，《NSObject Class Reference》的说明如下：</p>
<blockquote>
<p>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p>
<p>The order of initialization is as follows:</p>
<blockquote>
<ol>
<li>All initializers in any framework you link to.</li>
<li>All +load methods in your image.</li>
<li>All C++ static initializers and C/C++ <strong>attribute</strong>(constructor) functions in your image.</li>
<li>All initializers in frameworks that link to you.</li>
</ol>
</blockquote>
<p>In addition:</p>
<ul>
<li>A class’s +load method is called after all of its superclasses’ +load methods.</li>
<li>A category +load method is called after the class’s own +load method.<br>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</li>
</ul>
</blockquote>
<p>从这段文字可以读出如下信息：</p>
<ul>
<li>在一个程序（main函数）运行之前，所用到的库被加载到runtime之后，被添加到的runtime系统的各种类和category的<code>+load</code>方法就被调用；（关于这点很容易通过打印语句来验证）；</li>
<li>如果父类和子类的<code>+load</code>方法都被调用，父类的调用一定在子类之前，这是系统自动完成的，子类<code>+load</code>中没必要显式调用<code>[super load];</code>；</li>
<li>文档没有讲明<code>+load</code>的执行是否是线程安全的，但考虑到它是在runtime之前就调用，所以谈论它是否是线程安全没啥必要，根据我的理解，多线程在runtime才有谈论意义；</li>
<li>若某个类由一个主类和多个category组成，则允许主类和category中各自有自己的<code>+load</code>方法，只是category中的<code>+load</code>的执行在主类的<code>+load</code>之后；</li>
</ul>
<p>关于<code>+load</code>的使用场景，笔者知道的至少有一个，method swizzling的处理一般都在category的<code>+load</code>中完成的，参考<a href="/unstanding-objective-c-runtime-part-4/">这里</a>。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《NSObject Class Reference》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-understanding-objective-c-runtime-part-4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/27/understanding-objective-c-runtime-part-4/" class="article-date">
  	<time datetime="2015-04-27T13:10:53.000Z" itemprop="datePublished">2015-04-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/27/understanding-objective-c-runtime-part-4/">理解Objective-C Runtime（四）Method Swizzling</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Objective-C对象收到消息之后，究竟会调用何种方法需要在运行期间才能解析出来。那你也许会问：与给定的选择子名称相应的方法是不是也可以在runtime改变呢？没错，就是这样。<strong>若能善用此特性，则可发挥出巨大优势，因为我们既不需要源代码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能</strong>。这样一来，新功能将在本类的所有实例中生效，而不仅限于覆写了相关方法的那些子类实例。此方案就是大名鼎鼎的<strong>method swizzling</strong>，中文常称之为「方法调配」或「方法调和」或「方法混合」。</p>
<h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h2><p><strong>类的方法列表会把选择子的名称映射到相关的方法实现之上</strong>，使得<strong>动态消息派发系统</strong>（dynamic message-dispatch system）能够据此找到应该调和的方法。这些方法均以函数指针的形式来表示，这种指针叫IMP（IMP在《<a href="/understanding-objective-c-runtime-part-1/">理解Objective-C Runtime（一）预备知识</a>》已有说明）。</p>
<p>举个栗子，<code>NSString</code>类可以响应<code>lowercaseString</code>、<code>uppercaseString</code>、<code>capitalizedString</code>等选择子。这张映射表（selector table，也常称为<strong>选择器表</strong>）中的每个选择子都映射到不同的IMP之上，如下图所示：</p>
<div class="imagediv" style="width: 500px; height: 200px"></div>

<p>Objective-C runtime系统提供的几个方法都能够用来操作这张表。开发者可以向其中新增selector，也可以改变某个selector所对应的方法实现，还可以交换两个selector所映射到的指针。经过几次操作之后，类的方法就会变成如下图所示：</p>
<div class="imagediv" style="width: 500px; height: 250px"></div>

<p>在新的映射表中，多了一个名为newSelector的选择子，lowercaseString和uppercaseString的实现则互换了。上述修改均无需编写子类，只要修改<strong>方法表</strong>的布局即可，就会反映到程序中所有的NSString实例之上。</p>
<h2 id="交换两个方法的实现"><a href="#交换两个方法的实现" class="headerlink" title="交换两个方法的实现"></a>交换两个方法的实现</h2><p>现在通过示例代码演绎「调换<code>NSString</code>的<code>lowercaseString</code>和<code>uppercaseString</code>的方法实现」，具体实现操作是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *aString = <span class="string">@"AbcDEfg"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// lowercaseString和uppercaseString交换前：</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"lowercaseString和uppercaseString交换前："</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"lowercase of the string : %@"</span>, [aString lowercaseString]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"uppercase of the string : %@"</span>, [aString uppercaseString]);</div><div class="line">    </div><div class="line">    <span class="comment">// class_getInstanceMethod方法得到Method类型</span></div><div class="line">    Method originalMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(lowercaseString));</div><div class="line">    Method swappedMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(uppercaseString));</div><div class="line">    </div><div class="line">    <span class="comment">// method_exchangeImplementations交换映射指针</span></div><div class="line">    method_exchangeImplementations(originalMethod, swappedMethod);</div><div class="line">    </div><div class="line">    <span class="comment">// lowercaseString和uppercaseString交换后：</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"lowercaseString和uppercaseString交换后："</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"lowercase of the string : %@"</span>, [aString lowercaseString]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"uppercase of the string : %@"</span>, [aString uppercaseString]);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/* 输出结果：</span></div><div class="line">lowercaseString和uppercaseString交换前：</div><div class="line">lowercase of the string : abcdefg</div><div class="line">uppercase of the string : ABCDEFG</div><div class="line">lowercaseString和uppercaseString交换后：</div><div class="line">lowercase of the string : ABCDEFG</div><div class="line">uppercase of the string : abcdefg</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>这演示了如何交换两个方法的实现，然而在实际应用中，像这样直接交换两个方法实现，其意义不大，除非闲得蛋疼。但是，可以通过这一手段来为既有的方法实现增添新功能。</p>
<h2 id="修改既有方法的行为"><a href="#修改既有方法的行为" class="headerlink" title="修改既有方法的行为"></a>修改既有方法的行为</h2><p>介绍一个技巧，最好的方式就是提出具体的需求，然后用它跟其他的解决方法做比较。</p>
<p>所以，先来看看我们的需求：对 App 的用户行为进行追踪和分析。简单说，就是当用户看到某个View或者点击某个Button的时候，就把这个事件记下来。</p>
<p><strong>手动添加</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyViewController</span> ()</span></div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</div><div class="line">    </div><div class="line">    <span class="comment">// Custom code </span></div><div class="line">    </div><div class="line">    <span class="comment">// Logging</span></div><div class="line">    [Logging logWithEventName:<span class="string">@"my view did appear"</span>];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)myButtonClicked:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Custom code </span></div><div class="line">    </div><div class="line">    <span class="comment">// Logging</span></div><div class="line">    [Logging logWithEventName:<span class="string">@"my button clicked"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式的缺点也很明显：它破坏了代码的干净整洁。因为Logging的代码本身并不属于View Controller里的主要逻辑。随着项目扩大、代码量增加，你的View Controller里会到处散布着Logging的代码。这时，要找到一段事件记录的代码会变得困难，也很容易忘记添加事件记录的代码。</p>
<p>你可能会想到用继承或类别，在重写的方法里添加事件记录的代码。代码可以是长的这个样子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)myViewDidAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</div><div class="line">    </div><div class="line">    <span class="comment">// Custom code </span></div><div class="line">    </div><div class="line">    <span class="comment">// Logging</span></div><div class="line">    [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)myButtonClicked:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Custom code </span></div><div class="line">    </div><div class="line">    <span class="comment">// Logging</span></div><div class="line">    <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithFormat:@“my button <span class="keyword">in</span> %@ is clicked”, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</div><div class="line">    [Logging logWithEventName:name];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Logging 的代码都很相似，通过继承或类别重写相关方法是可以把它从主要逻辑中剥离出来。但同时也带来新的问题：</p>
<ol>
<li>你需要继承<code>UIViewController</code>，<code>UITableViewController</code>，<code>UICollectionViewController</code>所有这些View Controller，或者给他们添加类别；</li>
<li>每个View Controller里的ButtonClick方法命名不可能都一样；</li>
<li>你不能控制别人如何去实例化你的子类；</li>
<li>对于类别，你没办法调用到原来的方法实现，大多时候，我们重写一个方法只是为了添加一些代码，而不是完全取代它；</li>
<li>如果有两个类别都实现了相同的方法，运行时没法保证哪一个类别的方法会给调用。</li>
</ol>
<p><strong>Method Swizzling的做法</strong></p>
<p>Method Swizzling的做法是新增一个方法<code>log_viewDidAppear:</code>，在这个方法体中调用<code>viewDidAppear:</code>的方法体；然后将<code>log_viewDidAppear:</code>和<code>viewDidAppear:</code>进行调换。呃，有些绕，看图吧：</p>
<div class="imagediv" style="width: 505px; height: 154px"></div>

<p>新增方法<code>log_viewDidAppear:</code>的实现代码可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)log_viewDidAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> log_viewDidAppear:animated];</div><div class="line">        </div><div class="line">    <span class="comment">// Logging</span></div><div class="line">    [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看起来，这段代码好像会陷入递归使用的死循环，不过要记住，此方法是准备和<code>viewDidAppear:</code>方法互换的。所以，在runtime，<code>log_viewDidAppear:</code>选择子对应的是原来<code>viewDidAppear:</code>方法的实现；同样，当向对象发送<code>viewDidAppear:</code>消息时，如上这段代码会被调用，而这段代码的第一句是<code>[self log_viewDidAppear:animated];</code>，这其实是调用原来<code>viewDidAppear:</code>方法的实现代码…</p>
<p>定义了<code>log_viewDidAppear:</code>的实现后，还得与<code>viewDidAppear:</code>进行交换：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// class_getInstanceMethod方法得到Method类型</span></div><div class="line">Method originalMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidAppear:));</div><div class="line">Method swappedMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(log_viewDidAppear:));</div><div class="line">    </div><div class="line"><span class="comment">// method_exchangeImplementations交换映射指针</span></div><div class="line">method_exchangeImplementations(originalMethod, swappedMethod);</div></pre></td></tr></table></figure>
<p>如何安排method swizzling相关的代码？</p>
<p>一般来说，runtime相关的代码都会以category的形式组织，所以上述<code>log_viewDidAppear:</code>方法的实现会写在一个UIViewController category中，比如<code>UIViewController+log.h</code>。而<strong>交换方法</strong>相关的代码会写在category的load中。因为load方法是在runtime之前就被执行的，只要category所在的头文件被引用，load方法就会被调用，并且同一个class在不同category之间允许有多个load方法，这些load方法都会被调用（唯一的问题是谁先谁后）。</p>
<p>通过method swizzling方案，开发者可以为那些完全不知道具体实现的（completely opaque，完全不透明）黑盒方法增加日志记录功能，这非常有助于程序调试，然而，此做法只在调试程序时有用。很少有人在调试程序之外的场合用上述<strong>方法调配技术</strong>来永久改变某个类的功能，因为如果使用不慎，它造成的破坏太大了，并且很难Debug。不能仅仅因为Objective-C语言里有这个特性就一定要用它。若是滥用，反而会令代码变得不易读懂且难于维护。</p>
<p>总之，Method Swizzling只一个挺有争议的技术，对此有很多分析的文章，底部的参考资料中有链接。</p>
<p><strong>补充</strong></p>
<p>后来终于有机会在实际项目中使用到method swizzling。应用场景是这样的，接手了一个完整的项目，我的任务是在该项目基础上添加一些功能，顺便将项目整理一下，尽可能清理没有用的内容和过时的技术。项目页面非常多，各种文件的命名非常糟糕，我首先需要做的事情是将页面逻辑给整理出来（各种View Controller之间的逻辑关系），简单来说，我需要结合所看到的运行页面（譬如首页），将它的View Controller类给找出来。</p>
<p>比较蠢的做法当然是去查看代码了。好在我比较机灵，决定使用method swizzling技术，让每个页面将它的View Controller类名自己喊出来。</p>
<p>我的思路：定义一个UIViewController category，添加一个方法，该方法调用<code>viewDidAppear:</code>，并且将该类的名字给打印出来，然后将该方法的SEL和<code>viewDidAppear:</code>方法的SEL调换，这样系统在回调<code>viewDidAppear:</code>时会定义该方法代码，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">sayHello</span>)</span></div><div class="line"> </div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">    SEL originalSelector = <span class="keyword">@selector</span>(viewDidAppear:);</div><div class="line">    SEL swizzledSelector = <span class="keyword">@selector</span>(swizzled_viewDidAppear:);</div><div class="line">    </div><div class="line">    <span class="comment">// class_getInstanceMethod方法得到Method类型</span></div><div class="line">    Method originalMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], originalSelector);</div><div class="line">    Method swizzledMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], swizzledSelector);</div><div class="line"> </div><div class="line">    <span class="comment">// method_exchangeImplementations交换映射指针</span></div><div class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)swizzled_viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">self</span> swizzled_viewDidAppear:animated];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hello, my name is %@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="AOP-Aspect-Oriented-Programming"><a href="#AOP-Aspect-Oriented-Programming" class="headerlink" title="AOP(Aspect Oriented Programming)"></a>AOP(Aspect Oriented Programming)</h2><p>在阅读博客《<a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">Method Swizzling和AOP实践</a>》时了解到了一个新概念 – <code>AOP</code>。</p>
<p>简单来说，在Objective-C世界中，AOP就是利用Runtime特性给指定的方法添加自定义代码，Method Swizzling是其中一种实现AOP的方式之一。</p>
<p>Mark一下，暂不多讲。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《Effective Objective-C 2.0》</li>
<li>《iOS开发进阶》</li>
<li>《<a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">Method Swizzling和AOP实践</a>》</li>
<li>大神Mattt Thompson（AFNetworking作者）的《<a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">Method Swizzling</a>》</li>
<li>《<a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="external">Objective-C的hook方案（一）: Method Swizzling</a>》</li>
<li><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="external">What are the Dangers of Method Swizzling in Objective C?</a>；</li>
<li>《<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/#Method_Swizzling" target="_blank" rel="external">Objective-C Runtime</a>》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Runtime/">Runtime</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-understanding-objective-c-runtime-part-3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/27/understanding-objective-c-runtime-part-3/" class="article-date">
  	<time datetime="2015-04-27T07:41:47.000Z" itemprop="datePublished">2015-04-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/27/understanding-objective-c-runtime-part-3/">理解Objective-C Runtime（三）消息转发机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="消息转发机制概述"><a href="#消息转发机制概述" class="headerlink" title="消息转发机制概述"></a>消息转发机制概述</h2><p>上一篇博客《<a href="/understanding-objective-c-runtime-part-2/">消息传递机制</a>》中讲解了Objective-C中对象的消息传递机制。本文需要讲解另外一个重要问题：<strong>当对象收到无法处理的消息会发生什么</strong>？</p>
<p>显然，若想让类能理解某条消息，我们必须以程序代码实现出对应的方法才行。但是，在编译期向类发送了其无法理解解读的消息并不会报错，因为在运行期间允许继续向类中添加方法，所以，编译器在编译期间还无法确知类中到底会不会有某个方法的实现。当对象接收到无法理解的消息后，就会启动<strong>消息转发</strong>（message forwarding）机制，用户（程序员）可经此过程告诉对象应该如何处理未知消息。</p>
<p>向对象发送它无法理解的后果在实际开发中我们会经常遇到，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">NSObject</span> *aObject = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [(<span class="built_in">NSString</span> *)aObject lowercaseString]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，这几行代码可以通过编译，但是在运行时会出现如下错误，并导致崩溃：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-[NSObject lowercaseString]: unrecognized selector sent to instance 0x7a8acba0</div><div class="line">*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[NSObject lowercaseString]: unrecognized selector sent to instance 0x7a8acba0&apos;</div><div class="line">*** First throw call stack:</div><div class="line">(</div><div class="line">    0   CoreFoundation                      0x008f4746 __exceptionPreprocess + 182</div><div class="line">    1   libobjc.A.dylib                     0x0057da97 objc_exception_throw + 44</div><div class="line">    2   CoreFoundation                      0x008fc705 -[NSObject(NSObject) doesNotRecognizeSelector:] + 277</div><div class="line">    3   CoreFoundation                      0x00843287 ___forwarding___ + 1047</div><div class="line">    4   CoreFoundation                      0x00842e4e _CF_forwarding_prep_0 + 14</div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure>
<p>上面这段异常信息是由<code>NSObject</code>的<code>doesNotRecognizeSelector:</code>方法抛出的，此异常表明：消息的接收者的类型是<code>NSObject</code>（即receiver是<code>NSObject</code>类型对象），而该接收者无法理解名为<code>lowercaseString</code>的选择子。</p>
<p>在本例中，消息转发过程以应用程序崩溃告终，不过，开发者在编写自己的类时，可于转发过程中设置挂钩，用于执行预定的逻辑，而不使得应用程序崩溃。</p>
<p>当对象接收到未知的选择子（unknown selector）时，开启消息转发，这分为两大阶段：</p>
<ul>
<li>第一阶段先与接收者所属的类打交道，看其是否能动态添加方法，以处理当前这个未知的选择子，这叫<strong>动态方法解析</strong>（dynamic method resolution）；</li>
<li>第二阶段涉及<strong>完整的消息转发机制</strong>（full forwarding mechanism）。如果runtime系统已经把第一阶段执行完了，那receiver自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。此时，运行期系统会请求receiver用其他手段来处理这条消息相关的方法调用了。这又细分为为两小步：<ul>
<li>请receiver看看有没有其他对象能处理这条消息，若有，则runtime系统会把消息转发给那个对象，消息转发结束；</li>
<li>若有没有<strong>备援的接收者</strong>（replacement receiver），则启动<strong>完整的消息转发机制</strong>，runtime系统会把与消息有关的全部细节封装到NSInvocation对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。</li>
</ul>
</li>
</ul>
<h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2><p>Receiver在收到unknown selector后，首先将调用其本类的<code>resolveInstanceMethod:</code>方法，该方法定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</div></pre></td></tr></table></figure>
<p>该方法的参数就是那个unknown selector，其返回值为<code>Boolean</code>类型，表示这个类是否能新增一个实例方法用以处理该unknown selector。在继续往下执行转发机制之前，本类有机会新增一个处理此selector的方法。所以<code>resolveInstanceMethod:</code>的一般使用套路是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSelector &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="comment">/* aSelector满足某个条件  */</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         调用class_addMethod为该类添加一个处理aSelector的方法，譬如：</div><div class="line">         class_addMethod(self, aSelector, aImp, @"v@:@");</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假如尚未实现的方法不是实例方法而是类方法，那么runtime系统会调用另外一个与<code>resolveInstanceMethod:</code>类似的方法<code>resolveClassMethod:</code>，其原型如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel;</div></pre></td></tr></table></figure>
<p>举个栗子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">getter</span>=name, <span class="keyword">setter</span>=setName:) <span class="built_in">NSString</span> *name;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div><div class="line">    </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@dynamic</span> name;</div><div class="line">    </div><div class="line"><span class="comment">// 注意，这是C语言函数（不是Objective-C方法）</span></div><div class="line"><span class="keyword">id</span> name(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">@"张不坏"</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// 注意，这是C语言函数（不是Objective-C方法）  </span></div><div class="line"><span class="keyword">void</span> setName(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"do nothing"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(name)) &#123;</div><div class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)name, <span class="string">"@@:"</span>);        <span class="comment">// 添加getter</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(setName:)) &#123;</div><div class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)setName, <span class="string">"v@:@:"</span>);   <span class="comment">// 添加setter</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>@@:</code>和<code>v@:@:</code>用来描述函数参数和返回值，更多内容参考《<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">Apple: Type Encodings</a>》和《<a href="http://nshipster.com/type-encodings/" target="_blank" rel="external">NSHipster: Type Encodings</a>》。</p>
<p>执行效果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Student *jason = [[Student alloc] init];</div><div class="line">jason.name = <span class="string">@"Jason"</span>;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"name of this student：%@"</span>, jason.name);</div><div class="line">    </div><div class="line"><span class="comment">/* 输出：</span></div><div class="line">do nothing</div><div class="line">name of this student：张不坏</div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h2><p>当前receiver还有第二次机会能处理unknown selector，在这一步中，runtime系统会问它：可否把这条消息转给其他对象处理？该步骤对应的处理方法是<code>forwardingTargetForSelector:</code>，定义于<code>&lt;objc/NSObject.h&gt;</code>中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector;</div></pre></td></tr></table></figure>
<p>方法参数代表unknown selector，若当前receiver能找到备援对象，则将其返回，若找不到，则返回<code>nil</code>。</p>
<p>通过此方案，我们可以通过组合（composition）来模拟出多继承（multiple inheritance）的某些特性。</p>
<p>所谓<strong>多继承</strong>指一个类可以继承自多个类，即该类对象具有多个类的属性和方法，譬如A继承自B和C，则A的类对象a同时具有了B和C的方法和属性。</p>
<p>而Objective-C是不支持多继承了。因此A只能继承自B，而不能同时也继承C。若想让A也具备C的方法，基于<strong>消息转发机制</strong>的实现过程是这样的：在A中定义一个C对象（假设为c），当向A对象发送C才能处理的消息时，在A的<code>-(id)forwardingTargetForSelector:</code>方法实现中返回c（C对象）即可。如此这般，在外界看来，就感觉A能够处理这些C中定义的方法。</p>
<p>为了更好的阐述「通过转发模拟多继承」，以下图举个例子：</p>
<div class="imagediv" style="width: 321px; height: 206px"></div>

<p>在上图中，Warrior（武士）和Diplomat（外交官）没有继承关系，所以它自然不能处理Diplomat才能做的事情negotiate（谈判）。但是，通过「消息转发」，可以让Warrior也能够接受negotiate消息。具体做法是在Warrior中定义一个Diplomat对象（内部变量，假设名为aDiplomat），当Warrior对象接收到negotiate消息时，就转发给aDiplomat。这让人感觉武士（Warrior）也兼具谈判（negotiate）能力。</p>
<h2 id="完整的消息转发机制"><a href="#完整的消息转发机制" class="headerlink" title="完整的消息转发机制"></a>完整的消息转发机制</h2><p>如果转发已经到了这一步的话，那么唯一能够做的就是启用<strong>完整的消息转发机制</strong>了。首先创建<code>NSInvocation</code>对象，将未知消息相关的全部细节都封装于其中。此对象包含选择子、目标（target）以及参数。在触发<code>NSInvocation</code>对象时，消息派发系统（message-dispatch system）将亲自出马，把消息派给目标对象。</p>
<p>此步骤会调用<code>forwardInvocation:</code>方法来转发消息，该方法定义于<code>&lt;objc/NSObject.h&gt;</code>中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</div></pre></td></tr></table></figure>
<p>这个方法可以实现得很简单：只要改变调用目标，是消息在新目标上得以调用即可。然而这样实现出来的方法与「备援接收者」方案所实现的方法等效，所以很少有人采用这种实现方式。比较有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或是改换选择子，等等。</p>
<p>实现此方法时，若发现某调用方法不应由本类处理，则需调用超类的同名方法。这样的话，集成体系中的每个类都有机会处理此调用请求，直至NSObject。如果最后调用了NSObject类的方法，那么该方法还有继而调用<code>doesNotRecognizeSelector:</code>以抛出异常，此异常表明选择子最终未能得到处理。</p>
<h2 id="消息转发全流程"><a href="#消息转发全流程" class="headerlink" title="消息转发全流程"></a>消息转发全流程</h2><p>下图是消息转发全流程图，描述了<strong>消息转发机制</strong>的各个步骤。</p>
<div class="imagediv" style="width: 464px; height: 220px"></div>

<p>Receiver在每一步中均有机会处理消息。步骤越往后，处理消息的代价就越大；最好能在第一步就处理完，这样的话，runtime系统就可以将此方法缓存起来，进而提高效率。若想在第三步里把消息转发给备援的receiver，那还不如把转发操作提前到第二步。因为第三步只是修改了调用目标，这项改动放在第二步会更为简单，不然的话，还得创建并处理完整的<code>NSInvocation</code>。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Runtime/">Runtime</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-unstanding-objective-c-runtime-part-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/27/unstanding-objective-c-runtime-part-2/" class="article-date">
  	<time datetime="2015-04-27T03:16:36.000Z" itemprop="datePublished">2015-04-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/27/unstanding-objective-c-runtime-part-2/">理解Objective-C Runtime（二）消息传递机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在对象上调用方法是包括Objective-C的众多语言都具备的功能。但在Objective-C中，这个术语叫<strong>传递消息</strong>（pass a message）。消息有可以接受参数，也可能有返回值。</p>
<h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><p>由于Objective-C是C的超集，所以最好先理解C语言的函数调用方式。C语言使用<strong>静态绑定</strong>（static binding），也就是说，在编译期间就能决定运行时所应调用的函数。以下代码为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGoodbye</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTheThing</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</div><div class="line">        printHello();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        printGoodbye();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若不考虑内联（inline），那么编译器在编译代码时就已经知道程序中有printHello与printGoodbye这两个函数了，于是会直接生成调用这些函数的指令（站在汇编的角度，call命令）。而函数地址实际上是与硬编码在指令之中的。</p>
<p>如果将上述代码写成下面这样，会如何呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGoodbye</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTheThing</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> (*fnc)();</div><div class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</div><div class="line">        fnc = printHello;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fuc = printGoodbye;</div><div class="line">    &#125;</div><div class="line">    fnc();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是动态绑定（dynamic binding）！因为所要调用的函数知道运行期才能确定。编译器在这种情况下生成的指令与刚才的那个例子不同，在第一个例子（静态绑定）中，<code>if</code>与<code>else</code>语句里都有函数调用指令（汇编中的call命令）；而在第二个例子（动态绑定）中，只有一个函数调用指令，不过待调用的函数地址无法硬编码之中，而是要在运行期读出来。</p>
<h2 id="消息传递机制"><a href="#消息传递机制" class="headerlink" title="消息传递机制"></a>消息传递机制</h2><p>在OC中，如果向某对象传递消息，那就会使用<strong>动态绑定机制</strong>来决定需要调用的方法。在底层，所有方法都是普通的C语言函数，然而对象收到消息之后，究竟该调用哪个方法则完全在runtime决定，甚至可以在程序运行时改变，这些特性使得<strong>Objective-C成为一门真正的动态语言</strong>。</p>
<p>给对象发生消息可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> returnValue = [someObject messageName:parameter];</div></pre></td></tr></table></figure>
<p><code>someObject</code>是接收者（receiver），<code>messageName</code>叫做选择子（selector）。二者合起来称为消息（message）。</p>
<p>P.S: 「选择子」和「方法」这两个名词经常交替使用，都是一个意思。</p>
<p>编译器看到此消息后，将其转换为一条标准的C语言函数调用，所调用的函数乃是「消息传递机制」中的核心函数，即鼎鼎有名的<code>objc_msgSend</code>，其原型可以在<code>&lt;objc/message.h&gt;</code>中找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">id <span class="title">objc_msgSend</span><span class="params">(id self, SEL op, ...)</span></span></div></pre></td></tr></table></figure>
<p><code>id returnValue = [someObject messageName:parameter];</code>会被编译器翻译成如下形式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> returnValue = objc_msgSend(someObject, <span class="keyword">@selector</span>(messageName:), parameter);</div></pre></td></tr></table></figure>
<p>在runtime，<code>objc_msgSend</code>会依据receiver（即上述对象someObject）和选择子类型来调用适当的方法。为了完成此操作，该方法需要在接收者所属的类中搜寻其「方法列表」（关于方法列表，详见<a href="/unstanding-objective-c-runtime-part-1/#objc_class和isa">methodLists</a>），如果能找到与选择子匹配的方法，就调至其实现的代码。若找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果最终还找不到相匹配的方法，那就执行<strong>消息转发</strong>（message forwarding）操作，这会在下一篇<a href="/unstanding-objective-c-runtime-part-3/">博客</a>中阐述。</p>
<p>如此看来，Objective-C在runtime调用一个方法似乎需要很多步骤。所幸的是，<code>objc_msgSend</code>会将匹配结果缓存在快速映射表（fast map）里面，每个类都有这样一块缓存，若是稍后还想该类发送与选择子相同的方法，那么查找起来就很快了。</p>
<p>P.S: 上一篇博客《<a href="/unstanding-objective-c-runtime-part-1/">理解Objective-C Runtime（一）预备知识</a>》中在介绍<code>objc_class</code>结构体时谈到了其中一个变量<code>cache</code>，但简单忽略飘过；其实，根据我的理解，这里的快速映射表所对应的就是<code>objc_class</code>中的变量<code>cache</code>。</p>
<p>诚然，即便有这种快速映射表机制，执行速度还是不如静态绑定。实际上，对于当前这种硬件平台，这点速度差根本不值一提。</p>
<p>在<code>&lt;objc/message.h&gt;</code>中，除了<code>objc_msgSend</code>函数原型之外，还可以看到其他的<code>objc_msgSendXXOO</code>函数，这些方法的详细作用，《Effective Objective-C 2.0》item 11中有详细说明，本文就不赘述了。</p>
<p>只要理解了Objective-C的对象模型，理解「消息传递机制」还是非常容易的。</p>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li>《Effective Objective-C 2.0》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Runtime/">Runtime</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-understanding-objective-c-runtime-part-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/27/understanding-objective-c-runtime-part-2/" class="article-date">
  	<time datetime="2015-04-27T03:16:36.000Z" itemprop="datePublished">2015-04-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/27/understanding-objective-c-runtime-part-2/">理解Objective-C Runtime（二）消息传递机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在对象上调用方法是包括Objective-C的众多语言都具备的功能。但在Objective-C中，这个术语叫<strong>传递消息</strong>（pass a message）。消息有可以接受参数，也可能有返回值。</p>
<h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><p>由于Objective-C是C的超集，所以最好先理解C语言的函数调用方式。C语言使用<strong>静态绑定</strong>（static binding），也就是说，在编译期间就能决定运行时所应调用的函数。以下代码为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGoodbye</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTheThing</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</div><div class="line">        printHello();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        printGoodbye();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若不考虑内联（inline），那么编译器在编译代码时就已经知道程序中有printHello与printGoodbye这两个函数了，于是会直接生成调用这些函数的指令（站在汇编的角度，call命令）。而函数地址实际上是与硬编码在指令之中的。</p>
<p>如果将上述代码写成下面这样，会如何呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGoodbye</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTheThing</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> (*fnc)();</div><div class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</div><div class="line">        fnc = printHello;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fuc = printGoodbye;</div><div class="line">    &#125;</div><div class="line">    fnc();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是动态绑定（dynamic binding）！因为所要调用的函数知道运行期才能确定。编译器在这种情况下生成的指令与刚才的那个例子不同，在第一个例子（静态绑定）中，<code>if</code>与<code>else</code>语句里都有函数调用指令（汇编中的call命令）；而在第二个例子（动态绑定）中，只有一个函数调用指令，不过待调用的函数地址无法硬编码之中，而是要在运行期读出来。</p>
<h2 id="消息传递机制"><a href="#消息传递机制" class="headerlink" title="消息传递机制"></a>消息传递机制</h2><p>在OC中，如果向某对象传递消息，那就会使用<strong>动态绑定机制</strong>来决定需要调用的方法。在底层，所有方法都是普通的C语言函数，然而对象收到消息之后，究竟该调用哪个方法则完全在runtime决定，甚至可以在程序运行时改变，这些特性使得<strong>Objective-C成为一门真正的动态语言</strong>。</p>
<p>给对象发生消息可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> returnValue = [someObject messageName:parameter];</div></pre></td></tr></table></figure>
<p><code>someObject</code>是接收者（receiver），<code>messageName</code>叫做选择子（selector）。二者合起来称为消息（message）。</p>
<p>P.S: 「选择子」和「方法」这两个名词经常交替使用，都是一个意思。</p>
<p>编译器看到此消息后，将其转换为一条标准的C语言函数调用，所调用的函数乃是「消息传递机制」中的核心函数，即鼎鼎有名的<code>objc_msgSend</code>，其原型可以在<code>&lt;objc/message.h&gt;</code>中找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">id <span class="title">objc_msgSend</span><span class="params">(id self, SEL op, ...)</span></span></div></pre></td></tr></table></figure>
<p><code>id returnValue = [someObject messageName:parameter];</code>会被编译器翻译成如下形式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> returnValue = objc_msgSend(someObject, <span class="keyword">@selector</span>(messageName:), parameter);</div></pre></td></tr></table></figure>
<p>在runtime，<code>objc_msgSend</code>会依据receiver（即上述对象someObject）和选择子类型来调用适当的方法。为了完成此操作，该方法需要在接收者所属的类中搜寻其「方法列表」（关于方法列表，详见<a href="/understanding-objective-c-runtime-part-1/#objc_class和isa">methodLists</a>），如果能找到与选择子匹配的方法，就调至其实现的代码。若找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果最终还找不到相匹配的方法，那就执行<strong>消息转发</strong>（message forwarding）操作，这会在下一篇<a href="/understanding-objective-c-runtime-part-3/">博客</a>中阐述。</p>
<p>如此看来，Objective-C在runtime调用一个方法似乎需要很多步骤。所幸的是，<code>objc_msgSend</code>会将匹配结果缓存在快速映射表（fast map）里面，每个类都有这样一块缓存，若是稍后还想该类发送与选择子相同的方法，那么查找起来就很快了。</p>
<p>P.S: 上一篇博客《<a href="/understanding-objective-c-runtime-part-1/">理解Objective-C Runtime（一）预备知识</a>》中在介绍<code>objc_class</code>结构体时谈到了其中一个变量<code>cache</code>，但简单忽略飘过；其实，根据我的理解，这里的快速映射表所对应的就是<code>objc_class</code>中的变量<code>cache</code>。</p>
<p>诚然，即便有这种快速映射表机制，执行速度还是不如静态绑定。实际上，对于当前这种硬件平台，这点速度差根本不值一提。</p>
<p>在<code>&lt;objc/message.h&gt;</code>中，除了<code>objc_msgSend</code>函数原型之外，还可以看到其他的<code>objc_msgSendXXOO</code>函数，这些方法的详细作用，《Effective Objective-C 2.0》item 11中有详细说明，本文就不赘述了。</p>
<p>只要理解了Objective-C的对象模型，理解「消息传递机制」还是非常容易的。</p>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li>《Effective Objective-C 2.0》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Runtime/">Runtime</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/11/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/13/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>