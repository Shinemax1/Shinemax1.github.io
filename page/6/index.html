<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/6/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.67px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 15px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 18.33px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.67px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 20px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 13.33px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 16.67px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.67px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/Transition/" style="font-size: 13.33px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js基础/" style="font-size: 16.67px;">js基础</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，Android开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-git-branching-and-remoting" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/06/git-branching-and-remoting/" class="article-date">
  	<time datetime="2015-12-06T05:23:23.000Z" itemprop="datePublished">2015-12-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/06/git-branching-and-remoting/">Git分支与远程操作</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前在《<a href="/git-basics/">Git基础</a>》中介绍了一些Git的重要概念和基本操作，本文在此基础上补充Git分支与远程操作相关的内容。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是Git中的重要概念，其意义和重要性都被讲烂了，这里就不再过多阐述了。简单来说，每次commit都会产生一个快照，为了更好管理，Git把这些快照串成一条时间线，每条时间线就是一个分支，每个不少于一次提交的Git仓库都至少有一个分支；每个commit都有一个commit-id，而分支更高级一些，每个分支都有一个名字，譬如<code>master</code>。</p>
<p>《<a href="/git-basics/">Git基础</a>》中曾说过「在Git中，使用<code>HEAD</code>表示当前版本」，这种说法其实不够准确，因为<code>HEAD</code>指针并不是指向commit，而是指向当前分支，当前分支才指向commit。譬如在下图中，<code>HEAD</code>指向<code>some branch</code>（只是举个例子，Git不允许这样命名），<code>some branch</code>指向到commit。</p>
<div class="imagediv" style="width: 280px; height: 140px"></div>

<p>如果新创建一个分支<code>other branch</code>，再把<code>HEAD</code>指向到它，就表示当前分支在<code>other branch</code>上：</p>
<div class="imagediv" style="width: 280px; height: 190px"></div>

<p>默认情况下，当前分支的名字叫<code>master</code>，也就是经常所说的<code>master</code>分支。</p>
<p>Note: <code>master</code>分支并不是一个特殊分支，它跟其他分支完全没有区别。之所以几乎每个Git仓库都有master分支，是因为<code>git init</code>命令默认创建它，并且大多数人都懒得去改动它。</p>
<p>Git的分支操作涉及的命令包括<code>git branch</code>、<code>git checkout</code>、<code>git merge</code>，通过该命令可以创建、删除以及列举分支，具体使用如下文所述。</p>
<p><strong>创建分支</strong></p>
<p>创建新分支很简单，其本质是创建一个可以移动的新指针。比如，创建一个名为<code>testing</code>的分支，使用<code>git branch &lt;branch-name&gt;</code>即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch <span class="built_in">test</span>-branch  <span class="comment"># 创建一个名为test-branch的分支</span></div></pre></td></tr></table></figure>
<p>这条命令会在当前commit上创建一个指针。</p>
<p><strong>列举分支</strong></p>
<p>使用<code>git branch</code>或者<code>git branch --list</code>可以将所有分支给显示出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch --list</div><div class="line">* master</div><div class="line">  <span class="built_in">test</span>-branch</div></pre></td></tr></table></figure>
<p><code>master</code>前的星号（<code>*</code>）标记了当前分支，如上意味着当前分支是<code>master</code>。</p>
<p>使用<code>git log</code>命令并辅以<code>--decorate</code>选项可以查看各个分支所指向的commit：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --decorate --pretty=oneline</div><div class="line">0eb9dceaaf8f86bacd76ee7109edc1fec256b56e (HEAD -&gt; master, <span class="built_in">test</span>-branch) version 3</div><div class="line">82be09ef9e1ddb51b41d9b2b36039218673e5a6e version 2</div><div class="line">87e61d64ce34693ad62a23f7ee448ed3d9278f56 version 1</div></pre></td></tr></table></figure>
<p>正如所见，当前<code>master</code>和<code>test-branch</code>分支均指向version 3所对应的commit。</p>
<p>P.S: 如何在创建分支时指定commit？</p>
<p><strong>切换分支</strong></p>
<p>使用<code>git checkout &lt;branch-name&gt;</code>命令切换分支。</p>
<p>切换分支的命令非常简单，似乎也没有太多让人纠结的选项；但仍然有一个重大疑问：切换分支时，会对工作区和暂存区有影响吗？影响如何？</p>
<p><del>我们的期待是什么样子呢？我所期待的是，在branch a捣鼓了一通后，因为某种原因切换到branch b捣鼓一番，再切回到branch a时，之前在branch a中捣鼓的东西仍然有保留，无论是工作区还是暂存区，都是原来的味道；再切换到branch b也是同样的结果。换句话说，我们希望在逻辑上，branch a和branch b的工作区和暂存区也保持独立，互不影响。</del></p>
<p><del>事实是我所期待的那样的吗？</del></p>
<p>根据<a href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell" target="_blank" rel="external">Git Pro</a>的说法，<code>git checkout &lt;branch-name&gt;</code>这条命令做了两件事情：一是使<code>HEAD</code>指向<code>&lt;branch-name&gt;</code>分支，二是将工作区恢复成<code>&lt;branch-name&gt;</code>分支所指向的快照内容。</p>
<p>P.S: 对上面这段说明，表示不怎么理解，有待更详细的分析。</p>
<p>最后，<code>git checkout &lt;branch-name&gt;</code>加上选项<code>-b</code>更强大，它的效果是，创建一个名为<code>&lt;branch-name&gt;</code>的分支并将切换到该分支。</p>
<p>P.S: 关于<code>git checkout &lt;branch-name&gt;</code>对工作区及暂存区的影响，现在仍然没有完全搞清楚，以后有了更深刻理解再补充吧。</p>
<p><strong>删除分支</strong></p>
<p>使用<code>git branch -d &lt;branch-name&gt;</code>删除分支，比较简单，只是需要注意的是，Git不允许删除当前分支。</p>
<p><strong>重命名分支</strong></p>
<p>使用<code>git branch -m &lt;current-name&gt; &lt;new-name&gt;</code>修改分支的名字，也比较简单。</p>
<p><strong>无冲突合并分支</strong></p>
<p><code>git merge</code>命令用于合并指定分支到当前分支。分支合并的复杂地方在于冲突处理。阅读了一些资料，总结了常见的无冲突合并，假设在<code>master</code>中合并<code>test</code>，则无冲突合并包括：</p>
<ul>
<li>在<code>test</code>中新增文件；</li>
<li>在<code>test</code>中删除某文件，<code>master</code>中的该文件是其ancestor版本；</li>
<li>在<code>test</code>中修改某文件，<code>master</code>中的该文件使其ancestor版本；</li>
</ul>
<p>P.S: 「解决分支冲突」是个大主题，在以后的博客中补充吧！</p>
<p>P.S: <code>git merge</code>的操作是事务性的吗？会存在某个文件合并成功但是别的文件合并失败的情况吗？</p>
<p>P.S: 对<code>git branch</code>这几个命令的使用不是很理（zan）解（tong），如果是我设计，<code>git branch</code>的作用与<code>git branch list</code>等同，都是用于列举所有分支；使用<code>git branch delete</code>代替<code>git branch -d</code>；使用<code>git branch rename</code>代替<code>git branch -m</code>。</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>为了能在任意Git项目上协作，需要知道如何管理自己的远程仓库。远程仓库是指托管在因特网或其他网络中的项目的版本库。你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。</p>
<p>除了之前提到的<code>git clone</code>，还有4个命令与远程仓库息息相关：<code>git remote</code>、<code>git fetch</code>、<code>git pull</code>、<code>git push</code>。有一张非常常见且直观的图对这些命令的功能进行了描述，如下：</p>
<div class="imagediv" style="width: 400px; height: 113px"></div>

<p><strong>远程仓库的查看、添加、移除以及重命名 – git remote</strong></p>
<p>为了便于管理，Git要求每个远程主机都有一个主机名，简单来说，<code>git remote</code>命令就是用于管理Git远程主机名的。</p>
<p>不带选项的时候，<code>git remote</code>命令列出所有远程主机：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git remote</div><div class="line">origin</div></pre></td></tr></table></figure>
<p>也可以指定选项<code>-v</code>，会显示更多信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git remote -v  </div><div class="line">origin  git://github.com/sadjason/sadjason.github.io.git (fetch)</div><div class="line">origin  git://github.com/sadjason/sadjason.github.io.git (push)</div></pre></td></tr></table></figure>
<blockquote>
<p>P.S: 克隆（<code>git clone</code>）版本库的时候，所使用的远程主机被Git自动命名为<code>origin</code>，如果想使用其他的主机名，需要使用<code>-o</code>选项指定，譬如<code>git clone -o example git://example.com/example.git</code>。</p>
</blockquote>
<p><code>git remote</code>是一个比较复杂的命令，旗下还包括一些子命令：</p>
<ul>
<li><code>git remote add</code>，用于<strong>添加远程仓库</strong>，使用起来非常简单，运行<code>git remote add &lt;name&gt; &lt;url&gt;</code>即可添加一个新的远程Git仓库，同时指定一个名称（任意）。</li>
<li><code>git remote show</code>，用于<strong>查看指定远程仓库的更多信息</strong>，基本使用格式是<code>git remote show &lt;name&gt;</code>。</li>
<li><code>git remote remove</code>，用于<strong>移除远程仓库</strong>，如果因为一些原因想要移除一个远程仓库，可以使用<code>git remote remove &lt;name&gt;</code>命令，<code>git remote rm</code>与之等价。</li>
<li><code>git remote rename</code>，用于<strong>远程仓库重命名</strong>，基本使用格式是<code>git remote rename &lt;old_name&gt; &lt;new_name&gt;</code>。</li>
</ul>
<blockquote>
<p>P.S: 如上所列的几个<code>git remote</code>命令，只有<code>git remote show</code>需要访问网络，其余几个都是本地操作。以<code>git remote add</code>为例，其本质无非是在本地为远程仓库的URL创建一个字符串映射（毕竟操作remote repository时输入URL并不是一个特别好的体验）。这个字符串映射并没有任何实际意义，可以简单看成是远程仓库URL的一个alias。stackoverflow中的<a href="https://stackoverflow.com/questions/5617211/what-is-git-remote-add-and-git-push-origin-master/" target="_blank" rel="external">解释</a>更棒一些。既然<code>git remote add</code>的本质是为远程仓库的url创建字符串映射，那么这个映射存放在哪里呢？答案是<code>.git/config</code>。</p>
</blockquote>
<p><strong>关于git remote的一些补充</strong></p>
<p>我在学习过程中对这个命令产生了极大的误解，我以为能够通过<code>git remote</code>管理远程（服务器）repository，譬如远程在服务器中创建一个repository。</p>
<p>甚至做了如下的测试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ mkdir MyLocalRepository</div><div class="line">$ <span class="built_in">cd</span> MyLocalRepository</div><div class="line">$ git init</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"hello, github"</span> &gt;&gt; README.md</div><div class="line">$ git add README.md</div><div class="line">$ git commit -m <span class="string">"add readme file"</span></div><div class="line">$ git remote add MyLocalRepository https://github.com/xxoo/MyLocalRepository.git</div></pre></td></tr></table></figure>
<p>其中最后一步，我的目的是在github中创建一个名为MyLocalRepository的仓库，上述命令执行完后没有任何错误信息（UNIX的哲学是没有消息就是好消息）。如果这个命令执行成功，我能够在github中看到一个新的仓库被创建（不是通过<a href="https://github.com/new" target="_blank" rel="external">Create a New Repository</a>这个接口创建哦）。但我登录github后，啥都没发生。</p>
<p>这个测试结果说明我对<code>git remote</code>的理解有问题，于是去stackoverflow中寻找「可否在本地远程在github上创建repository」问题答案，还真找到了，即<a href="http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-ssh" target="_blank" rel="external">Is it possible to create a remote repository on github from client</a>。显然，stackoverflow给出的答案是：可以，但是需要通过github的api，这是另外一个故事了，本文不涉入。</p>
<p><strong>从远程仓库抓取数据 – git fetch</strong></p>
<p>从远程仓库中获取数据，可以执行<code>git fetch &lt;remote-repository-name&gt;</code>命令，该命令会访问远程仓库，从中拉取所有本地还没有的数据，执行完成后，本地将会拥有那个远程仓库中的所有分支的引用。</p>
<p>默认情况下，<code>git fetch</code>取回所有分支的更新，但若只想取回特定分支的更新，可以指定分支名：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git fetch &lt;remote-repository-name&gt; &lt;branch-name&gt;</div></pre></td></tr></table></figure>
<p>使用<code>git fetch</code>的一些说明：</p>
<ul>
<li>如果不指定<code>&lt;remote-repository-name&gt;</code>，则默认执行<code>git fetch origin</code>，执行成功的前提是<code>origin</code>这个远程仓库确实存在；</li>
<li><code>git fetch</code>可以fetch多个repository，指定选项<code>--all</code>即可；</li>
<li><code>git fetch</code>仅仅是将指定的远程仓库的所有分支内容全部下载到本地，除此之外不做其他的事情（譬如分支合并）；</li>
</ul>
<p><strong>git pull</strong></p>
<p><code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。其完整格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull &lt;remote-repository-name&gt; &lt;remote-branch-name&gt;:&lt;<span class="built_in">local</span>-branch-name&gt;</div></pre></td></tr></table></figure>
<p>比如，取回<code>origin</code>远程仓库的<code>next</code>分支，与本地的<code>master</code>分支合并，需要写成下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull origin next:master</div></pre></td></tr></table></figure>
<p>如果远程分支是与当前分支合并，则<code>:&lt;local-branch-name&gt;</code>可以去掉，譬如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull origin next</div></pre></td></tr></table></figure>
<p>P.S: <code>git pull</code>是事务性操作吗？</p>
<p><strong>推送数据到远程仓库 – git push</strong></p>
<p><code>git push</code>命令用于将本地分支的更新，推送到远程主机，使用格式是：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push &lt;remote-repository-name&gt; &lt;<span class="built_in">local</span>-branch-name&gt;:&lt;remote-branch-name&gt;</div></pre></td></tr></table></figure>
<p><strong>git clone v.s git fetch v.s git pull</strong></p>
<p><code>git clone</code>、<code>git fetch</code>、<code>git pull</code>这三个命令似乎都是用于从远程拉取数据，三者有啥区别呢？</p>
<p>本地没有repository时，<code>git clone</code>将远程repository整个下载下来；<code>git fetch</code>将远程新的commit数据（如果有的话）下载过来；<code>git pull</code>相当于<code>git fetch</code>和<code>git merge</code>，在<code>git fetch</code>的基础上，进行分支合并。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="http://git-scm.com/book/" target="_blank" rel="external">Pro Git</a></li>
<li><a href="https://git-scm.com/book/zh/v2/" target="_blank" rel="external">Pro Git中文版</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">Git远程操作详解</a></li>
<li><a href="https://stackoverflow.com/questions/5617211/what-is-git-remote-add-and-git-push-origin-master/" target="_blank" rel="external">What is git-remote-add and git-push-origin-master?</a></li>
<li><a href="http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-opening-br" target="_blank" rel="external">Is it possible to create a remote repo on GitHub from the CLI without opening browser?</a></li>
<li><a href="https://snowdream86.gitbooks.io/github-cheat-sheet/content/zh/index.html" target="_blank" rel="external">GitHub秘籍</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tools/">Tools</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Others/">Others</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-git-basics" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/05/git-basics/" class="article-date">
  	<time datetime="2015-12-05T03:04:04.000Z" itemprop="datePublished">2015-12-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/05/git-basics/">Git基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Git起步"><a href="#Git起步" class="headerlink" title="Git起步"></a>Git起步</h2><p>目前市场上主流的<strong>版本控制系统</strong>（Version Control Systems，简称VCS）有两种：<strong>集中式版本控制系统</strong>（Centralized Version Control Systems，简称CVCS）、分布式版本控制系统（Distributed Version Control System，简称DVCS）。其中CVCS包括CVS、Subversion以及Perforce。</p>
<p>Git是分布式版本控制系统（除了Git，DVCS还包括Mercurial、Bazaar以及Darcs等）。这一部分阐述Git的工作特点，并介绍一些基本概念。</p>
<p><strong>分布式 v.s 集中式</strong></p>
<p>分布式版本控制系统与集中式版本控制系统有何不同呢？</p>
<p>首先，不同于集中式版本控制系统，分布式版本控制系统没有所谓的「中央服务器」，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当「中央服务器」的电脑，但这个服务器的作用仅仅是用来方便交换大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<p><strong>直接记录快照，而非差异比较</strong></p>
<p>Git和其他版本控制系统不同，Git只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统（CVS、Subversion、Perforce等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，如下图。</p>
<div class="imagediv" style="width: 400px; height: 155px"></div>

<p>Git并不保存这些前后变化的差异数据。实际上，Git更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息（即根据文件信息，使用SHA-1算法计算得到的一个40位字串），并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git不会再次保存，而只对上次保存的快照作一链接。Git对待数据更像是一个快照流。Git的工作方式如下图所示。</p>
<div class="imagediv" style="width: 400px; height: 150px"></div>

<p><strong>近乎所有操作都是本地执行</strong></p>
<p>CVCS的几乎所有操作都需要连接网络，譬如使用Subversion和CVS，你能修改文件，但不能向数据库提交修改（因为本地数据库离线了）。</p>
<p>而Git中的绝大多数操作都只需要访问本地文件和资源，不用联网。举个例子，要浏览项目的历史，Git不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p>
<p><strong>时刻保持数据完整性</strong></p>
<p>在保存到Git之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后Git一无所知。这项特性作为Git的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git都能立即察觉。Git使用SHA-1算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个SHA-1哈希值，作为<strong>指纹字符串</strong>。该字串由40个十六进制字符（0-9及a-f）组成，看起来就像是：<code>24b9da6552252987aa493b52f8696cd6d3b00373</code>。</p>
<p>Git的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在Git数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</p>
<p><strong>多数操作仅添加数据</strong></p>
<p>常用的Git操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。在别的VCS中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在Git里，一旦提交快照之后就完全不用担心丢失数据，特别是在养成定期推送到其他仓库的习惯的情况下。</p>
<p><strong>工作区、版本库以及暂存区</strong></p>
<p>所谓工作区（working directory，又常称之为「工作目录」），就是Git目录（一般是<code>.git</code>目录）之外的区间。</p>
<blockquote>
<p>P.S: 每个项目都有一个<strong>Git目录</strong>（如果<code>git clone</code>出来的话，就是其中的<code>.git</code>目录；如果<code>git clone --bare</code>的话，新建的目录本身就是Git目录），它是Git用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。</p>
</blockquote>
<p>所谓的暂存区只不过是个简单的文件，一般都放在Git目录中。有时候人们会把这个文件叫做index文件，不过标准说法还是叫暂存区。</p>
<p>Git目录里除了index文件（暂存区）之外，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针<code>HEAD</code>。</p>
<div class="imagediv" style="width: 429px; height: 300px"></div>

<p><strong>文件的三种状态</strong></p>
<p>被Git管理的任何一个文件，在Git内都有三种状态：</p>
<ul>
<li>已提交（committed），表示数据已经安全的保存在本地数据库中；</li>
<li>已修改（modified），表示修改了文件，但还没保存到数据库中；</li>
<li>已暂存（staged），表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中；</li>
</ul>
<p>由此可以看到Git管理项目时，文件流转的三个区域：</p>
<div class="imagediv" style="width: 400px; height: 220px"></div>

<p>基本的Git工作流程如下：</p>
<ol>
<li>在工作区中修改某些文件；</li>
<li>对修改后的文件进行快照，然后保存到暂存区；</li>
<li>提交更新，将保存在暂存区的文件快照永久转储到版本库中。</li>
</ol>
<h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><p>这一部分将介绍几个最基本的，也是最常用的的Git命令；相对比较复杂的分支管理和远程操作，会在后续的博客中补充。</p>
<h3 id="取得项目的Git仓库"><a href="#取得项目的Git仓库" class="headerlink" title="取得项目的Git仓库"></a>取得项目的Git仓库</h3><p>有两种取得Git项目仓库的方法。第一种是在现存的目录下，通过导入所有文件来创建新的Git仓库。第二种是从已有的Git仓库克隆出一个新的镜像仓库来。</p>
<p><strong>从现有仓库克隆 – git clone</strong></p>
<p>如果想对某个开源项目出一份力，可以先把该项目的Git仓库复制一份出来，这就需要用到<code>git clone</code>命令。注意，这里用的是<code>clone</code>，而不是像其他CVCS（譬如Subversion）里用到的<code>checkout</code>。这是个非常重要的差别，Git获取的是项目历史的所有数据（每个文件的每一个版本），服务器上有的数据经过<code>git clone</code>后，本地也都有了；换句话说，即使服务器的磁盘发生故障，任何一个克隆出来的镜像都可以重建服务器上的仓库，回到当初克隆时的状态。</p>
<p>克隆仓库的最基本命令格式为<code>git clone [url]</code>。比如，要克隆本博客仓库，可以用下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git://github.com/sadjason/sadjason.github.io.git</div></pre></td></tr></table></figure>
<p>这会在当前目录下创建名为<code>sadjason.github.io</code>的目录，其中包含一个<code>.git</code>的目录，用于保存下载下来的所有版本记录，然后从中checkout最新版本的文件拷贝。如果进入这个新建的目录，会看到项目中的所有文件已经在里面了，准备好后续的开发和使用。</p>
<p>默认情况下，<code>git clone</code>还会完成「从Git目录checkout最新版本到根目录」的工作，若想略过这一步骤，加上<code>-n</code>（表示no checkout）选项，即：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> -n git://github.com/sadjasonsadjason.github.io.git</div></pre></td></tr></table></figure>
<p>除了no checkout设定，结合我的实践体验，将<code>git clone</code>的其他用法也给列出来：</p>
<ul>
<li>克隆到指定目录。格式为<code>git clone url target_dir</code>。</li>
<li>从本地克隆。格式为<code>git clone /path/to/repo</code>；还有一种更简单的方法，<code>Ctrl+C</code>-&gt;<code>Ctrl+V</code>或者<code>Cmd+C</code>-&gt;<code>Cmd+V</code>，也是醉了😂</li>
</ul>
<blockquote>
<p>P.S: 还可以设置<code>git clone</code>的选项，只克隆某个指定的分支，本文暂时不讨论分支相关问题，以后再说吧。</p>
</blockquote>
<p><strong>在工作目录中初始化新仓库 – git init</strong></p>
<p>要对现有的某个项目开始用Git管理，只需到此项目所在的根目录执行<code>git init</code>命令，此命令对该目录进行初始化。</p>
<p>初始化后，在当前目录会出现一个名为<code>.git</code>的目录，所有Git需要的数据和资源都存放在这个目录中，如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ <span class="comment"># 新建一个工程目录（简单的C工程）</span></div><div class="line">$ mkdir A-Simple-C-Project</div><div class="line">$ <span class="built_in">cd</span> A-Simple-C-Project</div><div class="line">$ git init</div><div class="line">Initialized empty Git repository <span class="keyword">in</span> ~/A-Simple-C-Project/.git/</div><div class="line">$ ls -al</div><div class="line">drwxr-xr-x   4 zhangbuhuai  staff  136  7  7 09:39 .</div><div class="line">drwxr-xr-x   4 zhangbuhuai  staff  136  7  7 09:38 ..</div><div class="line">drwxr-xr-x  10 zhangbuhuai  staff  340  7  7 09:39 .git</div></pre></td></tr></table></figure>
<h3 id="记录更新到仓库"><a href="#记录更新到仓库" class="headerlink" title="记录更新到仓库"></a>记录更新到仓库</h3><p>工作区下面的所有文件都不外乎两种状态：<strong>已跟踪</strong>或<strong>未跟踪</strong>。已跟踪的文件是指被纳入版本控制管理的文件，在上次快照时有它们的记录，工作一段时间后，它们的状态可能是未更新、已修改（但未放入暂存区）或者已放入暂存区。而未跟踪文件，它们既没有上次更新时的快照，也不在当前暂存区域。</p>
<p>初次克隆某个仓库时，工作区中的所有文件都属于已跟踪文件，且状态为<strong>未修改</strong>。</p>
<p>在编辑过某些文件之后，Git将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。使用Git时的文件状态变化周期如下图所示。</p>
<div class="imagediv" style="width: 400px; height: 165px"></div>

<p><strong>检查当前文件状态 – git status</strong></p>
<p>要确定哪些文件当前处于什么状态，可以用<code>git status</code>命令。如果在克隆仓库之后立即执行此命令，会看到类似这样的输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">nothing to commit, working directory clean</div></pre></td></tr></table></figure>
<p>这说明现在的工作区相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪的新文件，否则Git会在这里列出来。该命令还显示了当前所在的分支是<code>master</code>。</p>
<p>现在在当前目录(~/A-Simple-C-Project/）下创建一个新文件main.c，再次使用<code>git status</code>会看到该文件会出现在未跟踪文件列表中，这一次加上<code>-s</code>选项,如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ touch main.c</div><div class="line">$ git status <span class="_">-s</span></div><div class="line">?? main.c</div></pre></td></tr></table></figure>
<p>加上<code>-s</code>的状态报告要简洁得多，其中<code>??</code>标记表示该文件是未跟踪文件。</p>
<blockquote>
<p>P.S: <code>git status -s</code>的状态报告中有几种可能的状态符：</p>
<ul>
<li><code>??</code>：表示未跟踪；</li>
<li><code>A</code>：表示新添加到暂存区，但还没提交；</li>
<li><code>M_</code>（<code>M</code>在左侧）：表示已修改且添加（<code>git add</code>）到暂存区中，但还没提交（<code>git commit</code>)；</li>
<li><code>_M</code>（<code>M</code>在右侧）：表示已跟踪文件被修改了，但还没放入到暂存区中；</li>
<li><code>AM</code>：表示新增（新跟踪）文件，但后来又修改了，却没添加（<code>git add</code>）到暂存区中；</li>
<li><code>MM</code>：表示已跟踪文件被修改了，且添加（<code>git add</code>）到暂存区中，但后来又被修改了，却没有添加（<code>git add</code>）到暂存区；</li>
<li><code>_D</code>（<code>D</code>在右侧）：表示文件已经从工作区中删除（<code>rm</code>），但还没将更新添加到暂存区；</li>
<li><code>D_</code>（<code>D</code>在左侧）：表示文件已经从工作区中删除（<code>git rm</code>），且已将更新添加到暂存区，但还没提交（<code>git commit</code>)；<br>动手体验一下就知道了🙄。</li>
</ul>
</blockquote>
<p>或者通过<code>git status file_name1 file_name2 ...</code>查看某一个（或多个）文件的状态：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git status main.c <span class="_">-s</span></div><div class="line">?? main.c</div></pre></td></tr></table></figure>
<p>未跟踪的文件意味着Git在之前的快照中没有这些文件；Git不会自动将之纳入跟踪范围，除非明白告诉它「我需要跟踪该文件」，因此不用担心把临时文件的也归入到版本管理中。</p>
<p><strong>跟踪新文件 – git add</strong></p>
<p>使用<code>git add</code>开始跟踪一个新文件。<code>git add file1 file2</code>命令使得file1和file2这两个文件被纳入到Git管理；<code>git add</code>还可以让某个目录被追踪，即<code>git add some_dir</code>，值得一提的是，该命令会让some_dir下的所有文件被追踪，而不仅仅是some_dir目录本身。</p>
<p><strong>暂存已修改文件 – git add</strong></p>
<p>对于工作区的文件，哪怕该文件已经被追踪了，当该文件被修改时，也应该在提交到版本库之前把它添加到暂存区，此操作仍然也由<code>git add</code>完成。</p>
<blockquote>
<p>Note: <code>git add</code>是个多功能命名，根据目标文件的状态不同，此命令的作用效果不同，其一是它可以跟踪新文件，其二是把已跟踪文件放到暂存区中，其三是在合并时把冲突的文件标记为已解决状态。</p>
</blockquote>
<p><strong>忽略某些文件</strong></p>
<p>我们常常会有些文件无需纳入到Git管理中，譬如工程项目源码、配置之外的文件（尤其是二进制文件等）。我们可以创建一个<code>.gitignore</code>文件，列出需要忽略的文件模式。来看一个实际的例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat .gitignore</div><div class="line">*.[oa]</div><div class="line">*~</div></pre></td></tr></table></figure>
<p>第一行告诉Git忽略所有已<code>.o</code>或<code>.a</code>结尾的文件，一般这类对象文件和存档文件都是编译过程中出现的，用不着跟踪它们的版本信息；第二行告诉Git忽略所有以波浪符（<code>~</code>）结尾的文件，许多文本编译软件（比如Emacs）都用这样的文件名保存副本。此外，还可能需要忽略<code>log</code>、<code>tmp</code>或者<code>pid</code>目录，以及自动生成的文档等等。</p>
<p>要养成一开始就设置好<code>.gitignore</code>文件的习惯，以免将来误提交这类无用的文件。</p>
<p><code>.gitignore</code>的规格规范如下：</p>
<ul>
<li>所有空行或者以注释（<code>#</code>）开头的行都会被Git忽略</li>
<li>可以使用标准的glob模式匹配</li>
<li>匹配模式最后跟反斜杠（<code>/</code>）说明要忽略的是目录</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反</li>
</ul>
<p>P.S: 所谓的glob模式是指shell所使用的简化了的正则表达式。</p>
<p>GitHub有一个十分详细的针对数十种项目及语言的<code>.gitignore</code>文件<a href="https://github.com/github/gitignore/" target="_blank" rel="external">列表</a>。</p>
<p><strong>查看工作区相对于暂存区、暂存区相对于版本库的更新 – git diff</strong></p>
<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，但它所显示的讯息还是比较简单，<code>git diff</code>可以用来查看difference，会使用文件补丁的格式显示具体添加和删除的行。<code>git diff</code>的用法比较丰富。</p>
<p>不加参数的<code>git diff</code>比较的是工作区和暂存区之间的差异，也就是修改之后还没有暂存起来的变化内容。上文的main.c是空文件，现在编辑内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>保存，使用<code>git diff</code>查看工作区相对于暂存区的变化：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">index e69de29..cd9ca7d 100644</div><div class="line">--- a/main.c</div><div class="line">+++ b/main.c</div><div class="line">@@ -0,0 +1,5 @@</div><div class="line">+<span class="comment">#include &lt;stdio.h&gt;</span></div><div class="line">+</div><div class="line">+int main(void) &#123;</div><div class="line">+    <span class="built_in">return</span> 0;</div><div class="line">+&#125;</div></pre></td></tr></table></figure>
<p>使用<code>git add main.c</code>命令将main.c的变化放入到暂存区，然后再使用<code>git diff</code>查看，可以看到报告内容为空。</p>
<p><code>git diff</code>加上<code>--cached</code>选项，能够查看暂存区相对于版本库（默认是HEAD指向的分支）的变化，譬如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ git diff --cached</div><div class="line">diff --git a/main.c b/main.c</div><div class="line">new file mode 100644</div><div class="line">index 0000000..cd9ca7d</div><div class="line">--- /dev/null</div><div class="line">+++ b/main.c</div><div class="line">@@ -0,0 +1,5 @@</div><div class="line">+#include &lt;stdio.h&gt;</div><div class="line">+</div><div class="line">+int main(void) &#123;</div><div class="line">+    return 0;</div><div class="line">+&#125;</div></pre></td></tr></table></figure>
<p>P.S: <code>--staged</code>选项和<code>--cached</code>作用相同，且表达意思更准确一些，只是1.6.1及更高版本才能使用。</p>
<p><strong>提交更新 – git commit</strong></p>
<p>如果所有文件新增、文件修改都放入了暂存区，那么意味着已经准备妥当，可以提交以记录成版本了。如果不确定，可以使用<code>git status</code>或者<code>git diff</code>查看一下。提交操作命令是<code>git commit</code>，常用的格式是<code>git commit -m &quot;some commit messages&quot;</code>。</p>
<p>正常情况下，修改一个文件的流程是：在工作区修改-&gt;<code>git add ...</code>-&gt;<code>git commit ...</code>。有时候会觉得<code>git add</code>太麻烦了，就可以直接跳过使用暂时区，help文档描述如下：</p>
<blockquote>
<p>By using the <code>-a</code> switch with the commit command to automatically “add” changes from all known files (i.e. all files that are already listed in the index) and to automatically “rm” files in the index that have been removed from the working tree, and then perform the actual commit.</p>
</blockquote>
<p><strong>移除文件 – git rm</strong></p>
<p>要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区移除），然后提交。可以用<code>git rm</code>命令完成此项工作，并连带从工作区中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果只是简单的从工作区中手工删除文件，运行<code>git status</code>时会看到「Changes not staged for commit」信息，此时还得补上<code>git add</code>命令才行。</p>
<p>还有一种常见情况是，我们想把文件从Git仓库中删除（亦即从暂存区中移除），但仍然希望保留在当前工作区中。换句话说，想让文件保存在磁盘，但并不想让Git继续跟踪该文件。当忘记添加<code>.gitignore</code>文件，不小心把一个很大的日志文件或一堆<code>.a</code>这样的编译生成文件添加到暂存区时，这一做法尤其有用，为达到这一目的，需要加上<code>--cached</code>选项。</p>
<p><strong>移动文件 – git mv</strong></p>
<p>不像其他VCS，Git并不显式跟踪文件移动操作（包括重命名）。可使用<code>git mv</code>命令处理文件移动处理，简单来说，运行<code>git mv file_from file_to</code>相当于运行了下面三条命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mv file_from file_to</div><div class="line">$ git rm file_from</div><div class="line">$ git add file_to</div></pre></td></tr></table></figure>
<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，也许想回顾下提交历史. 完成这个任务最简单而又有效的工具是<code>git log</code>命令。</p>
<p>注意，<code>git log</code>命令并不是查看所有git操作记录，而只是查看<code>git commit</code>的记录。</p>
<p>默认不用任何参数的话，<code>git log</code>会按提交时间列出所有的commits，最近的更新排在最上面，如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">log</span></div><div class="line">commit 75c19156d70f1617cba0091bd43494f840c91ea2</div><div class="line">Author: sadjason &lt;sadjason@qq.com&gt;</div><div class="line">Date:   Sun Jul 10 13:44:23 2016 +0800</div><div class="line"></div><div class="line">    modify main.c</div><div class="line"></div><div class="line">commit 007069d0f1b81bd34823dec48d62b959cc665ec0</div><div class="line">Author: sadjason &lt;sadjason@qq.com&gt;</div><div class="line">Date:   Sun Jul 10 13:41:54 2016 +0800</div><div class="line"></div><div class="line">    add a.out</div><div class="line"></div><div class="line">commit c589bac19d121c56cbc078f67ab7bd9a91764815</div><div class="line">Author: sadjason &lt;sadjason@qq.com&gt;</div><div class="line">Date:   Sun Jul 10 13:40:59 2016 +0800</div><div class="line"></div><div class="line">    add two files</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<p>可以看到，这个命令会列出每个commit的SHA-1校验和、作者的姓名和电子邮件、提交时间、提交说明。</p>
<p><code>git log</code>有许多选项，下面介绍一些常用的。</p>
<p>一个常用的选项是<code>-p</code>，用来显示每次提交的内容差异；也可以加上<code>-2</code>来显示最近两次提交。</p>
<p>也可以为<code>git log</code>附带一系列的总结性选项。比如说，如果想看到每次提交的简略的统计信息，可以使用<code>--stat</code>选项。</p>
<p>关于更多<code>git log</code>的选项配置，参考<a href="https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History" target="_blank" rel="external">Viewing the Commit History</a>。</p>
<h3 id="撤销与版本回退"><a href="#撤销与版本回退" class="headerlink" title="撤销与版本回退"></a>撤销与版本回退</h3><p>在任何一个阶段，都有可能想要撤销某些操作。这里，将学习几个撤销所作修改的基本工具。除了撤销，这一部分还介绍版本回退。</p>
<p>值得一提的是，有些撤销操作是不可逆的。</p>
<p><strong>撤销最后一次提交</strong></p>
<p>有时候提交完了，才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有<code>--amend</code>选项（amend译作「修改」）的命令尝试重新提交：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit --amend -m <span class="string">"some message"</span></div></pre></td></tr></table></figure>
<p>这个命令会将暂存区中的文件提交，并把当前分支的最新commit给覆盖掉。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">"last commit"</span>  <span class="comment"># mark 1</span></div><div class="line">$ <span class="comment"># some modifies</span></div><div class="line">$ git commit --amend -m <span class="string">"new commit"</span>  <span class="comment"># mark 2</span></div><div class="line"><span class="comment"># 作用效果是：mark 1标记的commit被mark 2标记的commit给覆盖掉</span></div></pre></td></tr></table></figure>
<p>如果自上次提交以来还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而修改的只是commit message：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">"last commit"</span>  <span class="comment"># 上一次commit</span></div><div class="line">$ git commit --amend -m <span class="string">"new commit"</span>  <span class="comment"># 更新commit message</span></div></pre></td></tr></table></figure>
<p><strong>撤销已经暂存的文件 – git reset</strong></p>
<p><code>git add</code>会影响暂存区里的文件状态，有时需要撤销。例如，已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了<code>git add *</code>暂存了它们俩。如何只取消暂存两个中的一个呢？<code>git status</code>命令其实有提示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ touch file_step_1 file_step_2  <span class="comment"># 创造两个新文件</span></div><div class="line">$ git add *</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">	new file:   file_step_1</div><div class="line">	new file:   file_step_2</div></pre></td></tr></table></figure>
<p>在「Changes to be committed」正下方，提示使用「git reset HEAD <file>…」来取消暂存。</file></p>
<p>所以，我们可以这样来暂存取消file_step_2文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ git reset HEAD file_step_2</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">	new file:   file_step_1</div><div class="line"></div><div class="line">Untracked files:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</div><div class="line"></div><div class="line">	file_step_2</div></pre></td></tr></table></figure>
<p>P.S: <code>git reset HEAD</code>命令会撤销所有暂存。</p>
<p><strong>撤销对文件的修改 – git checkout</strong></p>
<p>可能经常会有这样的场景，在工作区对某个文件进行修改，但因为某种原因想放弃对它的修改，想把它还原到上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作区的样子），怎么办？其实<code>git status</code>也告诉了应该如何做，比如，在提交了所有更新后再次修改main.c文件，调用<code>git status</code>命令可以看到如下信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ <span class="comment"># 修改main.c文件</span></div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">	modified:   main.c</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure>
<p>「use “git checkout – <file>…” to discard changes in working directory」提示告诉了我们该怎么干，照做就是：</file></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- main.c  <span class="comment"># 注意`--`和`main.c`之间得用空格隔开</span></div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">nothing to commit, working directory clean</div></pre></td></tr></table></figure>
<p>值得注意的是，<code>git checkout -- &lt;file&gt;</code>是一个危险的命令。对文件做的任何修改都会消失 – 它只是拷贝了另一个文件来覆盖它。因此，除非确实清楚不想要那个文件了，否则不要使用这个命令。此外，该命令能执行成功的前提是仓库中已有该文件。</p>
<p><del>P.S: 如果修改了某个文件，并且把它提交到暂存区，但现在想放弃该文件的所有修改，该如何处理呢？也简单，先<code>git reset HEAD &lt;file&gt;</code>，然后再<code>git checkout -- &lt;file&gt;</code>即可。</del></p>
<p>补充说明：<code>git checkout -- &lt;file&gt;</code>的意思是把<code>&lt;file&gt;</code>文件在工作区的修改全部撤销，这里有两种情况：一种是<code>&lt;file&gt;</code>自修改后还没有被放到暂存区，该命令作用后，<code>&lt;file&gt;</code>回到和版本库一模一样的状态；另一种是<code>&lt;file&gt;</code>已经被添加到暂存区，且之后又作了修改，即该命令对应的状态符是<code>MM</code>，该命令作用后，<code>&lt;file&gt;</code>回到添加到暂存区后的状态。</p>
<p>P.S: <code>git reset --hard HEAD</code>命令也能使得工作区的所有文件状态恢复到与当前版本库一致。</p>
<p><strong>版本回退 – git reset</strong></p>
<p>很多时候遇到这样抓狂的事情：在某个节点之后修改工程，做了一番修改后，工程无法再次通过编译，或者无法达到想要的目的，寻找问题却始终不得结果，无奈之下，只能回到最后一次正常的节点推倒重来。如果项目使用Git进行管理，那么「回到最后一次正常的节点」应该就是常说的版本回退。</p>
<p>版本回退的意义应该不用赘述了。如何处理呢？首先确定工具（命令），<code>git reset</code>是也！</p>
<p>下面阐述版本回退的内容比较长…</p>
<p>这里先简要介绍两个概念：commit-id和<code>HEAD</code>指针。每个版本（每次commit）都有一个id，这个id是Git自动生成的，即所谓的commit-id；<code>HEAD</code>指针的概念相对复杂一些，它与分支也有关系，当前还没有涉及到分支，目前所需要知道的是：在Git中，使用<code>HEAD</code>表示当前版本，<code>HEAD^</code>表示上一个版本，<code>HEAD^^</code>表示上上个版本，依次类推，当然，也可以使用<code>HEAD~n</code>表示<code>HEAD</code>的前<code>n</code>个版本（<code>HEAD^</code>等价于<code>HEAD~1</code>）。</p>
<p>P.S: 貌似在比较高的版本中将<code>HEAD^</code>这种语义给剔除掉了，我所使用的版本是2.7.4。</p>
<p>举个例子，创建一个Git仓库，提交3次，提交的message分别写为「version 1」「version 2」「version 3」，通过<code>git log</code>命令可以看到这3次提交记录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="comment"># 创建一个demo，提交3次，通过git log查看3个版本记录</span></div><div class="line">$ git <span class="built_in">log</span> --pretty=oneline  <span class="comment"># --pretty=oneline选项会让显示结果更简洁一些</span></div><div class="line">0eb9dceaaf8f86bacd76ee7109edc1fec256b56e version 3</div><div class="line">82be09ef9e1ddb51b41d9b2b36039218673e5a6e version 2</div><div class="line">87e61d64ce34693ad62a23f7ee448ed3d9278f56 version 1</div></pre></td></tr></table></figure>
<p>下图是具象化的说明：</p>
<div class="imagediv" style="width: 299px; height: 149px;"></div>

<p>如果想看当前的版本库信息，即<code>HEAD</code>指针指向的commit，可以通过<code>git show HEAD</code>查看，同样，通过<code>git show HEAD~&lt;n&gt;</code>可以查看往前的第<code>n</code>个版本信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ git show HEAD  <span class="comment"># 查看当前版本库信息</span></div><div class="line">commit 0eb9dceaaf8f86bacd76ee7109edc1fec256b56e</div><div class="line">Author: zhangwei72 &lt;zhangwei72@meituan.com&gt;</div><div class="line">Date:   Sat Jul 23 19:08:05 2016 +0800</div><div class="line"></div><div class="line">    version 3</div><div class="line">    ...</div><div class="line">$ git show HEAD~1  <span class="comment"># 查看往前的版本库信息</span></div><div class="line">commit 82be09ef9e1ddb51b41d9b2b36039218673e5a6e</div><div class="line">Author: zhangwei72 &lt;zhangwei72@meituan.com&gt;</div><div class="line">Date:   Sat Jul 23 19:07:38 2016 +0800</div><div class="line"></div><div class="line">    version 2</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>讲了这么多<code>HEAD</code>指针，其实是为了给「通过<code>git reset</code>回退版本」作铺垫。</p>
<p>所谓版本回退，根据我的理解，其本质是设置<code>HEAD</code>指针的指向，譬如回退到version 2，其实所需要做的是重定向<code>HEAD</code>指针到version 2的快照：</p>
<div class="imagediv" style="width: 300px; height: 150px;"></div>

<p>设置<code>HEAD</code>指针有两种方式，一种是<code>git reset &lt;commit-id&gt;</code>，另一种是通过<code>git reset HEAD~&lt;n&gt;</code>。假如当前<code>HEAD</code>指针指向version 3，<code>git reset 82be09e</code>（82be09e是version 2对应的commit-id的前6位）会将<code>HEAD</code>指向到version 2；<code>git reset HEAD~1</code>也会有同样的作用。</p>
<p>本文将<code>HEAD</code>指针指向到version 2：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git reset HEAD~1  <span class="comment"># 将HEAD指针指向到前一个版本（version 2）</span></div><div class="line">$ git show HEAD</div><div class="line">commit 82be09ef9e1ddb51b41d9b2b36039218673e5a6e</div><div class="line">Author: zhangwei72 &lt;zhangwei72@meituan.com&gt;</div><div class="line">Date:   Sat Jul 23 19:07:38 2016 +0800</div><div class="line"></div><div class="line">    version 2</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>现在确定当前版本（<code>HEAD</code>指针）切换到version 2了，再用<code>git log</code>查看commits信息会发现version 3不见了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --pretty=oneline</div><div class="line">82be09ef9e1ddb51b41d9b2b36039218673e5a6e version 2</div><div class="line">87e61d64ce34693ad62a23f7ee448ed3d9278f56 version 1</div></pre></td></tr></table></figure>
<p>问题来了：version 3快照会被删除吗？</p>
<p>答案是：不会！version 3之所以没有在<code>git log</code>报告中显示出来，是因为<code>git log</code>的报告结果依赖于<code>HEAD</code>指针，它只会将比<code>HEAD</code>所指向的commit以及更旧的commits给查询出来。</p>
<p>那么还有机会将当前版本切换到version 3吗？在Git中，总有后悔药可以吃的。version 3没有被删除，只要知道其commit-id，就可以通过<code>git reset &lt;commit-id&gt;</code>切回到version 3。</p>
<p>这就说到另外一个命令：<code>git reflog</code>。该命令可以查看所有分支的所有操作记录（包括commit和reset的操作）。简单一句话，可以通过<code>git reflog</code>找到version 3的commit-id，有了commit-id，后面的事情就好办了…</p>
<p>使用<code>git reset</code>重置<code>HEAD</code>时，还会涉及几个选项：</p>
<ul>
<li><code>--mixed</code>，此为默认选项，除了设置<code>HEAD</code>，还额外的将暂存区给清空；</li>
<li><code>--soft</code>，此选项除了设置<code>HEAD</code>指针，其他的啥都不干；</li>
<li><code>--hard</code>，此选项在<code>--mixed</code>的基础上还会重置工作区，使得工作区的文件状态和<code>HEAD</code>所指向的版本完全一致；</li>
<li><code>--merge</code>和<code>--keep</code>，这俩选项似乎很少用到，略过不讲；</li>
</ul>
<p>P.S: 关于<code>git reset</code>的使用，似乎还有很多内容没有说到，以后再另外补充吧！</p>
<p>还有一个问题：重定向<code>HEAD</code>后，如何将<code>HEAD</code>之后的commits给永远删掉呢？</p>
<p>接下来的Git博客：<a href="/git-branching-and-remoting/">Git分支与远程操作</a>。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="http://git-scm.com/book/" target="_blank" rel="external">Pro Git</a></li>
<li><a href="https://git-scm.com/book/zh/v2/" target="_blank" rel="external">Pro Git中文版</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374831943254ee90db11b13d4ba9a73b9047f4fb968d000" target="_blank" rel="external">廖雪峰Git教程之撤销修改</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tools/">Tools</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Others/">Others</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-good-resources-about-ios" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/11/good-resources-about-ios/" class="article-date">
  	<time datetime="2015-10-11T12:43:39.000Z" itemprop="datePublished">2015-10-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/11/good-resources-about-ios/">iOS好资源</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="好博客"><a href="#好博客" class="headerlink" title="好博客"></a>好博客</h2><ul>
<li><a href="http://www.infoq.com/cn/mobile-weekly/" target="_blank" rel="external">iOS移动开发周报</a></li>
</ul>
<p>最开始由猿题库大神<a href="http://blog.devtang.com/" target="_blank" rel="external">唐巧</a>维护，唐大神维护了大概四十来期，后转交给喵神<a href="https://onevcat.com/" target="_blank" rel="external">王巍</a>维护，发布于<a href="http://www.infoq.com/cn/mobile-weekly/" target="_blank" rel="external">InfoQ</a>；该周报极大丰富了我的视野，感谢他们的付出！</p>
<ul>
<li><a href="http://nshipster.com/" target="_blank" rel="external">NSHipster</a></li>
</ul>
<p>国外的一个在iOS圈子非常知名的博客，AFNetworking的作者Mattt Thompson是该博客的作者之一，该网站分量可见一斑！</p>
<ul>
<li><a href="http://objccn.io/" target="_blank" rel="external">objc中国</a></li>
</ul>
<p>正如其口号：为中国Objective-C社区带来最佳实践和先进技术。它是国外著名网站iOS开发<a href="https://www.objc.io/" target="_blank" rel="external">objc</a>的中国版。其内容略微高深，若想成为高手，这个站点的内容应当全部消化掉。</p>
<h2 id="有意思的站点"><a href="#有意思的站点" class="headerlink" title="有意思的站点"></a>有意思的站点</h2><ul>
<li><a href="http://fuckingclangwarnings.com/" target="_blank" rel="external">Which Clang Warning Is Generating This Message?</a></li>
</ul>
<p>处理Objective-C警告时可能会用到。</p>
<ul>
<li><a href="http://fuckingblocksyntax.com/" target="_blank" rel="external">How Do I Declare A Block in Objective-C?</a></li>
</ul>
<p>忘记了block语法怎么办？这个网站会告诉你！</p>
<h2 id="好控件（增强、个性、炫酷）"><a href="#好控件（增强、个性、炫酷）" class="headerlink" title="好控件（增强、个性、炫酷）"></a>好控件（增强、个性、炫酷）</h2><ul>
<li><a href="https://github.com/gontovnik/DGRunkeeperSwitch" target="_blank" rel="external">DGRunkeeperSwitch</a></li>
</ul>
<p>非常漂亮的Segmented Control。</p>
<ul>
<li><a href="https://github.com/PavelKatunin/DownloadButton" target="_blank" rel="external">DownloadButton</a></li>
</ul>
<p>漂亮的下载button。</p>
<ul>
<li><a href="https://github.com/gmertk/ParkedTextField" target="_blank" rel="external">ParkedTextField</a></li>
</ul>
<p>固定后缀的文本框控件。</p>
<ul>
<li><a href="https://github.com/ninjaprox/NVActivityIndicatorView" target="_blank" rel="external">NVActivityIndicatorView</a></li>
</ul>
<p>豪华漂亮的Activity Indicator View</p>
<ul>
<li><a href="https://github.com/entotsu/TKSubmitTransition" target="_blank" rel="external">TKSubmitTransition</a></li>
</ul>
<p>漂亮的提交按钮button。</p>
<h2 id="好ViewController"><a href="#好ViewController" class="headerlink" title="好ViewController"></a>好ViewController</h2><p>待续</p>
<h2 id="其他汇总"><a href="#其他汇总" class="headerlink" title="其他汇总"></a>其他汇总</h2><ul>
<li><a href="https://github.com/vsouza/awesome-ios" target="_blank" rel="external">Awesome iOS</a></li>
<li><a href="http://github.ibireme.com/github/list/ios/" target="_blank" rel="external">Github-iOS备忘</a></li>
<li><a href="https://github.com/iamdaiyuan/ios_top_1000" target="_blank" rel="external">iOS Top 1000</a></li>
<li><a href="https://github.com/Aufree/trip-to-iOS/blob/master/Top-100.md" target="_blank" rel="external">iOS Top 100</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Resources/">Resources</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-using-sublime-text-packages" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/08/using-sublime-text-packages/" class="article-date">
  	<time datetime="2015-10-08T14:13:04.000Z" itemprop="datePublished">2015-10-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/08/using-sublime-text-packages/">一些常用的Sublime Text插件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文旨在记录一些笔者曾经使用过的Sublime Text插件，记录插件的使用和配置，以免忘记。</p>
<ul>
<li><a href="https://github.com/jarod2d/sublime_valign" target="_blank" rel="external"><strong>valign</strong></a></li>
</ul>
<p>非常轻的一个插件，用于代码对齐，Xcode环境中也有一个类似的插件XAlign，使用非常简单：</p>
<ol>
<li>选中代码块；</li>
<li>触发<code>⌘⇧X</code>（Cmd+Shift+X）；</li>
</ol>
<p>但默认情况下，触发valign功能的快捷键是<code>ctrl+\\</code>，笔者已经习惯了XAlign的快捷键<code>⌘⇧X</code>，因此作了一些处理，即选中<code>Preferences</code> &gt; <code>Key Bindings - User</code>，然后添加一条记录，如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123; <span class="attr">"keys"</span>: [<span class="string">"command+shift+x"</span>], <span class="attr">"command"</span>: <span class="string">"valign"</span> &#125;,</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这便将触发valign的快捷键改为<code>⌘⇧X</code>。</p>
<ul>
<li><a href="https://github.com/buymeasoda/soda-theme" target="_blank" rel="external"><strong>Soda Theme</strong></a></li>
</ul>
<p>Soda Theme让Sublime Text的整体风格更符合Mac，但该theme只会变更整个程序的骨架风格，不会更改编辑区（譬如背景色及高亮显示）。编辑区的背景色及高亮显示是由color_scheme负责的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sublime-Text/">Sublime Text</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tools/">Tools</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Others/">Others</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-using-sublime-text" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/06/using-sublime-text/" class="article-date">
  	<time datetime="2015-10-06T09:34:30.000Z" itemprop="datePublished">2015-10-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/06/using-sublime-text/">使用Sublime Text</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Sublime Text是一款强大的代码编辑器，其强大体现在三个方面：</p>
<ol>
<li>丰富的快捷键组合</li>
<li>实用的插件</li>
<li>支持代码片段snippet</li>
</ol>
<blockquote>
<p>P.S: 其提供的插件API基于Python。</p>
</blockquote>
<p>为了叙述方便，下文将以「ST」代替「Sublime Text」。</p>
<p>接触Sublime Text由来已久，只是一直都是极轻量级使用（当成普通的文本编辑器），现在想挖掘其更深层次的功能，将一些东西记录下来，以免以后忘记了。本文所涉及的ST版本为Version 3，所参考的系统环境是Mac OS X。</p>
<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>ST的配置主要是通过修改配置文件来实现的。</p>
<p><strong>配置文件</strong></p>
<p>其主要配置文件有两个：<code>Settings - Default</code>和<code>Settings - User</code>，如下图：</p>
<div class="imagediv" style="width: 378px; height: 288px"></div>

<p>二者都以JSON格式记录配置信息，其中前者记录着ST的默认配置，禁止用户修改（强行修改也是可以的，在指定目录新建一个文件即可，但最好不要修改）；后者默认为空，允许用户修改。User配置文件的内容会覆盖Default的相应内容，所以只要修改User配置文件就好了。</p>
<p>配置文件的item有很多，每一项是什么含义，上网一搜就有不少解释，况且Default配置文件中的注释已经非常清晰了。如果你不知道写什么，可以从Default配置文件里拷贝相应的内容到User配置文件里，然后将参数的值修改为希望的样子。我的<code>Settings - User</code>配置如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"theme"</span>: <span class="string">"Soda Dark 3.sublime-theme"</span>,</div><div class="line">    <span class="attr">"color_scheme"</span>: <span class="string">"Packages/Color Scheme - Default/Zenburnesque.tmTheme"</span>,</div><div class="line">    <span class="attr">"highlight_line"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"save_on_focus_lost"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"scroll_past_end"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">"tab_size"</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">"translate_tabs_to_spaces"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"trim_trailing_white_space_on_save"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"wrap_width"</span>: <span class="number">90</span>,</div><div class="line">    <span class="attr">"soda_folder_icons"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"update_check"</span>: <span class="literal">false</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得一提的是，最后一项<code>&quot;update_check&quot;:false</code>并不能在<code>Settings - Default</code>中找到，但确实有效，其作用是「disable每次启动ST后自动检查更新」。</p>
<p><strong>theme和color_scheme</strong></p>
<p>我在<code>Settings - User</code>中将theme设置为「Soda Dark」，<a href="https://github.com/buymeasoda/soda-theme" target="_blank" rel="external">Soda Theme</a>让ST的整体风格更符合Mac，但该theme只会变更整个程序的骨架风格，不会更改编辑区（譬如背景色及高亮显示）。编辑区的背景色及高亮显示是由color_scheme负责的。</p>
<p>theme在ST中也以插件的形式存在，简单来说，设置theme的步骤是：</p>
<ol>
<li>下载安装theme package；</li>
<li>配置<code>Settings - User</code>，配置theme这个item；</li>
</ol>
<p>那么color_scheme是如何设置的呢？</p>
<p>和theme不同，ST的color scheme不是以插件的形式安装的，支持ST的color scheme一般都对应一个.tmTheme文件，github中能找到很多此类color theme配色方案文件，弄一个心仪的下来添加到ST中即可。问题是拷贝到哪里呢？在网上看到很多博客的说法是「只需要将相应的文件放在Packages/Color Scheme - Default/目录下就行」。但事实上，在Mac环境下我找不到所谓的<code>Color Scheme - Default/</code>目录，对于ST Version 3而言，倒是能够在与<code>Packages/</code>同级目录<code>Cache/</code>中找到名为<code>Color Scheme - Default/</code>的目录…</p>
<p>P.S：如何快速找到<code>Packages/</code>目录呢？点击<code>Preferences</code> &gt; <code>Browse Packages…</code>菜单，所进入的目录即<code>Packages/</code>目录。</p>
<p>总之，最后，我的处理策略是：</p>
<ol>
<li>在<code>Packages/</code>目录下新建一个<code>Color Scheme - User/</code>目录；</li>
<li>将下载的.tmTheme文件拷贝到该目录中（以Flatland Dark.tmTheme为例）；</li>
<li>然后修改<code>Settings - User</code>配置文件中的color_scheme，设置其值为”Packages/Color Scheme - User/Flatland Dark.tmTheme”；</li>
</ol>
<p>立马生效，且在<code>Preferences</code> &gt; <code>Color Scheme</code>中看到多了一个<code>Color Scheme - User</code>选项，如下：</p>
<div class="imagediv" style="width: 741px; height: 326px"></div>

<p>如此这般，我们便可以通过UI选项卡选择color scheme了，当然，也可以在<code>Settings - User</code>中配置color_scheme。</p>
<p><strong>设置Tab</strong></p>
<p>代码迁移中最频繁的问题是处理Tab和Spacing；比较好的习惯是在编辑代码时，使用数个空格代替Tab。</p>
<p>上文在<code>Settings - User</code>中设置了两个与Tab相关的item：translate_tabs_to_spaces和tab_size。前者设置为True是为了让编辑器自动将Tab输入处理成空格，后者用于指示「一个Tab等于多少个Spacing」。</p>
<p>当然，除了配置<code>Settings - User</code>之外，也可以通过选项卡设置，如下：</p>
<div class="imagediv" style="width: 518px; height: 557px"></div>


<p><code>Settings - User</code>可配置的内容有很多，上文只是列出了其中几个于我而言比较通用的配置。</p>
<h2 id="使用Package-Control管理插件"><a href="#使用Package-Control管理插件" class="headerlink" title="使用Package Control管理插件"></a>使用Package Control管理插件</h2><p>ST中所谓的「插件」，其专业说法是「Package」。</p>
<p>ST之所以强大的一个重要原因是其具备强大的插件系统，像很多其他的集成环境或开发平台一样，ST中也有一个管理插件的插件，名为「Package Control」，Package Control的<a href="https://packagecontrol.io/" target="_blank" rel="external">官方</a>描述如下：</p>
<blockquote>
<p>The Sublime Text package manager that makes it exceedingly simple to find, install and keep packages up-to-date.</p>
</blockquote>
<p><strong>安装Package Control</strong></p>
<p>对于Package Control的安装，官网中有比较详细的安装<a href="https://packagecontrol.io/installation" target="_blank" rel="external">说明</a>，自动安装常常出错，我比较倾向手动安装，手动安装Package Control步骤如下：</p>
<ol>
<li>点击<code>Preferences</code> &gt; <code>Browse Packages…</code>菜单；</li>
<li>跳入上一级目录，进入<code>Installed Packages/</code>目录；</li>
<li>下载<a href="https://packagecontrol.io/Package%20Control.sublime-package" target="_blank" rel="external">Package Control.sublime-package</a>，将之拷贝到<code>Installed Packages/</code>目录；</li>
<li>重启Sublime Text；</li>
</ol>
<p>P.S：这里提到的<code>Installed Packages/</code>目录和上文的<code>Packages/</code>目录是平级关系，手动安装的插件一般都放到该目录中。</p>
<p>在初步使用Package Control的过程中，笔者自然而然产生了一些疑虑：</p>
<ul>
<li>如何更新Package Control？</li>
<li>如何查看通过Package Control下载的Package？</li>
<li>如何remove通过Package Control？</li>
<li>如何更新通过Package Control安装的Package？</li>
</ul>
<p>以上文提到的Soda Theme为例，通过Package Control安装Soda Theme的步骤如下：</p>
<ol>
<li>触发<code>Cmd+Shift+P</code>，激活命令框，输入「Package Control: Install Package」（或者干脆「pcinstall」）命令；</li>
<li>等待片刻（加载Package List，ST的底部状态栏可看到加载状态）后，输入SoDa过滤得到Soda Theme Package，点击后即会自动安装（ST的底部状态栏可看到安装状态）；</li>
</ol>
<p>安装完成后可在<code>Installed Packages/</code>目录下看到<code>Theme - Soda.sublime-package</code>文件，即安装的package文件。</p>
<p>到此为止，「更新插件」「移除插件」等操作就比较容易理解了。</p>
<p>ST的插件实在太丰富，Package Control官网的<a href="https://packagecontrol.io/browse/popular" target="_blank" rel="external">流行插件页面</a>能够看到更详细的插件列表。插件相关的使用以后单辟博客介绍。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>熟练使用ST有两大关键，除了熟练使用合适的插件之外，还得灵活使用ST快捷键。</p>
<p>ST原生自带的快捷键也能很大程度上方便开发，这里以Mac为主，Windows多数与其相似。下文中的会用一些特殊字符表示Mac环境下的一些按键，对应关系如下：</p>
<ul>
<li><code>⌘</code>Command key</li>
<li><code>⌃</code>Control key</li>
<li><code>⌥</code>Option key</li>
<li><code>⇧</code>Shift Key</li>
</ul>
<p>为了方便记忆，将快捷键分成了8个类型，分别为：</p>
<ul>
<li>Edit（编辑）</li>
<li>Selection（光标选中）</li>
<li>Find（查找）</li>
<li>View（视图）</li>
<li>Go to（跳转）</li>
<li>Project（工程）</li>
<li>General（通用）</li>
<li>Tabs（标签）</li>
</ul>
<h3 id="Edit快捷键"><a href="#Edit快捷键" class="headerlink" title="Edit快捷键"></a>Edit快捷键</h3><ul>
<li><code>⌘[</code>向左缩进</li>
<li><code>⌘]</code>向右缩进</li>
<li><code>⌘⌃↑</code>与上一行互换</li>
<li><code>⌘⌃↓</code>与下一行互换</li>
<li><code>⌘⇧D</code>复制粘贴当前选中内容（如果没有选中内容，则复制粘贴当前行）</li>
<li><code>⌘J</code>拼接当前行和下一行</li>
<li><code>⌘←</code>去往行的开头</li>
<li><code>⌘→</code>去往行的结尾</li>
<li><code>⌃K</code>从光标开始的地方删除到行尾</li>
<li><code>⌃⇧K</code>删除一整行</li>
<li><code>⌘⇧⏎</code>向光标前插入一行</li>
<li><code>⌘⏎</code>向光标后插入一行</li>
<li><code>⌘⌥T</code>插入特殊字符</li>
<li><p><code>⌃D</code>向后删除</p>
</li>
<li><p><code>⌘D</code>选中相同的词</p>
</li>
<li><code>⌘L</code>选中一行（没按一下选一行）</li>
<li><code>⌃⇧↑</code>一行一行向上选中</li>
<li><code>⌃⇧↓</code>一行一行向下选中</li>
</ul>
<h3 id="Find快捷键"><a href="#Find快捷键" class="headerlink" title="Find快捷键"></a>Find快捷键</h3><ul>
<li><code>⌘F</code>普通查找</li>
<li><code>⌘G</code>查找下一个</li>
<li><code>⌘⇧F</code>在文件夹中查找</li>
</ul>
<h3 id="View快捷键"><a href="#View快捷键" class="headerlink" title="View快捷键"></a>View快捷键</h3><ul>
<li>推荐使用Origami插件，可以随意对sublime进行分割</li>
</ul>
<h3 id="Go-to快捷键"><a href="#Go-to快捷键" class="headerlink" title="Go to快捷键"></a>Go to快捷键</h3><ul>
<li><code>⌘P</code>跳转文件</li>
<li><code>⌘R</code>定位文件中的方法（对于markdown，可以定义「标题」）</li>
<li><code>^G</code>定位文件中的行号</li>
<li><code>⌘⌥→</code>下一个打开的文件</li>
</ul>
<h3 id="Project快捷键"><a href="#Project快捷键" class="headerlink" title="Project快捷键"></a>Project快捷键</h3><ul>
<li><code>⌘⌃P</code>在保存过的工程中切换</li>
</ul>
<h3 id="General快捷键"><a href="#General快捷键" class="headerlink" title="General快捷键"></a>General快捷键</h3><ul>
<li><code>⌘⇧P</code>打开命令行</li>
<li><code>⌘K</code>/<code>⌘B</code>隐藏/打开侧边栏</li>
</ul>
<h3 id="Tab快捷键"><a href="#Tab快捷键" class="headerlink" title="Tab快捷键"></a>Tab快捷键</h3><ul>
<li><code>⌘⇧T</code>打开最后一次关闭的文件</li>
<li><code>^Tab</code>循环遍历Tab</li>
<li><code>^⇧Tab</code>反方向循环遍历Tab</li>
</ul>
<h2 id="ST的高级配置"><a href="#ST的高级配置" class="headerlink" title="ST的高级配置"></a>ST的高级配置</h2><p><strong>在终端中使用ST打开/创建文件</strong></p>
<p>很简单，使用ln命令创建一个软链接即可：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -sf /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/<span class="built_in">local</span>/bin/subl</div></pre></td></tr></table></figure></p>
<p>之后便可在终端中基于subl命令，使用ST创建或打开文件。</p>
<p><strong>修改ST图标</strong></p>
<p>ST的图标太丑了，网上有许多方法修改ST图标的博客，譬如<a href="http://davidwalsh.name/mac-app-icons" target="_blank" rel="external">这篇</a>，但是都无效。希望以后能解决这个问题。</p>
<p><strong>ST和Alfred配合使</strong><br>引入alfred workflow即可，详见<a href="https://github.com/franzheidl/alfred-workflows/tree/master/open-with-sublime-text" target="_blank" rel="external">这里</a>。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="http://www.zhihu.com/question/24896283" target="_blank" rel="external">知乎：Sublime Text 有哪些使用技巧？</a></li>
<li><a href="http://www.zhihu.com/question/24736400" target="_blank" rel="external">知乎：Sublime Text 3插件推荐？</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sublime-Text/">Sublime Text</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tools/">Tools</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Others/">Others</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>