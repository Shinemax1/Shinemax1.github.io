<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/6/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.67px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 15px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 18.33px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.67px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 20px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 13.33px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 16.67px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.67px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/Transition/" style="font-size: 13.33px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 13.33px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js基础/" style="font-size: 20px;">js基础</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，Android开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-navigation-transitions-in-ios" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/11/navigation-transitions-in-ios/" class="article-date">
  	<time datetime="2016-06-11T02:30:03.000Z" itemprop="datePublished">2016-06-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/11/navigation-transitions-in-ios/">Navigation Transition</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="../modal-transitions-in-ios/">Modal Transition概述</a>对自定义transition进行了简单概述，<a href="../using-uipercentdriveninteractivetransition">Using UIPercentDrivenInteractiveTransition</a>介绍了可交互转场的基本实现思路。本文旨在总结实现<strong>自定义navigation转场</strong>的基本套路。</p>
<p>此外，还对自己写的相关demo做一个汇总。</p>
<h2 id="Basic-Methods-Of-Custom-Navigation-Transition"><a href="#Basic-Methods-Of-Custom-Navigation-Transition" class="headerlink" title="Basic Methods Of Custom Navigation Transition"></a>Basic Methods Of Custom Navigation Transition</h2><p>在<code>UINavigationController</code>的基础上实现自定义custom navigation transition，只需要让自定义view controller遵循<code>UINavigationControllerDelegate</code>协议，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewController</span>: <span class="title">UIViewController</span>, <span class="title">UINavigationControllerDelegate</span> </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    navigationController?.delegate = <span class="keyword">self</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认情况下，<code>UINavigationController#delegate</code>为<code>nil</code>，此时push和pop动画全部采用系统默认transition。</p>
<p><code>UINavigationControllerDelegate</code>定义了6个方法，与transition直接相关的有两个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为push和pop操作提供animation controller</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(navigationController: UINavigationController,</span></span></div><div class="line">  animationControllerForOperation operation: UINavigationControllerOperation,</div><div class="line">  fromViewController fromVC: UIViewController,</div><div class="line">  toViewController toVC: UIViewController)</div><div class="line">  -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>?</div><div class="line"></div><div class="line"><span class="comment">// 为push和pop操作提供interaction controller</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(</span></span></div><div class="line">  navigationController: UINavigationController,</div><div class="line">  interactionControllerForAnimationController animationController: UIViewControllerAnimatedTransitioning)</div><div class="line">  -&gt; <span class="type">UIViewControllerInteractiveTransitioning</span>?</div></pre></td></tr></table></figure>
<p>站在这两个方法的角度来看，<code>UINavigationControllerDelegate</code>有点类似于<code>UIViewControllerTransitioningDelegate</code>，后者为transition动画提供animation controller和interaction controller，前者的作用也类似。</p>
<h2 id="Some-Demos"><a href="#Some-Demos" class="headerlink" title="Some Demos"></a>Some Demos</h2><p><strong>可交互的简单push/pop实现 – 仿知乎</strong></p>
<!-- <div class="imagediv" style="width: 320px; height: 566px"></div> –&gt;
<p><img src="/navigation-transitions-in-ios/BasicInteractiveCustomNavigationTransitionDemo.gif" alt="ssss"></p>
<p>代码详见<a href="https://github.com/sadjason/BasicInteractiveCustomNavigationTransitionDemo">这里</a>。</p>
<p>如下是一些不错的开源custom navigation transition实现：</p>
<ul>
<li><a href="https://github.com/recruit-mp/RMPZoomTransitionAnimator">RMPZoomTransitionAnimator</a></li>
<li><a href="https://github.com/DenHeadless/ZoomInteractiveTransition">ZoomInteractiveTransition</a></li>
<li><a href="https://github.com/NewAmsterdamLabs/ZOZolaZoomTransition">ZOZolaZoomTransition</a></li>
<li><a href="https://github.com/hebertialmeida/HAPaperViewController">HAPaperViewController</a></li>
<li><a href="https://github.com/boycechang/BCMagicTransition">BCMagicTransition</a></li>
<li><a href="https://github.com/JakeLin/IBAnimatable">IBAnimatable</a></li>
</ul>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="http://stackoverflow.com/questions/26569488/navigation-controller-custom-transition-animation">Navigation Controller Custom Transition Animation</a></li>
</ul>
-->
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Transition/">Transition</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-using-uipercentdriveninteractivetransition" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/10/using-uipercentdriveninteractivetransition/" class="article-date">
  	<time datetime="2016-06-10T09:06:55.000Z" itemprop="datePublished">2016-06-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/10/using-uipercentdriveninteractivetransition/">使用UIPercentDrivenInteractiveTransition</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>实现可交互的自定义转场动画的关键在于：定义遵循<code>UIViewControllerInteractiveTransitioning</code>协议的类。</p>
<p><code>UIViewControllerInteractiveTransitioning</code>协议的内容如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">UIViewControllerInteractiveTransitioning</span> : <span class="title">NSObjectProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">startInteractiveTransition</span><span class="params">(transitionContext: UIViewControllerContextTransitioning)</span></span></div><div class="line">    </div><div class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">completionSpeed</span><span class="params">()</span></span> -&gt; <span class="type">CGFloat</span></div><div class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">completionCurve</span><span class="params">()</span></span> -&gt; <span class="type">UIViewAnimationCurve</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到现在我都没搞明白如何定义遵循<code>UIViewControllerInteractiveTransitioning</code>的类。</p>
<p>但正如Apple<a href="https://developer.apple.com/library/prerelease/content/featuredarticles/ViewControllerPGforiPhoneOS/CustomizingtheTransitionAnimations.html" target="_blank" rel="external">文档</a>所言：</p>
<blockquote>
<p>The easiest way to make your animations interactive is to use a <code>UIPercentDrivenInteractiveTransition</code> object.</p>
</blockquote>
<p>简单来说，创建遵循<code>UIViewControllerInteractiveTransitioning</code>协议的类型的最简单方式是继承<code>UIPercentDrivenInteractiveTransition</code>类。</p>
<p>这是一个遵循<code>UIViewControllerInteractiveTransitioning</code>协议的类，为我们预先实现和提供了一系列便利的方法，可以用一个百分比来控制交互式切换的过程。</p>
<p>该类的内容及介绍如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIPercentDrivenInteractiveTransition</span> : <span class="title">NSObject</span>, <span class="title">UIViewControllerInteractiveTransitioning</span> </span>&#123;</div><div class="line">    </div><div class="line">  <span class="comment">// 只读，对应的是animation controller的transitionDuration(_:)返回值</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">var</span> duration: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    </div><div class="line">  <span class="comment">// 交互动画完成度（百分比），updateInteractiveTransition(_:)会改变该值</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">var</span> percentComplete: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    </div><div class="line">  <span class="comment">// 影响completion animation duration，一般设置为1.0（默认值），</span></div><div class="line">  <span class="comment">// 对应的completion animation duration为(1 - percentComplete)*duration.</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">var</span> completionSpeed: <span class="type">CGFloat</span></div><div class="line">    </div><div class="line">  <span class="comment">// completion animation的timing curve，默认是.EaseInOut</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">var</span> completionCurve: <span class="type">UIViewAnimationCurve</span></div><div class="line"></div><div class="line">  <span class="comment">/* 这三个方法在gesture recognizer的处理逻辑中调用 */</span></div><div class="line">  <span class="comment">// 更新百分比，一般通过手势识别的长度之类的来计算一个值，然后进行更新</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">updateInteractiveTransition</span><span class="params">(percentComplete: CGFloat)</span></span></div><div class="line">  <span class="comment">// 报告交互取消，返回切换前的状态</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">cancelInteractiveTransition</span><span class="params">()</span></span></div><div class="line">  <span class="comment">// 报告交互完成，更新到切换后的状态</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">finishInteractiveTransition</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>UIPercentDrivenInteractiveTransition</code>的内容并不复杂，使用时需要注意的是，interaction controller不能孤立存在，需要配合animation controller工作；换句话说，具体的transition仍然在animation controller的<code>animateTransition(_:)</code>中完成。</p>
<p>此外，在定义animation controller的<code>animateTransition(_:)</code>方法时，不要忘记调用<code>UIViewControllerContextTransitioning</code>的<code>completeTransition(_:)</code>方法。</p>
<blockquote>
<p>P.S: 根据我的理解并验证，<code>UIViewControllerContextTransitioning#completeTransition(true)</code>的作用效果之一是将from view从container view中移除掉。</p>
</blockquote>
<p>基于<code>UIPercentDrivenInteractiveTransition</code>做了个简单的Demo，如下图：</p>
<div class="imagediv" style="width: 320px; height: 568px"></div>

<p>代码详见<a href="https://github.com/sadjason/ShrinkingModalInteractiveTransitionDemo" target="_blank" rel="external">Github</a>。</p>
<p><code>UIViewControllerTransitioning.h</code>中对<code>UIPercentDrivenInteractiveTransition</code>有一段说明，不是特别理解：</p>
<blockquote>
<p>This style of interaction controller should only be used with an animator that implements a CA style transition in the animator’s animateTransition: method.</p>
</blockquote>
<p>掌握使用<code>UIPercentDrivenInteractiveTransition</code>并不难，但是该类有哪些限制（或缺陷）呢？我有该如何抛开该类自定义实现interaction controller呢？</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://onevcat.com/2013/10/vc-transition-in-ios7/" target="_blank" rel="external">WWDC 2013 Session笔记 - iOS7中的ViewController切换</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerInteractiveTransitioning_protocol/" target="_blank" rel="external">UIViewControllerInteractiveTransitioning Protocol Reference</a></li>
<li><a href="http://initwithfunk.com/blog/2014/05/22/interactive-animated-transitions-on-ios/" target="_blank" rel="external">Interactive Animated Transitions on iOS</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Transition/">Transition</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-modal-transitions-in-ios" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/09/modal-transitions-in-ios/" class="article-date">
  	<time datetime="2016-06-09T11:43:39.000Z" itemprop="datePublished">2016-06-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/09/modal-transitions-in-ios/">Modal Transition</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文旨在分析modal transition自定义过场动画的实现过程，总结一些基本套路。</p>
<p>视图控制器的转场动画涉及几大组件：</p>
<ol>
<li><strong>转场上下文</strong>（transition context）</li>
<li><strong>转场代理</strong>（transitioning delegation）</li>
<li><strong>动画控制器</strong>（animation controller）</li>
<li><strong>交互控制器</strong>（interaction controller）</li>
<li><strong>转场协调器</strong>（transition coordination）</li>
<li><strong>呈现控制器</strong>（presentation controller）</li>
</ol>
<p>其中前5个是iOS 7中引入的，都以<strong>协议</strong>的形式定义，利用这5个接口可以实现丰富转场动画（不光是modal transition），详细内容参考<a href="../viewcontroller-transitions-basics/">iOS转场动画概述</a>；第6个是Apple在iOS 8中引入的，以类（<code>UIPresentationController</code>）的形式定义，在modal transition中可能会用到。</p>
<p>下文若涉及如上这些概念，均以对应的英文代指。</p>
<p>在iOS中，modal transition涉及两个控制器：presenting view controller和presented view controller。transition结束后，后者盖在前者上面。</p>
<p>过场动画说到底是对view的动画处理，根据我的分析，相关的view包括：key window、presenting controller’s view、container view、presented controller’s view，完成transition后，它们的层次结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">|--key window</div><div class="line">   |--presenting controller&apos;s view</div><div class="line">   |--container view</div><div class="line">      |--presented controller&apos;s view</div><div class="line"></div><div class="line"># 说明：</div><div class="line"># a. 此处presenting view controller是keyWindow的rootViewController；</div><div class="line"># b. container view并不一定是presented controller&apos;s view的super view，但一定是它的ancestor view；</div></pre></td></tr></table></figure>
<p>为叙述简单起见，下文中的<strong>presented view</strong>等价于上述的<strong>presented controller’s view</strong>，<strong>presenting view</strong>则等价于<strong>presenting controller’s view</strong>。</p>
<p>如上的层次结构是我通过阅读文档和测试得出的结论，可以看出，presenting view和presented view并没有包含关系。container view是什么呢？在transition过程中，系统先创建一个临时的view，把它纳入到key window的层次结构中，然后将presented view加入到container view中。</p>
<p>对于modal transition，一般来说，container view是系统产生的。</p>
<blockquote>
<p>P.S: 根据我的认知，貌似只有在自定义容器控制器时，才需要指定container view。</p>
</blockquote>
<h2 id="简单的自定义Modal过场动画"><a href="#简单的自定义Modal过场动画" class="headerlink" title="简单的自定义Modal过场动画"></a>简单的自定义Modal过场动画</h2><p>把相关的view层次关系理清，实现简单的自定义过场动画就不难了，先来一个最简单的：presented view渐进显示（alpha从0.0到1.0），效果如下：</p>
<div class="imagediv" style="width: 320px; height: 568px"></div>

<p>上述demo中涉及两个view controller，本文将它们对应的类命名为：PresentingViewController和PresentedViewController。</p>
<p>从PresentingViewController过渡到PresentedViewController非常容易，一行代码解决：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">presentViewController(<span class="type">PresentedViewController</span>(), animated: <span class="literal">true</span>)</div></pre></td></tr></table></figure>
<p>默认情况下，PresentedViewController会从底部升起，现在想让它执行自定义动画（alpha从0.0到1.0），需要对PresentedViewController稍作处理，首先是设置其modal style为Custom，并指定其过场动画的代理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PresentedViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> presenter: <span class="type">UIViewControllerTransitioningDelegate</span>?</div><div class="line">  <span class="keyword">init</span>() &#123;</div><div class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</div><div class="line">    commonSetup()</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</div><div class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</div><div class="line">    commonSetup()</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">commonSetup</span><span class="params">()</span></span> &#123;</div><div class="line">    modalPresentationStyle = .<span class="type">Custom</span></div><div class="line">    presenter = <span class="type">SimpleModalPresenter</span>()</div><div class="line">    transitioningDelegate = presenter</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>modalPresentationStyle=.Custom</code>告诉系统自定义过场处理，而<code>transitioningDelegate</code>属性指定transitioning delegation，值得一提的是，<code>transitioningDelegate</code>属性被<code>weak</code>修饰，不强持有所指向的资源，故而<code>commonSetup()</code>不能写成如下这样（曾在这里栽过跟头）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">commonSetup</span><span class="params">()</span></span> &#123;</div><div class="line">  modalPresentationStyle = .<span class="type">Custom</span></div><div class="line">  transitioningDelegate = <span class="type">SimpleModalPresenter</span>()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目前为止（当前最新版本为iOS 9），transitioning delegation有5个可选回调，作用有三个：</p>
<ul>
<li>提供animation controllers（遵循<code>UIViewControllerAnimatedTransitioning</code>协议的对象）；</li>
<li>提供interaction controllers（遵循<code>UIViewControllerInteractiveTransitioning</code>协议的对象）；</li>
<li>提供presentation controller（<code>UIPresentationController</code>对象）；</li>
</ul>
<p><code>SimpleModalPresenter</code>的实现非常简单，实现两个回调，分别为presentation transition和dismissal transition提供animation controller（暂时不考虑交互，因此略过interaction controller，<code>UIPresentationController</code>下文会提到）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleModalPresenter</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerTransitioningDelegate</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="comment">// 非交互动画</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animationControllerForPresentedController</span><span class="params">(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? &#123;</div><div class="line">    <span class="keyword">let</span> animator = <span class="type">SimpleModalAnimator</span>()</div><div class="line">    animator.isPresentation = <span class="literal">true</span></div><div class="line">    <span class="keyword">return</span> animator</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animationControllerForDismissedController</span><span class="params">(dismissed: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? &#123;</div><div class="line">    <span class="keyword">let</span> animator = <span class="type">SimpleModalAnimator</span>()</div><div class="line">    animator.isPresentation = <span class="literal">false</span></div><div class="line">    <span class="keyword">return</span> animator</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Animation controller的实现也非常简单，无非是利用系统提供transition context信息进行简单的动画处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleModalAnimator</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> isPresentation: <span class="type">Bool</span> = <span class="literal">false</span></div><div class="line">  </div><div class="line">  <span class="comment">// 定义过场动画时间，其他地方可能会用到这个</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">NSTimeInterval</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1.0</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 过场动画的具体执行</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> containerView = transitionContext.containerView()</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> presentedView: <span class="type">UIView</span>?</div><div class="line">    <span class="keyword">if</span> isPresentation &#123;</div><div class="line">      presentedView = transitionContext.viewForKey(<span class="type">UITransitionContextToViewKey</span>)</div><div class="line">      presentedView?.frame = (containerView?.bounds)!</div><div class="line">      presentedView?.alpha = <span class="number">0.0</span></div><div class="line">      containerView?.addSubview(presentedView!)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      presentedView = transitionContext.viewForKey(<span class="type">UITransitionContextFromViewKey</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="type">UIView</span>.animateWithDuration(transitionDuration(transitionContext), animations: &#123;</div><div class="line">      presentedView?.alpha = <span class="keyword">self</span>.isPresentation ? <span class="number">1.0</span> : <span class="number">0.0</span></div><div class="line">      &#125;) &#123; (finished) <span class="keyword">in</span></div><div class="line">        transitionContext.completeTransition(finished)</div><div class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.isPresentation &#123;</div><div class="line">          presentedView?.removeFromSuperview()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SimpleModalAnimator</code>将presentation和dismissal二合一，定义<code>isPresentation</code>属性以便区分。</p>
<p>综上，实现简单的modal transition只需要三个步骤：</p>
<ol>
<li>在presented view controller中指定modal style和transition delegate；</li>
<li>实现transition delegate，即定义遵循<code>UIViewControllerTransitioningDelegate</code>协议的类，transition delegate为presented view controller提供animation controllers；</li>
<li>实现animation controllers，即定义遵循<code>UIViewControllerAnimatedTransitioning</code>协议的类，animation controller利用系统所提供的transition context信息，处理一些简单的view animation。</li>
</ol>
<h2 id="UIPresentationController"><a href="#UIPresentationController" class="headerlink" title="UIPresentationController"></a>UIPresentationController</h2><p>Presentation controller是iOS 8引入的新概念，能够帮助我们更方便快捷地实现view controller的自定义过渡效果，与animation controller等不同，它不是以协议的方式定义，而是定义了一个名为<code>UIPresentationController</code>的类。</p>
<blockquote>
<p>P.S: 很好奇为什么不把presentation controller也定义成protocol。</p>
</blockquote>
<p>简单来说，presentation controller和animation controller有些类似，它们都不是视图控制器，没有<code>view</code>属性，都拥有container view、presented view等访问权，都由transitioning delegation提供；presentation controller的主要使命是提供一些回调，系统在presentation transition的开始/结束、dismissal transition的开始/结束会调用这些回调，有点类似视图控制器的<code>viewWillAppear(_:)</code>、<code>viewDidAppear(_:)</code>，常用的回调如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// presentation transition</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentationTransitionWillBegin</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentationTransitionDidEnd</span><span class="params">(completed: Bool)</span></span></div><div class="line"><span class="comment">// dismissal transition</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismissalTransitionWillBegin</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismissalTransitionDidEnd</span><span class="params">(completed: Bool)</span></span></div><div class="line"></div><div class="line"><span class="comment">/* Position of the presented view in the container view </span></div><div class="line"> * by the end of the presentation transition.</div><div class="line"> * (Default: container view bounds)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">frameOfPresentedViewInContainerView</span><span class="params">()</span></span> -&gt; <span class="type">CGRect</span></div><div class="line"></div><div class="line"><span class="comment">/* Indicate whether the view controller's view we are transitioning from </span></div><div class="line"> * will be removed from the window in the end of the presentation transition</div><div class="line"> * (Default: NO)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldRemovePresentersView</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></div></pre></td></tr></table></figure>
<p>可以看到，相较于animation controller，presentation controller所涉及的过场讯息更加精细。</p>
<blockquote>
<p>Note: <code>UIPresentationController</code>实例的初始化不能使用<code>init()</code>，必须要使用<code>init(presentedViewController:presentingViewController:)</code>。</p>
</blockquote>
<p>刚开始接触presentation controller时有些疑点：</p>
<ul>
<li>Presentation controller一定要配合animation controller使用？可以单独使用吗？</li>
<li>Presentation controller和animation controller都可以访问container view和presented view，都能处理过场动画，如何让它们俩协调工作？</li>
</ul>
<p>首先，presentation controller是可以单独使用的！也就是说，transitioning delegation可以只提供presentation controller，而不提供animation controller，如下这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 转场代理只提供presentation controller</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleModalPresenter</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerTransitioningDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">presentationControllerForPresentedViewController</span><span class="params">(presented: UIViewController, presentingViewController presenting: UIViewController, sourceViewController source: UIViewController)</span></span> -&gt; <span class="type">UIPresentationController</span>? &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">SimplePresentationController</span>(presentedViewController: presented, presentingViewController: presenting)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StackOverFlow中有一个简单的<a href="http://stackoverflow.com/questions/29219688/present-modal-view-controller-in-half-size-parent-controller/29220983#29220983" target="_blank" rel="external">用例</a>：让presented view占据屏幕的下半部分，而不是全屏。重载自定义presentation controller的<code>frameOfPresentedViewInContainerView() -&gt; CGRect</code>方法即可实现。</p>
<blockquote>
<p>Note: 当transitioning delegation同时提供自定义的animation controller和presentation controller时，presentation controller的<code>frameOfPresentedViewInContainerView() -&gt; CGRect</code>方法不管用了，不晓得什么原因，非常诡异！除了这种方式，还可以在animation controller的<code>animateTransition(_:)</code>设置presented view的<code>frame</code>。</p>
</blockquote>
<p>然后来分析presentation controller和animation controller如何协同工作。</p>
<p>如上文所述，二者拥有对presented view和container view的访问权…在我看来，它们所能做的事情有些重叠，modal呈现presented view controller的一个重要步骤是<code>containerView.addSubview(presentedView)</code>，这行代码在哪里执行呢？可以在animation controller的<code>animateTransition(_:)</code>方法中处理，也可以在presentation controller的回调<code>presentationTransitionWillBegin()</code>中处理。此外，presentation controller的很多用法是在container view和presented view中加入一层view（充当遮罩或者蒙板），比如<a href="http://www.cocoachina.com/industry/20140707/9053.html" target="_blank" rel="external">这样</a>；这种事情显然也可以在animation controller的<code>animateTransition(_:)</code>方法中完成。</p>
<p>总之，在我看来，presentation controller不是必要的，它所能做的事情，animation controller的<code>animateTransition(_:)</code>都能做，只是presentation controller把工作给简化了一些。</p>
<blockquote>
<p>Note: 把presentation controller看作是animation controller和interaction controller的扩展。</p>
</blockquote>
<p>个人感觉，presentation controller虽然简化了自定义modal transition的实现，但是让逻辑更复杂了，甚至更混乱了。</p>
<p>因此，有必要将presentation controller和animation controller的工作给分清楚。我是这么想的：presented view相关的设置与动画处理都放在animation controller中完成，而presentation view（一般是夹在container view和presented view之间的临时view）相关设置和处理都放在presentation controller中处理。</p>
<p>在presentation transition和dismissal transition过程中，animation controller的<code>animateTransition(_:)</code>和presentation controller的几个回调的执行顺序是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># presentation transition</div><div class="line">presentationTransitionWillBegin()</div><div class="line">animateTransition(_:)</div><div class="line">presentationTransitionDidEnd(_:)</div><div class="line"></div><div class="line"># dismissal transition</div><div class="line">dismissalTransitionWillBegin()</div><div class="line">animateTransition(_:)</div><div class="line">dismissalTransitionDidEnd(_:)</div></pre></td></tr></table></figure>
<h2 id="Presentation-Style"><a href="#Presentation-Style" class="headerlink" title="Presentation Style"></a>Presentation Style</h2><p><code>UIViewController</code>有个属性<code>modalPresentationStyle</code>，上文中用到了该属性，只是用得稀里糊涂，这一部分对它进行进一步说明。</p>
<p>Apple文档对<code>modalPresentationStyle</code>属性的解释如下：</p>
<blockquote>
<p>The presentation style determines how a modally presented view controller is displayed onscreen. In a horizontally compact environment, modal view controllers are always presented full-screen. In a horizontally regular environment, there are several different presentation options. For a list of possible presentation styles, and their compatibility with the available transition styles, see the <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/#//apple_ref/c/tdef/UIModalPresentationStyle" target="_blank" rel="external">UIModalPresentationStyle</a> constant descriptions.</p>
</blockquote>
<p>该属性是个枚举值，包括9个case，其中大多数都与iPad环境有关，这里只介绍iPhone开发环境中会常常涉及到的3个枚举值：</p>
<ul>
<li><code>.FullScreen</code> – A presentation style in which the presented view covers the screen. The views belonging to the presenting view controller are removed after the presentation completes.</li>
<li><code>.OverFullScreen</code> – A view presentation style in which the presented view covers the screen. The views beneath the presented content are not removed from the view hierarchy when the presentation finishes. So if the presented view controller does not fill the screen with opaque content, the underlying content shows through.</li>
<li><code>.Custom</code> – A custom view presentation style that is managed by a custom presentation controller and one or more custom animator objects. All of these objects are provided by the presented view controller’s transitioning delegate.</li>
</ul>
<p>简单来说，当<code>modalPresentationStyle</code>属性赋值<code>.FullScreen</code>或者<code>.OverFullScreen</code>时，transitioning delegation提供的自定义presentation controller就没什么卵用。换句话说，如果想使用自定义的presentation controller，必须对<code>modalPresentationStyle</code>属性赋值<code>.Custom</code>。</p>
<p>它们仨有啥不同呢？</p>
<p><code>.FullScreen</code>所对应的内置presentation controller，会在presentation transition结束时，将presenting view从key window的view hierarchy中移除掉。</p>
<p>而<code>.OverFullScreen</code>所对应的内置presentation controller，则不会在presentation transition结束时移除掉presenting view。</p>
<p>在<code>.Custom</code>模式下，不会使用任何一种系统内置presentation controller，它依赖于用户自定义presentation controller，即实现一个<code>UIPresentationController</code>子类，该子类有一个<code>shouldRemovePresentersView() -&gt; Bool</code>方法。单从对待presenting view的角度来看，当该方法返回<code>false</code>时，<code>.Custom</code>与<code>.OverFullScreen</code>一致，反之，当该方法返回<code>true</code>时，<code>.Custom</code>与<code>.FullScreen</code>一致。</p>
<p>我为什么会关注<code>modalPresentationStyle</code>属性呢？</p>
<p>这是因为我在animation controller的<code>animateTransition(_:)</code>方法中无法访问presenting view，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">  <span class="keyword">let</span> presentingView = transitionContext.viewForKey(<span class="type">UITransitionContextFromViewKey</span>)</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查了半天资料，发现这个<a href="http://stackoverflow.com/questions/24338700/from-view-controller-disappears-using-uiviewcontrollercontexttransitioning/25901154#25901154" target="_blank" rel="external">说法</a>比较靠谱。大概的意思是：</p>
<ul>
<li>如果在presentation transition结束时仍然将presenting view保留到key window中，iOS（iOS 8及以后版本）认为没有必要让你再操控presenting view，故而通过<code>viewForKey(UITransitionContextFromViewKey)</code>访问presenting view得到的结果为<code>nil</code>；</li>
<li>如果在presentation transition结束时将presenting view从key window中移除掉，iOS认为你可能需要在presentation transition过程中对presenting view做一个动画，故而通过<code>viewForKey(UITransitionContextFromViewKey)</code>能够访问到presenting view。</li>
</ul>
<p>UIKit的UIViewControllerTransitioning.h文件中也有对这种说法的佐证：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Currently only two keys are defined by the system -</span></div><div class="line"><span class="comment">// UITransitionContextFromViewKey, and UITransitionContextToViewKey</span></div><div class="line"><span class="comment">// viewForKey: may return nil which would indicate that the animator should not</span></div><div class="line"><span class="comment">// manipulate the associated view controller's view.</span></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">viewForKey</span><span class="params">(key: String)</span></span> -&gt; <span class="type">UIView</span>?</div></pre></td></tr></table></figure>
<p>对于这种做法，我的下意识是：What The Fuck!</p>
<p>当然，如果非要访问presenting view，除了通过<code>viewForKey(_:)</code>，还可以曲线救国：先通过<code>viewControllerForKey(_:)</code>访问presenting view controller，然后再访问view。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="http://www.cocoachina.com/industry/20140707/9053.html" target="_blank" rel="external">iOS 8的PresentationController</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIPresentationController_class/" target="_blank" rel="external">UIPresentationController Class Reference</a></li>
<li><a href="https://developer.apple.com/library/prerelease/content/featuredarticles/ViewControllerPGforiPhoneOS/CustomizingtheTransitionAnimations.html" target="_blank" rel="external">Customizing the Transition Animations</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Transition/">Transition</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-practice-in-uiscrollview" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/21/practice-in-uiscrollview/" class="article-date">
  	<time datetime="2016-05-21T05:41:28.000Z" itemprop="datePublished">2016-05-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/21/practice-in-uiscrollview/">使用UIScrollView</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="UIScrollViewDelegate"><a href="#UIScrollViewDelegate" class="headerlink" title="UIScrollViewDelegate"></a>UIScrollViewDelegate</h2><p>简单介绍一下UIScrollViewDelegate定义的一些方法，这里只涉及与scroll相关的方法，zoom相关的方法略过不表。</p>
<ul>
<li><code>scrollViewDidScroll(_:)</code></li>
</ul>
<p>这个方法在任何方式触发<code>contentOffset</code>变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控<code>contentOffset</code>的变化，并根据当前的<code>contentOffset</code>对其他view做出随动调整。</p>
<ul>
<li><code>scrollViewWillBeginDragging(_:)</code></li>
</ul>
<p>用户开始拖动scroll view的时候被调用。</p>
<ul>
<li><code>scrollViewWillEndDragging(_:withVelocity:targetContentOffset:)</code></li>
</ul>
<p>这个方法是iOS 5之后引入的，可在它的基础上实现更为丰富的自定义paging。</p>
<ul>
<li><code>scrollViewDidEndDragging(_:willDecelerate:)</code></li>
</ul>
<p>在用户结束拖动后被调用，<code>willDecelerate</code>为YES时，结束拖动后会有减速过程（惯性）。</p>
<ul>
<li><code>scrollViewWillBeginDecelerating(_:)</code></li>
</ul>
<p>减速动画开始前被调用。</p>
<ul>
<li><code>scrollViewDidEndDecelerating(_:)</code></li>
</ul>
<p>减速动画结束时被调用，这里有一种特殊情况：当一次减速动画尚未结束的时候再次drag scroll view，该方法不会被调用，并且这时scroll view的<code>dragging</code>和<code>decelerating</code>属性都是<code>YES</code>。新的dragging如果有加速度，那么<code>scrollViewWillBeginDecelerating(_:)</code>会再一次被调用，然后才是<code>scrollViewDidEndDecelerating(_:)</code>；如果没有加速度，虽然<code>scrollViewWillBeginDecelerating(_:)</code>不会被调用，但前一次留下的<code>scrollViewDidEndDecelerating(_:)</code>会被调用。</p>
<blockquote>
<p>P.S: 以上的解释比较拗口，动手体验一下就明白了。</p>
</blockquote>
<ul>
<li><code>scrollViewDidEndScrollingAnimation(_:)</code></li>
</ul>
<p>当通过代码滑动scroll view时（<code>setContentOffset(_:animated:)</code>或者<code>scrollRectVisible(_:animated:)</code>），动画结束时会调用该方法；值得一提的是，当且仅当动画存在时才会调用该方法。</p>
<h2 id="Scrolling-With-Finger"><a href="#Scrolling-With-Finger" class="headerlink" title="Scrolling With Finger"></a>Scrolling With Finger</h2><p>我总结了一些手指控制UIScrollView滑动的场景，将相关的回调给列出来了。</p>
<p><strong>场景一：一次正常的滑动-减速-停止</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 手指介入</span></div><div class="line">scrollViewWillBeginDragging(<span class="number">_</span>:)</div><div class="line"><span class="comment">// 开始滑动</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)                     <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)                     <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指离开屏幕（scrolling继续，并未停滞）</span></div><div class="line">scrollViewWillEndDragging(scrollView:withVelocity:targetContentOffset:)</div><div class="line">scrollViewDidEndDragging(<span class="number">_</span>:willDecelerate:) <span class="comment">// 拖拽结束（willDecelerate=true）</span></div><div class="line">scrollViewWillBeginDecelerating(<span class="number">_</span>:)         <span class="comment">// 减速</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)                     <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)                     <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">scrollViewDidEndDecelerating(<span class="number">_</span>:)            <span class="comment">// 减速结束</span></div></pre></td></tr></table></figure>
<p><strong>场景二：减速过程中的手指介入（点停）</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 手指介入</span></div><div class="line">scrollViewWillBeginDragging(<span class="number">_</span>:)</div><div class="line"><span class="comment">// 开始滑动</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指离开屏幕（scrolling继续，并未停滞）</span></div><div class="line">scrollViewWillEndDragging(scrollView:withVelocity:targetContentOffset:)</div><div class="line">scrollViewDidEndDragging(<span class="number">_</span>:willDecelerate:) <span class="comment">// 拖拽结束（willDecelerate=true）</span></div><div class="line">scrollViewWillBeginDecelerating(<span class="number">_</span>:)         <span class="comment">// 减速</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指介入（scrolling停止 -- 之前的操作被取消）</span></div><div class="line">scrollViewWillBeginDragging(<span class="number">_</span>:)</div><div class="line"><span class="comment">// 手指离开屏幕</span></div><div class="line">scrollViewWillEndDragging(scrollView:withVelocity:targetContentOffset:)</div><div class="line">scrollViewDidEndDragging(<span class="number">_</span>:willDecelerate:)     <span class="comment">// 拖拽结束（willDecelerate=false）</span></div><div class="line">scrollViewDidEndDecelerating(<span class="number">_</span>:)                <span class="comment">// 减速结束</span></div></pre></td></tr></table></figure>
<p><strong>场景三：减速过程中的手指介入（乱滑）</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 手指介入</span></div><div class="line">scrollViewWillBeginDragging(<span class="number">_</span>:)</div><div class="line"><span class="comment">// 开始滑动</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指离开屏幕（scrolling继续，并未停滞）</span></div><div class="line">scrollViewWillEndDragging(scrollView:withVelocity:targetContentOffset:)</div><div class="line">scrollViewDidEndDragging(<span class="number">_</span>:willDecelerate:) <span class="comment">// 拖拽结束（willDecelerate=true）</span></div><div class="line">scrollViewWillBeginDecelerating(<span class="number">_</span>:)         <span class="comment">// 减速</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指介入--重新拖拽（scrolling停止 -- 之前的操作被取消）</span></div><div class="line">scrollViewWillBeginDragging(<span class="number">_</span>:)</div><div class="line"><span class="comment">// 开始滑动</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指离开屏幕（scrolling继续，并未停滞）</span></div><div class="line">scrollViewWillEndDragging(scrollView:withVelocity:targetContentOffset:)</div><div class="line">scrollViewDidEndDragging(<span class="number">_</span>:willDecelerate:) <span class="comment">// 拖拽结束（willDecelerate=true）</span></div><div class="line">scrollViewWillBeginDecelerating(<span class="number">_</span>:)         <span class="comment">// 减速</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指介入--点停（scrolling停止 -- 之前的操作被取消）</span></div><div class="line">scrollViewWillBeginDragging(<span class="number">_</span>:)</div><div class="line"></div><div class="line"><span class="comment">// 手指离开屏幕</span></div><div class="line">scrollViewWillEndDragging(scrollView:withVelocity:targetContentOffset:)</div><div class="line">scrollViewDidEndDragging(<span class="number">_</span>:willDecelerate:)     <span class="comment">// 拖拽结束（willDecelerate=false）</span></div><div class="line">scrollViewDidEndDecelerating(<span class="number">_</span>:)                <span class="comment">// 减速结束</span></div></pre></td></tr></table></figure>
<h2 id="Scrolling-Programmatically"><a href="#Scrolling-Programmatically" class="headerlink" title="Scrolling Programmatically"></a>Scrolling Programmatically</h2><p><strong>Scrolling to a Specific Offset</strong></p>
<p>可通过设置content offset让scrollView滚动到某个指定位置，有两种方式：一是直接给<code>contentOffset</code>属性赋值，二是调用<code>setContentOffset(_:animated:)</code>方法。对于第二种，当<code>animated</code>参数设置为NO，等效于第一种方式。</p>
<p>无论是哪一种情况，<code>delegate</code>都会接收到<code>scrollViewDidScroll(_:)</code>消息。</p>
<p>只是当禁止动画时，<code>delegate</code>只会收到一次<code>scrollViewDidScroll(_:)</code>消息；当允许动画时，<code>delegate</code>会在动画过程中接收到一系列<code>scrollViewDidScroll(_:)</code>消息，并且当动画结束时，<code>delegate</code>还会接收到<code>scrollViewDidEndScrollingAnimation(_:)</code>消息。</p>
<p><strong>Making a rectangle visible</strong></p>
<p>还可以调用<code>scrollRectToVisible(_:animated:)</code>方法让scrollView滚动到一个合适的位置以使指定区域可见，<code>animated</code>参数依然是用来控制动画开关的。当关闭动画时，<code>delegate</code>会接收到一次<code>scrollViewDidScroll(_:)</code>消息；当允许动画时，<code>delegate</code>会在动画过程中接收到一系列<code>scrollViewDidScroll(_:)</code>消息，并且当动画结束时，<code>delegate</code>还会接收到<code>scrollViewDidEndScrollingAnimation(_:)</code>消息。</p>
<p><strong>Scroll To Top</strong></p>
<p><code>UITableView</code>等子类还实现了Scroll To Top功能，这里不赘述了，详细参考<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/UIScrollView_pg/ScrollingViewContent/ScrollingViewContent.html" target="_blank" rel="external">这里</a>。</p>
<h2 id="Tracking-The-Start-and-Completion-Of-A-Scroll-Action"><a href="#Tracking-The-Start-and-Completion-Of-A-Scroll-Action" class="headerlink" title="Tracking The Start and Completion Of A Scroll Action"></a>Tracking The Start and Completion Of A Scroll Action</h2><p>Implement the scrollViewWillBeginDragging: method to receive notification that dragging will begin.</p>
<p>当编程实现滚动（设置<code>contentOffset</code>、）时，<code>scrollViewWillBeginDragging:</code>也会被调用吗？</p>
<p>To determine when scrolling is complete you must implement two delegate methods: scrollViewDidEndDragging:willDecelerate: and scrollViewDidEndDecelerating:. Scrolling is completed either when the delegate receives the scrollViewDidEndDragging:willDecelerate: message with NO as the decelerate parameter, or when your delegate receives the scrollViewDidEndDecelerating: method. In either case, scrolling is complete.</p>
<p><strong>编程实现滚动时抗干扰</strong></p>
<p>在开始和结束时设置<code>userInteractionEnabled</code>属性即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">scrollView.userInteractionEnabled = <span class="literal">false</span></div><div class="line">scrollView.setContentOffset(<span class="type">CGPointZero</span>, animated: <span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndScrollingAnimation</span><span class="params">(scrollView: UIScrollView)</span></span> &#123;</div><div class="line">  scrollView.userInteractionEnabled = <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h2><p><strong>不可描述的问题</strong></p>
<p>一般来说，在UIScrollView静止状态下，点击（只是轻点一下）不会触发UIScrollViewDelegate相关的回调，但曾在开发中遇到了一件诡异的事情，点击静止状态下的UIScrollView会触发<code>scrollViewWillBeginDecelerating(_:)</code>和<code>scrollViewDidEndDecelerating(_:)</code>回调，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">  [<span class="keyword">super</span> viewDidLoad];</div><div class="line">  </div><div class="line">  <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">  </div><div class="line">  <span class="built_in">UIScrollView</span> *scrollView = [[<span class="built_in">UIScrollView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">30</span>, <span class="number">100</span>, <span class="number">200</span>)];</div><div class="line">  scrollView.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">  scrollView.bounces = <span class="literal">NO</span>;</div><div class="line">  scrollView.contentSize = <span class="built_in">CGSizeMake</span>(<span class="number">160</span>, <span class="number">200</span>);</div><div class="line">  scrollView.pagingEnabled = <span class="literal">YES</span>;</div><div class="line">  scrollView.showsHorizontalScrollIndicator = <span class="literal">NO</span>;</div><div class="line">  scrollView.delegate = <span class="keyword">self</span>;</div><div class="line">  </div><div class="line">  [<span class="keyword">self</span>.view addSubview:scrollView];</div><div class="line">  </div><div class="line">  <span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">60</span>, <span class="number">200</span>)];</div><div class="line">  view1.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">  [scrollView addSubview:view1];</div><div class="line">  </div><div class="line">  <span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">60</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>)];</div><div class="line">  view2.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</div><div class="line">  [scrollView addSubview:view2];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>排查了好久，最终发现问题出在<code>scrollView.pagingEnabled = YES</code>这里，以上的scroll view允许paging，然而，其<code>contentSize.width</code>并不是<code>size.width</code>的整数倍，这会让它显式最后一页时没办法达到稳定状态，该情况下点击UIScrollView会触发<code>scrollViewWillBeginDecelerating(_:)</code>和<code>scrollViewDidEndDecelerating(_:)</code>。该情景不太容易描述…</p>
<p><strong>UIScrollView Custom Paging</strong></p>
<p>通过回调<code>scrollViewWillEndDragging(_:withVelocity:targetContentOffset:)</code>可以在<code>UIScrollView#pagingEnabled</code>设为<code>false</code>的情况下自己实现paging效果。然而，用户体验并不好，至少不如<code>UIScrollView#pagingEnabled = true</code>顺畅，参考<a href="http://stackoverflow.com/questions/6945964/uiscrollview-custom-paging" target="_blank" rel="external">这里</a>，不晓得有没什么办法改善操作体验。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/UIScrollView_pg/ScrollingViewContent/ScrollingViewContent.html" target="_blank" rel="external">Scroll View Programming Guide for iOS</a></li>
<li><a href="http://tech.glowing.com/cn/practice-in-uiscrollview/" target="_blank" rel="external">UIScrollView实践经验</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UIScrollView/">UIScrollView</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-git-branching-and-remoting" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/06/git-branching-and-remoting/" class="article-date">
  	<time datetime="2015-12-06T05:23:23.000Z" itemprop="datePublished">2015-12-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/06/git-branching-and-remoting/">Git分支与远程操作</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前在《<a href="/git-basics/">Git基础</a>》中介绍了一些Git的重要概念和基本操作，本文在此基础上补充Git分支与远程操作相关的内容。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是Git中的重要概念，其意义和重要性都被讲烂了，这里就不再过多阐述了。简单来说，每次commit都会产生一个快照，为了更好管理，Git把这些快照串成一条时间线，每条时间线就是一个分支，每个不少于一次提交的Git仓库都至少有一个分支；每个commit都有一个commit-id，而分支更高级一些，每个分支都有一个名字，譬如<code>master</code>。</p>
<p>《<a href="/git-basics/">Git基础</a>》中曾说过「在Git中，使用<code>HEAD</code>表示当前版本」，这种说法其实不够准确，因为<code>HEAD</code>指针并不是指向commit，而是指向当前分支，当前分支才指向commit。譬如在下图中，<code>HEAD</code>指向<code>some branch</code>（只是举个例子，Git不允许这样命名），<code>some branch</code>指向到commit。</p>
<div class="imagediv" style="width: 280px; height: 140px"></div>

<p>如果新创建一个分支<code>other branch</code>，再把<code>HEAD</code>指向到它，就表示当前分支在<code>other branch</code>上：</p>
<div class="imagediv" style="width: 280px; height: 190px"></div>

<p>默认情况下，当前分支的名字叫<code>master</code>，也就是经常所说的<code>master</code>分支。</p>
<p>Note: <code>master</code>分支并不是一个特殊分支，它跟其他分支完全没有区别。之所以几乎每个Git仓库都有master分支，是因为<code>git init</code>命令默认创建它，并且大多数人都懒得去改动它。</p>
<p>Git的分支操作涉及的命令包括<code>git branch</code>、<code>git checkout</code>、<code>git merge</code>，通过该命令可以创建、删除以及列举分支，具体使用如下文所述。</p>
<p><strong>创建分支</strong></p>
<p>创建新分支很简单，其本质是创建一个可以移动的新指针。比如，创建一个名为<code>testing</code>的分支，使用<code>git branch &lt;branch-name&gt;</code>即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch <span class="built_in">test</span>-branch  <span class="comment"># 创建一个名为test-branch的分支</span></div></pre></td></tr></table></figure>
<p>这条命令会在当前commit上创建一个指针。</p>
<p><strong>列举分支</strong></p>
<p>使用<code>git branch</code>或者<code>git branch --list</code>可以将所有分支给显示出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch --list</div><div class="line">* master</div><div class="line">  <span class="built_in">test</span>-branch</div></pre></td></tr></table></figure>
<p><code>master</code>前的星号（<code>*</code>）标记了当前分支，如上意味着当前分支是<code>master</code>。</p>
<p>使用<code>git log</code>命令并辅以<code>--decorate</code>选项可以查看各个分支所指向的commit：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --decorate --pretty=oneline</div><div class="line">0eb9dceaaf8f86bacd76ee7109edc1fec256b56e (HEAD -&gt; master, <span class="built_in">test</span>-branch) version 3</div><div class="line">82be09ef9e1ddb51b41d9b2b36039218673e5a6e version 2</div><div class="line">87e61d64ce34693ad62a23f7ee448ed3d9278f56 version 1</div></pre></td></tr></table></figure>
<p>正如所见，当前<code>master</code>和<code>test-branch</code>分支均指向version 3所对应的commit。</p>
<p>P.S: 如何在创建分支时指定commit？</p>
<p><strong>切换分支</strong></p>
<p>使用<code>git checkout &lt;branch-name&gt;</code>命令切换分支。</p>
<p>切换分支的命令非常简单，似乎也没有太多让人纠结的选项；但仍然有一个重大疑问：切换分支时，会对工作区和暂存区有影响吗？影响如何？</p>
<p><del>我们的期待是什么样子呢？我所期待的是，在branch a捣鼓了一通后，因为某种原因切换到branch b捣鼓一番，再切回到branch a时，之前在branch a中捣鼓的东西仍然有保留，无论是工作区还是暂存区，都是原来的味道；再切换到branch b也是同样的结果。换句话说，我们希望在逻辑上，branch a和branch b的工作区和暂存区也保持独立，互不影响。</del></p>
<p><del>事实是我所期待的那样的吗？</del></p>
<p>根据<a href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell" target="_blank" rel="external">Git Pro</a>的说法，<code>git checkout &lt;branch-name&gt;</code>这条命令做了两件事情：一是使<code>HEAD</code>指向<code>&lt;branch-name&gt;</code>分支，二是将工作区恢复成<code>&lt;branch-name&gt;</code>分支所指向的快照内容。</p>
<p>P.S: 对上面这段说明，表示不怎么理解，有待更详细的分析。</p>
<p>最后，<code>git checkout &lt;branch-name&gt;</code>加上选项<code>-b</code>更强大，它的效果是，创建一个名为<code>&lt;branch-name&gt;</code>的分支并将切换到该分支。</p>
<p>P.S: 关于<code>git checkout &lt;branch-name&gt;</code>对工作区及暂存区的影响，现在仍然没有完全搞清楚，以后有了更深刻理解再补充吧。</p>
<p><strong>删除分支</strong></p>
<p>使用<code>git branch -d &lt;branch-name&gt;</code>删除分支，比较简单，只是需要注意的是，Git不允许删除当前分支。</p>
<p><strong>重命名分支</strong></p>
<p>使用<code>git branch -m &lt;current-name&gt; &lt;new-name&gt;</code>修改分支的名字，也比较简单。</p>
<p><strong>无冲突合并分支</strong></p>
<p><code>git merge</code>命令用于合并指定分支到当前分支。分支合并的复杂地方在于冲突处理。阅读了一些资料，总结了常见的无冲突合并，假设在<code>master</code>中合并<code>test</code>，则无冲突合并包括：</p>
<ul>
<li>在<code>test</code>中新增文件；</li>
<li>在<code>test</code>中删除某文件，<code>master</code>中的该文件是其ancestor版本；</li>
<li>在<code>test</code>中修改某文件，<code>master</code>中的该文件使其ancestor版本；</li>
</ul>
<p>P.S: 「解决分支冲突」是个大主题，在以后的博客中补充吧！</p>
<p>P.S: <code>git merge</code>的操作是事务性的吗？会存在某个文件合并成功但是别的文件合并失败的情况吗？</p>
<p>P.S: 对<code>git branch</code>这几个命令的使用不是很理（zan）解（tong），如果是我设计，<code>git branch</code>的作用与<code>git branch list</code>等同，都是用于列举所有分支；使用<code>git branch delete</code>代替<code>git branch -d</code>；使用<code>git branch rename</code>代替<code>git branch -m</code>。</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>为了能在任意Git项目上协作，需要知道如何管理自己的远程仓库。远程仓库是指托管在因特网或其他网络中的项目的版本库。你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。</p>
<p>除了之前提到的<code>git clone</code>，还有4个命令与远程仓库息息相关：<code>git remote</code>、<code>git fetch</code>、<code>git pull</code>、<code>git push</code>。有一张非常常见且直观的图对这些命令的功能进行了描述，如下：</p>
<div class="imagediv" style="width: 400px; height: 113px"></div>

<p><strong>远程仓库的查看、添加、移除以及重命名 – git remote</strong></p>
<p>为了便于管理，Git要求每个远程主机都有一个主机名，简单来说，<code>git remote</code>命令就是用于管理Git远程主机名的。</p>
<p>不带选项的时候，<code>git remote</code>命令列出所有远程主机：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git remote</div><div class="line">origin</div></pre></td></tr></table></figure>
<p>也可以指定选项<code>-v</code>，会显示更多信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git remote -v  </div><div class="line">origin  git://github.com/sadjason/sadjason.github.io.git (fetch)</div><div class="line">origin  git://github.com/sadjason/sadjason.github.io.git (push)</div></pre></td></tr></table></figure>
<blockquote>
<p>P.S: 克隆（<code>git clone</code>）版本库的时候，所使用的远程主机被Git自动命名为<code>origin</code>，如果想使用其他的主机名，需要使用<code>-o</code>选项指定，譬如<code>git clone -o example git://example.com/example.git</code>。</p>
</blockquote>
<p><code>git remote</code>是一个比较复杂的命令，旗下还包括一些子命令：</p>
<ul>
<li><code>git remote add</code>，用于<strong>添加远程仓库</strong>，使用起来非常简单，运行<code>git remote add &lt;name&gt; &lt;url&gt;</code>即可添加一个新的远程Git仓库，同时指定一个名称（任意）。</li>
<li><code>git remote show</code>，用于<strong>查看指定远程仓库的更多信息</strong>，基本使用格式是<code>git remote show &lt;name&gt;</code>。</li>
<li><code>git remote remove</code>，用于<strong>移除远程仓库</strong>，如果因为一些原因想要移除一个远程仓库，可以使用<code>git remote remove &lt;name&gt;</code>命令，<code>git remote rm</code>与之等价。</li>
<li><code>git remote rename</code>，用于<strong>远程仓库重命名</strong>，基本使用格式是<code>git remote rename &lt;old_name&gt; &lt;new_name&gt;</code>。</li>
</ul>
<blockquote>
<p>P.S: 如上所列的几个<code>git remote</code>命令，只有<code>git remote show</code>需要访问网络，其余几个都是本地操作。以<code>git remote add</code>为例，其本质无非是在本地为远程仓库的URL创建一个字符串映射（毕竟操作remote repository时输入URL并不是一个特别好的体验）。这个字符串映射并没有任何实际意义，可以简单看成是远程仓库URL的一个alias。stackoverflow中的<a href="https://stackoverflow.com/questions/5617211/what-is-git-remote-add-and-git-push-origin-master/" target="_blank" rel="external">解释</a>更棒一些。既然<code>git remote add</code>的本质是为远程仓库的url创建字符串映射，那么这个映射存放在哪里呢？答案是<code>.git/config</code>。</p>
</blockquote>
<p><strong>关于git remote的一些补充</strong></p>
<p>我在学习过程中对这个命令产生了极大的误解，我以为能够通过<code>git remote</code>管理远程（服务器）repository，譬如远程在服务器中创建一个repository。</p>
<p>甚至做了如下的测试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ mkdir MyLocalRepository</div><div class="line">$ <span class="built_in">cd</span> MyLocalRepository</div><div class="line">$ git init</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"hello, github"</span> &gt;&gt; README.md</div><div class="line">$ git add README.md</div><div class="line">$ git commit -m <span class="string">"add readme file"</span></div><div class="line">$ git remote add MyLocalRepository https://github.com/xxoo/MyLocalRepository.git</div></pre></td></tr></table></figure>
<p>其中最后一步，我的目的是在github中创建一个名为MyLocalRepository的仓库，上述命令执行完后没有任何错误信息（UNIX的哲学是没有消息就是好消息）。如果这个命令执行成功，我能够在github中看到一个新的仓库被创建（不是通过<a href="https://github.com/new" target="_blank" rel="external">Create a New Repository</a>这个接口创建哦）。但我登录github后，啥都没发生。</p>
<p>这个测试结果说明我对<code>git remote</code>的理解有问题，于是去stackoverflow中寻找「可否在本地远程在github上创建repository」问题答案，还真找到了，即<a href="http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-ssh" target="_blank" rel="external">Is it possible to create a remote repository on github from client</a>。显然，stackoverflow给出的答案是：可以，但是需要通过github的api，这是另外一个故事了，本文不涉入。</p>
<p><strong>从远程仓库抓取数据 – git fetch</strong></p>
<p>从远程仓库中获取数据，可以执行<code>git fetch &lt;remote-repository-name&gt;</code>命令，该命令会访问远程仓库，从中拉取所有本地还没有的数据，执行完成后，本地将会拥有那个远程仓库中的所有分支的引用。</p>
<p>默认情况下，<code>git fetch</code>取回所有分支的更新，但若只想取回特定分支的更新，可以指定分支名：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git fetch &lt;remote-repository-name&gt; &lt;branch-name&gt;</div></pre></td></tr></table></figure>
<p>使用<code>git fetch</code>的一些说明：</p>
<ul>
<li>如果不指定<code>&lt;remote-repository-name&gt;</code>，则默认执行<code>git fetch origin</code>，执行成功的前提是<code>origin</code>这个远程仓库确实存在；</li>
<li><code>git fetch</code>可以fetch多个repository，指定选项<code>--all</code>即可；</li>
<li><code>git fetch</code>仅仅是将指定的远程仓库的所有分支内容全部下载到本地，除此之外不做其他的事情（譬如分支合并）；</li>
</ul>
<p><strong>git pull</strong></p>
<p><code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。其完整格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull &lt;remote-repository-name&gt; &lt;remote-branch-name&gt;:&lt;<span class="built_in">local</span>-branch-name&gt;</div></pre></td></tr></table></figure>
<p>比如，取回<code>origin</code>远程仓库的<code>next</code>分支，与本地的<code>master</code>分支合并，需要写成下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull origin next:master</div></pre></td></tr></table></figure>
<p>如果远程分支是与当前分支合并，则<code>:&lt;local-branch-name&gt;</code>可以去掉，譬如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull origin next</div></pre></td></tr></table></figure>
<p>P.S: <code>git pull</code>是事务性操作吗？</p>
<p><strong>推送数据到远程仓库 – git push</strong></p>
<p><code>git push</code>命令用于将本地分支的更新，推送到远程主机，使用格式是：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push &lt;remote-repository-name&gt; &lt;<span class="built_in">local</span>-branch-name&gt;:&lt;remote-branch-name&gt;</div></pre></td></tr></table></figure>
<p><strong>git clone v.s git fetch v.s git pull</strong></p>
<p><code>git clone</code>、<code>git fetch</code>、<code>git pull</code>这三个命令似乎都是用于从远程拉取数据，三者有啥区别呢？</p>
<p>本地没有repository时，<code>git clone</code>将远程repository整个下载下来；<code>git fetch</code>将远程新的commit数据（如果有的话）下载过来；<code>git pull</code>相当于<code>git fetch</code>和<code>git merge</code>，在<code>git fetch</code>的基础上，进行分支合并。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="http://git-scm.com/book/" target="_blank" rel="external">Pro Git</a></li>
<li><a href="https://git-scm.com/book/zh/v2/" target="_blank" rel="external">Pro Git中文版</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">Git远程操作详解</a></li>
<li><a href="https://stackoverflow.com/questions/5617211/what-is-git-remote-add-and-git-push-origin-master/" target="_blank" rel="external">What is git-remote-add and git-push-origin-master?</a></li>
<li><a href="http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-opening-br" target="_blank" rel="external">Is it possible to create a remote repo on GitHub from the CLI without opening browser?</a></li>
<li><a href="https://snowdream86.gitbooks.io/github-cheat-sheet/content/zh/index.html" target="_blank" rel="external">GitHub秘籍</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tools/">Tools</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Others/">Others</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>