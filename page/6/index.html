<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/6/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/iOS/">Android相关</a></li>
				        
							<li><a href="/categories/essay">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.67px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 15px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 18.33px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.67px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 20px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 13.33px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 16.67px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.67px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/Transition/" style="font-size: 13.33px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，Android开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/iOS/">Android相关</a></li>
		        
					<li><a href="/categories/essay">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-using-webviewjavascriptbridge" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/16/using-webviewjavascriptbridge/" class="article-date">
  	<time datetime="2015-06-16T08:53:35.000Z" itemprop="datePublished">2015-06-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/16/using-webviewjavascriptbridge/">使用WebViewJavascriptBridge</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在App中使用Web代替一些Native UI已经成为移动客户端开发的一种思潮。在App中嵌入Web有一个重要的基础问题：Objective-C和JavaScript的交互。</p>
<p>近期的项目需要，笔者开始着手这方面的问题学习。很容易想到：一定存在某个引擎能够在OC和JS之间转换。去github中搜索关键字<code>iOS JavaScript</code>得到的选择并不多，第三方库<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>的Stars遥遥领先，自然选择它作为OC和JS的交互引擎了。</p>
<p>本文是笔者了解WebViewJavascriptBridge过程中的一些学习记录，好记性不如烂笔头嘛！</p>
<h2 id="使用WebViewJavascriptBridge"><a href="#使用WebViewJavascriptBridge" class="headerlink" title="使用WebViewJavascriptBridge"></a>使用WebViewJavascriptBridge</h2><p>WebViewJavascriptBridge的使用不难，<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>提供的Example比较直观的展示了各种接口的使用。</p>
<p>App中嵌入Web一般需要使用UIWebView（除非你自己写一个），WebViewJavascriptBridge正是配合UIWebView进行工作的。</p>
<p><strong>初始化</strong></p>
<p>和其他第三库一样，使用WebViewJavascriptBridge需要做一些初始化，只是WebViewJavascriptBridge的初始化包括两部分：「Objective-C初始化」和「JavaScript初始化」。</p>
<ul>
<li>OC初始化</li>
</ul>
<p>OC中初始化WebViewJavascriptBridge的前提是存在一个UIWebView对象，每个WebViewJavascriptBridge对象都应该与一个UIWebView对象绑定。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建UIWebView对象</span></div><div class="line"><span class="built_in">UIWebView</span> * webView = [[<span class="built_in">UIWebView</span> alloc] initWithFrame:<span class="keyword">self</span>.view.bounds];</div><div class="line">    </div><div class="line"><span class="comment">// 配置logging</span></div><div class="line">[WebViewJavascriptBridge enableLogging];</div><div class="line">    </div><div class="line"><span class="comment">// 创建WebViewJavascriptBridge对象并与UIWebView对象绑定</span></div><div class="line"><span class="keyword">self</span>.bridge = (&#123;</div><div class="line">    WebViewJavascriptBridge* bridge =</div><div class="line">    [WebViewJavascriptBridge bridgeForWebView:webView</div><div class="line">                              webViewDelegate:<span class="keyword">self</span></div><div class="line">                                      handler:^(<span class="keyword">id</span> data, WVJBResponseCallback responseCallback) &#123;</div><div class="line">                                          <span class="comment">// do something</span></div><div class="line">                                          <span class="comment">// responseCallback(responseData)</span></div><div class="line">                                      &#125;</div><div class="line">     ];</div><div class="line">    bridge;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用类方法创建一个WebViewJavascriptBridge对象，其中有一个<code>block</code>类型的handler。这个handler用来处理来自于JavaScript发送的消息，<strong>handler的形参与JavaScript中的send方法的形参对应</strong>，一般有两个参数，第一个参数是JS send传入的参数（可以是任意类类型），第二个是JS send传入的回调handler。</p>
<p>P.S：看客可能像我当初一样不太理解第二个参数：responseCallback，后文会对此进行详细说明。</p>
<ul>
<li>JS初始化</li>
</ul>
<p>除了OC外，JS中也得执行针对WebViewJavascriptBridge的初始化代码。这意味着，除了客户端（iOS开发人员）外，服务端（后端写JS的开发人员）也得对WebViewJavascriptBridge有所了解。好在需要理解的内容不多，十分钟就可以搞定。JavaScript对WebViewJavascriptBridge初始化过程（这部分代码几乎是固定的）如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建了一个connectWebViewJavascriptBridge方法，该方法名是固定的</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">connectWebViewJavascriptBridge</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.WebViewJavascriptBridge) &#123;</div><div class="line">        callback(WebViewJavascriptBridge)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">'WebViewJavascriptBridgeReady'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            callback(WebViewJavascriptBridge)</div><div class="line">        &#125;, <span class="literal">false</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// 调用connectWebViewJavascriptBridge方法</span></div><div class="line">connectWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</div><div class="line">    bridge.init(<span class="function"><span class="keyword">function</span>(<span class="params">message, responseCallback</span>) </span>&#123;</div><div class="line">        <span class="comment">// do something</span></div><div class="line">        responseCallback(responseData)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>先创建了一个connectWebViewJavascriptBridge方法，该方法注册了一个WebViewJavascriptBridgeReady事件，同时声明了一个全局的WebViewJavascriptBridge变量，这样我们可以在外部通过WebViewJavascriptBridge调用相关方法。</p>
<p>在<code>bridge.init</code>里面同样定义了一个匿名function，这个function用来接收Objective-C里面通过send方法发送的消息的，参数与OC里的send方法参数对应。同样，一般有两个参数，第一个参数是OC send传入的参数（可以是任意类类型），第二个是OC send传入的回调handler。</p>
<p>可以简单总结一下。初始化的根本目的是啥？<br>根据我的理解，初始化的根本目的是：消息接收者定义<code>message handler</code>。</p>
<p>P.S：请记住<code>message handler</code>这个名词，后文会经常用到。</p>
<p><strong>发送消息</strong></p>
<p>上述「初始化」操作的目的是为了确保OC和JS能够相互处理来自对方的消息。</p>
<p>除了「初始化」操作之外，WebViewJavascriptBridge对发送消息也有所约束，这意味着OC和JS发送消息必须得遵守一定的格式。</p>
<ul>
<li>OC向JS发送消息</li>
</ul>
<p>OC向JS发送消息，定义了两个用于「发送消息」的接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// APIs</span></div><div class="line">- (<span class="keyword">void</span>)send:(<span class="keyword">id</span>)data;</div><div class="line">- (<span class="keyword">void</span>)send:(<span class="keyword">id</span>)data responseCallback: (WVJBResponseCallback)responseCallback;</div></pre></td></tr></table></figure>
<p>两个接口的区别只是参数个数不同，参数data指的是「传给JS的参数」，responseCallback参数是一个<code>block</code>，给JS发送消息后，JS的<code>message handler</code>可能会返回一些值，responseCallback就是用来处理<strong><em>返回值</em></strong>的。</p>
<p>P.S：data可以为空；这里的「返回值」并不是非常准确的说法，只是一种参考「函数」的说法，准确来讲应该叫<code>response data</code>。</p>
<ul>
<li>JS向OC发送消息</li>
</ul>
<p>JS向OC发送消息，WebViewJavascriptBridge也定义了两种格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bridge.send(data)</div><div class="line">bridge.send(data, <span class="function"><span class="keyword">function</span> <span class="title">responseCallback</span>(<span class="params">responseData</span>) </span>&#123; ... &#125;)</div></pre></td></tr></table></figure>
<p>显然，无论是「OC向JS发送消息」，还是「JS向OC发送消息」，都有两种格式，含有<code>responseCallback</code>和不含<code>responseCallback</code>。</p>
<p>P.S：data可以为空；</p>
<p><strong>理解responseCallback</strong></p>
<p>上文已经多次提到了<code>responseCallback</code>，可能是由于笔者对跨平台了解得比较少，也可能是对函数式编程了解不多，刚开始对<code>responseCallback</code>不甚理解。这一小段将对<code>responseCallback</code>进行详细阐述。</p>
<p>关于「消息处理」和「消息发送」，我是参考「函数定义」和「函数调用」这两个概念来理解的。「函数定义」定义了函数的具体工作（即说明这段代码块都干了些啥），「函数调用」指示执行具体代码块；根据我的理解，从概念上讲，「消息处理」对应「函数定义」，「消息发送」对应「函数调用」。</p>
<p>这段话非常啰嗦，但引入这么一种对应关系是为了更好说明<code>responseCallback</code>。</p>
<p>对于函数（广义上的「函数」，而不仅仅指JavaScript function）来说，函数可能有返回值，也可能没有返回值。当有返回值时，调用者往往会定义变量接收返回值，方便之后使用返回值…而上文中反复出现的<code>responseCallback</code>有些类似于对函数返回值的处理，消息发送方向消息接收方发出一个消息，除了希望对方处理某些事情之外，可能还期待对方返回一些数据（<code>response data</code>），这些数据往往会在后续的处理中起作用。</p>
<p>因此，若「消息接收方」的<code>message handler</code>中可能有需要传给「消息发送方」的<code>response data</code>时，「消息发送方」还需要定义一个handler用来处理这些值，即所谓的<code>responseCallBack</code>。</p>
<p>P.S：为什么函数处理返回值使用<code>ret = aFunction(variable)</code>这样的格式，而这里使用<code>responseCallBack</code>处理呢？我想是因为这里处理的是两种不同语言，过程中难免存在类型转换，况且，还有可能是由于并发。</p>
<p>对于函数而言，若某个函数有返回值，但调用者不想要保存该返回值，此时往往不会定义变量接收该返回。这在大多属于语言中是被允许的。</p>
<p>对于WebViewJavascriptBridge也一样，「消息发送方」发送消息时，可以不传入responseCallback参数，表示对「消息接收方」的<code>response data</code>不care。</p>
<p>在定义<code>message handler</code>时，在handler的<code>responseCallback(responseData)</code>好比函数中<code>return ret</code>。</p>
<p>P.S：在定义<code>message handler</code>时，并不要求一定有<code>responseCallback(responseData)</code>这么一句代码；只是个人觉得，有必要写上，哪怕没有任何<code>response data</code>需要返回，也得加上<code>responseCallback(null)</code>。类似于函数，若某个函数没有返回值，也没有显式调用<code>return</code>语句，在编译阶段，编译器也会帮助在末尾加上<code>return void</code>。</p>
<p>理清了<code>responseCallback</code>这个概念，就基本上算是学会使用WebViewJavascriptBridge了。</p>
<p><strong>OC和JS互相调用</strong></p>
<p>「OC和JS互相调用」指的是OC和JS互相对应对方的handler（block或function）。</p>
<p>笔者刚开始觉得啰嗦：既然「消息机制」能够解决OC和JS交互问题，为啥还需要OC和JS互相调用对方的handler呢？</p>
<p>我还没有找到比较权威的的说法，但这里也谈谈自己的一点理解。</p>
<p>先说「函数」，「函数」的本质不过是代码的一种组织结构，它使得代码块具有了更好的可读性，同时极大加强代码复用。</p>
<p>基于「消息机制」，我们可以尽可能实现任何基于文本交互。可以做的事情非常丰富，譬如「消息发送者」传入参数<code>1</code>，<code>message handler</code>执行A段代码，传入参数<code>2</code>，执行B段代码。但问题是：基于「消息机制」，OC和JS之间的几乎所有交互任务都得写在<code>message handler</code>中。当交互任务变得复杂时，代码组织将是一种灾难（会充斥很长并且嵌套很深的<code>if</code>语句）。以消息的第一个参数data为例，有时候，data可能是一个URL字符串，有时候可能是一个JSON字符串，有时候可能只是一个数值，光是解析这些参数，都需要一个非常复杂的<code>if</code>语句…写到这里，「在OC和JS中定义能被对方调用的handler」的意义就不需要多讲了。</p>
<p>关于「OC和JS互相调用」，WebViewJavascriptBridge也定义了一些约束。约束包括两部分：定义handler的姿势，调用handler的姿势。</p>
<p><strong>OC定义和调用JS handler</strong></p>
<p>所谓定义handler，其实是向bridge注册一个handler，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// API</span></div><div class="line"><span class="comment">// - (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler</span></div><div class="line">    </div><div class="line"><span class="comment">// eg:</span></div><div class="line">[<span class="keyword">self</span>.bridge registerHandler:<span class="string">@"OCHandlerName"</span></div><div class="line">                     handler:^(<span class="keyword">id</span> data, WVJBResponseCallback responseCallback) &#123;</div><div class="line">                         <span class="comment">// do something</span></div><div class="line">                         responseCallback(responseData);</div><div class="line">                 &#125;</div><div class="line"> ];</div></pre></td></tr></table></figure>
<p>向bridge注册handler包括两部分内容：name和handler body。</p>
<p>调用JS的handler也简单，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// APIs</span></div><div class="line"><span class="comment">// - (void)callHandler:(NSString *)handlerName;</span></div><div class="line"><span class="comment">// - (void)callHandler:(NSString*)handlerName data:(id)data;</span></div><div class="line"><span class="comment">// - (void)callHandler:(NSString*)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback;</span></div><div class="line">    </div><div class="line"><span class="comment">// eg：</span></div><div class="line">[<span class="keyword">self</span>.bridge callHandler:<span class="string">@"JSHandlerName"</span> data:data];</div></pre></td></tr></table></figure>
<p><strong>JS定义和调用OC handler</strong></p>
<p>在JS定义（注册）handler的姿势如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bridge.registerHandler(<span class="string">"handlerName"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">responseData</span>) </span>&#123; ... &#125;)</div></pre></td></tr></table></figure>
<p>调用OC的handler也简单，和OC调用JS handler类似。</p>
<p>。。。。。。</p>
<p>本文写得好啰嗦啊！</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge - github</a></li>
<li><a href="http://dxldy.iteye.com/blog/2078350?utm_source=tuicool" target="_blank" rel="external">《WebViewJavascriptBridge使用说明（iOS）》</a></li>
<li><a href="http://honglu.me/2014/09/27/WebViewJavascriptBridge使用/" target="_blank" rel="external">《WebViewJavascriptBridge使用》</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-uiwebview-load-local-html" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/16/uiwebview-load-local-html/" class="article-date">
  	<time datetime="2015-06-16T08:38:39.000Z" itemprop="datePublished">2015-06-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/16/uiwebview-load-local-html/">UIWebView加载本地HTML文件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>写本文的原因是今天被要求「调研在iOS中加载本地HTML的相关技术」，好记性不如烂笔头，将一些东西给记录下来吧。</p>
<p>应用场景是这样的：手头的iOS App有一部分UI需要使用HTML完成，好处是这部分UI可以更灵活，即可以在任何不需要升级App的情况下更新这部分UI（包括样式、操作等等）。当下非常火的技术 – Facebook的React Native – 正是用来解决这种问题的，毕竟在传统的开发模式下，更新UI必须要升级App，而升级App是一个非常耗时的过程。使用Web App部分代替Native App已经成为当下移动客户端开发的一种思潮了。为了简便起见，也为了不给项目的接盘者制造更高的门槛，暂时决定不使用React Native（原因是多方面的）等著名框架去这种事情，从0开始探究。话说胡来，也许走了这么一遭之后，以后学习React Native会有更多的体会呢！</p>
<p>总之，目前的构想是这样的：</p>
<ol>
<li>App部分UI是由HTML+JS+CSS完成的，HTML+JS+CSS代码会随着App一起发布；</li>
<li>当后端决定更新App的部分UI（HTML）时，客户端从服务器下载最新的HTML+JS+CSS包，解压后代替本地的、旧的HTML+JS+CSS资源，将最新的呈现给用户，至此完成UI的更新；</li>
</ol>
<p>因此有这么些问题需要考虑：</p>
<ol>
<li>加载本地HTML+JS+CSS资源（在iOS中，通常使用UIWebView）；</li>
<li>解压从服务端下载的压缩文件（HTML+JS+   CSS包）；</li>
<li>JS代码和OC代码的互相调用；</li>
</ol>
<p>本文主要探究第一个问题！</p>
<h2 id="UIWebView介绍"><a href="#UIWebView介绍" class="headerlink" title="UIWebView介绍"></a>UIWebView介绍</h2><p>UIWebView是iOS中一个非常常用的控件，是内置的浏览器控件，可能也是最强大复杂的控件。可以用它来浏览网页、打开文档（譬如PDF文档）等等。</p>
<p>UIWebView既可以用来显示本地文档，也可以用来显示网络文档。无论是显示本地文件还是网络文件，此过程都可以统称为「加载」。与「加载」相关的方法不多，只有三个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Loading Local Content or Loading Content From the Network</span></div><div class="line">- (<span class="keyword">void</span>)loadRequest:(<span class="built_in">NSURLRequest</span> *)request;</div><div class="line">    </div><div class="line"><span class="comment">// 嵌入HTML结构的字符串</span></div><div class="line">- (<span class="keyword">void</span>)loadHTMLString:(<span class="built_in">NSString</span> *)string</div><div class="line">               baseURL:(<span class="built_in">NSURL</span> *)baseURL;</div><div class="line">    </div><div class="line"><span class="comment">// Loading Local Content</span></div><div class="line">- (<span class="keyword">void</span>)loadData:(<span class="built_in">NSData</span> *)data</div><div class="line">        MIMEType:(<span class="built_in">NSString</span> *)MIMEType</div><div class="line">textEncodingName:(<span class="built_in">NSString</span> *)textEncodingName</div><div class="line">         baseURL:(<span class="built_in">NSURL</span> *)baseURL;</div></pre></td></tr></table></figure>
<p>与UIWebView相关的知识点并不多（从某种角度来看，也可以认为是Apple封装得比较好吧），除了上述的三个方法之外，还有必要了解的是UIWebViewDelegate定义的一些delegate方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开始加载前调用</span></div><div class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line"> navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType;</div><div class="line"><span class="comment">// 开始加载时调用</span></div><div class="line">- (<span class="keyword">void</span>)webViewDidStartLoad:(<span class="built_in">UIWebView</span> *)webView;</div><div class="line"><span class="comment">// 加载成功时调用</span></div><div class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView;</div><div class="line"><span class="comment">// 加载失败时调用</span></div><div class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">UIWebView</span> *)webView didFailLoadWithError:(<span class="built_in">NSError</span> *)error;</div></pre></td></tr></table></figure>
<p>除此之外，UIWebView似乎有啥其他需要了解的内容，若有需要，以后再补充吧！</p>
<h2 id="加载本地HTML文件"><a href="#加载本地HTML文件" class="headerlink" title="加载本地HTML文件"></a>加载本地HTML文件</h2><p>加载本地HTML文件不是多么难的事情，但再简单的事情也有一个1-2-3-4，不是嘛？何况笔者比较笨，参考<a href="http://blog.csdn.net/kaitiren/article/details/17115085" target="_blank" rel="external">UIWebView加载本地HTML5文件</a>，也分几个步骤：</p>
<ol>
<li>准备HTML文件及其资源文件（主要是CSS文件和JS文件以及image文件）；</li>
<li>加载本地HTML文件；</li>
</ol>
<p>第一种：<br>loadRequest:<br>第二种：<br>loadHTMLString:baseURL:</p>
<p><strong>第一步，准备HTML文件及其资源文件。</strong></p>
<p>HTML及其资源文件比较容易获取，随便找个比较漂亮的web页面，将它保存起来即可！</p>
<p>显然HTML文件及其资源文件是需要添加到工程的，问题是如何添加呢？如何组织管理这些文件呢？沙盒？Bundle？</p>
<p><strong>Xcode工程添加文件有两种方式</strong></p>
<p>向项目中添加已有的文件（或资源文件，或第三方库）不是什么稀罕的事情，只是平时都没怎么注意。实际上，将「文件」或者「目录」添加到项目时，Xcode给了我们两个选项：Create groups以及Create folder references，如下图：</p>
<div class="imagediv" style="width: 730px; height: 126px;"></div>

<p>简单来说，若选择Create groups的方式添加文件夹，则文件夹的颜色是黄色的；若选择Create folder references的，则发现添加的文件夹在工程目录中的的颜色是蓝色的：</p>
<div class="imagediv" style="width: 400px; height: 120px;"></div>

<p>当然不只是颜色上的区别！主要是Xcode对加入的文件的路径处理不一样。</p>
<p>如果文件/文件夹以Create groups的方式添加到工程中，则不管加入项目的文件的目录结构如何，在APP中都可以通过mainBundlePath/filename这样结构来访问文件；反之，若文件/文件夹以Create folder references的方式添加到工程中，则会保留相对路径，访问文件的结构就变成了mainBundlePath/path/filename。</p>
<p>理解Create groups以及Create folder references并不难，自己动手试试就能感受二者的不同了。</p>
<p><strong>Bundle介绍</strong></p>
<p>上文谈到了向工程添加文件的两种方式，由此延伸，不得不提bundle，一直以来对bundle的理解非常模糊，知道它的本质是一个目录，也知道在OS X中就有此概念，但一直没get到<code>bundle</code>的存在意义，总感觉它没必要存在，事实上也没主动使用它。</p>
<p>借撰写本文这个机会，驱动一下自己，查查资料，争取对bundle理解更深入一点点吧！</p>
<p>参考《<a href="http://avatar-matrix.lofter.com/post/e4689_236e82" target="_blank" rel="external">Bundle in iOS</a>》和《<a href="http://www.cnblogs.com/BigPolarBear/archive/2012/03/28/2421802.html" target="_blank" rel="external">iOS开发里的Bundle是个啥玩意</a>》。</p>
<p>简单地讲，bundle就是一个内部结构按照标准规则组织的特殊目录，常用来存放一些资源文件，譬如图片，plist文件等，它不会成为编译的一部分，所以它不存放能够被编译的文件，譬如<code>.m</code>、<code>.h</code>文件等。</p>
<p>Bundle的主要用途是软件的国际化，想象一个应用场景：软件有美国、中国版本，软件的logo等图片不同，这时候，我们把相应的图片资源放到一个文件夹下，然后修改文件夹的名字，以<code>.bundle</code>作为后缀，然后添加到xcode中。</p>
<p>有过iOS开发经历的人都应该知道，每个project都有个mainBundle，那如何去获取自己定义的bundle内容呢？我们把自定义的bundle当成项目的一种资源，由mainBundle去获取<code>~</code>，然后我们用相同的方式获取自定义的bundle下的资源。即：</p>
<p>1、通过mainBundle去加载自定义的bundle；<br>2、通过获取到的自定义bundle去获取资源；</p>
<p>根据上述场景来写的demo项目结构如下：</p>
<div class="imagediv" style="width: 340px; height: 280px;"></div>

<p>此时，我容易联想到了在Windows世界经常使用的「汉化包」。根据我的理解，我们通过某种手段得到的「汉化包」和本文所谈及的bundle是类似的概念，它们的本质是一个目录，只是这个目录有些特别，特别之处在于它只存放一些资源文件，以及目录名后缀为<code>.bundle</code>，这让它看起来像个文件，但实际上又不是文件，开发者又特别想让普通用户以为它是一个文件…</p>
<p>总之，bundle就是这么个东东。</p>
<p>到了这里，应该弄清楚了该把HTML文件及其资源放在哪里了。</p>
<p>沙盒？显然不可能，沙盒可是App到设备之后才有的概念；所以我们只能让HTML资源成为工程的一部分呢，编译打包时作为安装包的一部分。</p>
<p>放在普通目录下还是组织成bundle，个人以为没必要组织成bundle，因为后者主要用来处理国际化问题，国际化问题面对的一般是图片资源、字符串资源等等，所以不需要组成成bundle，而是直接添加到工程的mainBundle中。</p>
<p>上文已经提到了Xcode工程添加文件有两种方式：Create groups和Create folder references，个人以为应该选择后者！</p>
<p>值得注意是，当被加入到项目中的文件包含js文件时，有可能因为操作不慎等原因，js文件成为了编译文件，若是这样，应该将它从<code>Compile Sources</code>给踢掉，让它成为<code>Copy Bundle Resources</code>的一部分，具体做法是在TARGETS-&gt;Build Phases中的<code>Compile Sources</code>中找到该js文件，并将其移到<code>Copy Bundle Resources</code>中，如下图所示：</p>
<div class="imagediv" style="width: 699px; height: 364px;"></div>

<p><strong>第二步，加载本地HTML。</strong></p>
<p>本文示例中，HTML文件及其资源文件被组织在一个叫<code>html</code>的目录中，目录结构如下图，index.html是要被加载的目标文件，index.html中访问css、js以及图片资源的方式都是使用相对路径，实现代码也给展示在下图中。</p>
<div class="imagediv" style="width: 926px; height: 400px;"></div>

<p>上图右侧代码区域加载策略是，先获取本地HTML文本，转为字符串，然后使用<code>loadHTMLString:baseURL:</code>方法加载；当然也可以使用<code>loadRequest:</code>方法，哪个更好？我暂时也不知道！</p>
<p><strong>关于baseURL</strong></p>
<p>上文<code>loadHTMLString:baseURL:</code>方法的第二个参数是baseURL，baseURL是HTML字符串中引用到资源的查找路径，当HTML中没有引用外部资源时，可以指定为<code>nil</code>；若引用了外部资源，一般情况下使用mainBundle的路径即可。在实际操作中，常常会出现「文本显示正常，图片无法显示」等情况，若HTML文本中引用外部资源都是使用相对路径，则出现这种问题的原因一般都是baseURL参数错误（有时甚至是<code>nil</code>）。</p>
<p>最后，本文的Demo详见<a href="https://github.com/sadjason/iOSDemos/tree/master/UIWebView%E9%9D%9E%E5%88%9D%E4%BD%93%E9%AA%8C" target="_blank" rel="external">这里</a>。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UIWebView/">UIWebView</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pragma" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/29/pragma/" class="article-date">
  	<time datetime="2015-04-29T08:12:35.000Z" itemprop="datePublished">2015-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/29/pragma/">预处理指令#pragma</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="pragma介绍"><a href="#pragma介绍" class="headerlink" title="#pragma介绍"></a>#pragma介绍</h2><p><code>#pragma</code>是一个预处理指令，pragma的中文意思是『编译指示』。它不是Objective-C中独有的东西（貌似在C/C++中使用比较多），最开始的设计初衷是为了保证代码在不同编译器之间的兼容性，但随着时间推移，它出现在了更多更丰富的应用场景中。</p>
<p><code>#pragma</code>代码是在编译期间处理的；它既不属于注释，也不属于逻辑代码的一部分；并且它和其他预处理命令譬如<code>#ifdef ... #endif</code>不同，它不会影响代码在运行时的逻辑处理，所以<code>#pragma</code>指令丝毫不会影响到程序在运行时的性能。根据Mattt Thompson大神的描述，在当前Xcode开发环境中，<code>#pragma</code>主要有两个应用场景：组织代码和屏蔽编译警告。</p>
<h2 id="pragma-mark组织代码"><a href="#pragma-mark组织代码" class="headerlink" title="#pragma mark组织代码"></a>#pragma mark组织代码</h2><p>组织代码是个人卫生问题，个人卫生不好（代码组织不好）不能反映人品（技术能力），但它在某种程度中影响了别人是否愿意和他搞基（合作）。在一个项目（尤其是多人合作的项目）中，应该有一个比较好的内部一致性编码习惯，不好的习惯或者缺乏一致性，会使得项目难以维持，协作也不便（这点笔者深有体会，笔者目前的项目有一个同事，编码能力尚可，但编码习惯实在太糟糕，代码紧凑，从来不空格，更妄谈空行和注释了，甚至经常不对齐，看他的代码，一点修改的欲望都没有，想的只是自己重写一遍=_=）。</p>
<p>在组织代码时充分使用<code>#pragma mark</code>就是写出『干净代码』的一个重要环节，就像这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - UIViewController</span></div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">#pragma mark - IBAction</span></div><div class="line">    </div><div class="line">- (<span class="keyword">IBAction</span>)loginNow:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">#pragma mark - UITableViewDataSource</span></div><div class="line">    </div><div class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">#pragma mark - UITableViewDelegate</span></div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中使用<code>#pragma mark</code>将@implementation中的代码（方法）分成了几个逻辑section，这种处理并没有改变程序逻辑，但我们在使用Xcode代码导航工具时可以在视觉上汲取片刻的欢愉：</p>
<div class="imagediv" style="width: 402px; height: 256px;"></div>

<p>组织N个方法为一个section的依据是什么呢？这个就见仁见智了。一般来说：</p>
<ul>
<li>将一个protocol的方法组织成一个section；</li>
<li>将target-action类型方法组织成一个section；</li>
<li>将notification相关方法组织成一个section；</li>
<li>将需要override的父类方法组成成一个section；</li>
</ul>
<h2 id="pragma屏蔽编译警告"><a href="#pragma屏蔽编译警告" class="headerlink" title="#pragma屏蔽编译警告"></a>#pragma屏蔽编译警告</h2><p>使用<code>#pragma mark</code>来组织代码使用比较普遍，相对而言，使用<code>#pragma</code>指令屏蔽编译器和静态分析器的警告相对来说就比较新鲜了。</p>
<p>You know what is even more annoying than poorly-formatted code? Code that generates warnings. 编译警告很可恶，应该尽可能修改代码干掉这些警告，但是有些时候有些警告无法避免，譬如我们在编写<code>@selector(aMethodName)</code>这样的代码时，如果aMethodName没有在上下文中出现，可能会出现含有『undeclared-selector』关键词的warning，有洁癖的程序员会想到干掉这个warning，此时<code>#pragma</code>指令就派上用场了。譬如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wundeclared-selector"</span></span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.selectedViewController respondsToSelector:<span class="keyword">@selector</span>(isReadyForEditing)]) &#123;</div><div class="line">        boolNumber = [<span class="keyword">self</span>.selectedViewController performSelector:<span class="keyword">@selector</span>(isReadyForEditing)];</div><div class="line">    &#125;</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div></pre></td></tr></table></figure>
<p>这是Clang编译器提供的一种解决方案，通过使用<code>#pragma clang diagnostic push/pop</code>来告诉编译器仅仅为某一特定部分代码（记得要在代码片段末尾使用pop将最初的diagnostic设置恢复哦）忽视特定警告。</p>
<p>上述示例中<code>#pragma clang diagnostic ignored</code>后面的<code>&quot;-Wundeclared-selector&quot;</code>指示的是『特定警告』，再别的应用场景中肿么知道该填写什么呢？网络是强大的，有一个（可能是N个）愤怒的网友对clang警告消息做了一个总结，之所以说这个网友“愤怒”，是因为其链接非常有意思：<a href="http://fuckingclangwarnings.com/。" target="_blank" rel="external">http://fuckingclangwarnings.com/。</a></p>
<p>Finally, you can read more about the LLVM’s use of #pragma in the <a href="http://clang.llvm.org/docs/UsersManual.html#diagnostics_pragmas" target="_blank" rel="external">Clang Compiler User’s Manual</a>.</p>
<p>最后，感谢大神Mattt Thompson，本文的参考资料完全来自于《<a href="http://nshipster.com/pragma/" target="_blank" rel="external">#pragma</a>》，本来想用自己的语言完成这篇博客，边读边写，最后发现几乎差不多了，没留下啥自己的东西，就这样吧！</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《<a href="http://nshipster.com/pragma/" target="_blank" rel="external">#pragma</a>》</li>
<li>《<a href="http://nshipster.com/clang-diagnostics/" target="_blank" rel="external">clang diagnostics</a>》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-associated-object" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/29/associated-object/" class="article-date">
  	<time datetime="2015-04-29T06:47:10.000Z" itemprop="datePublished">2015-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/29/associated-object/">关联对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关联对象概述"><a href="#关联对象概述" class="headerlink" title="关联对象概述"></a>关联对象概述</h2><p>Objective—C作为一门动态语言，它本身有一个非常大的弱点，即不能在类的category中方便地为类添加新的自定义属性。「关联对象」（Associated Objects）或曰「关联引用」（Associative References）是基于Objective-C 2.0的一个Runtime特性，它使得可以在Runtime为某个类对象绑定一个对象（通过简单的封装，可以让这个关联属性在使用上和普通属性有类似的体验）。</p>
<p>P.S：也可以绑定一个block。</p>
<p>与此相关有3个函数，都在<code>&lt;objc/runtime.h&gt;</code>中定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 绑定对象，类似setter</span></div><div class="line">objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy);</div><div class="line"><span class="comment">// 获取对象，类似于getter</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key);</div><div class="line"><span class="comment">// 移除绑定关系</span></div><div class="line">objc_removeAssociatedObjects(<span class="keyword">id</span> object);</div></pre></td></tr></table></figure>
<p>假设现在需要往对象A上绑定一个对象B（即B作为A的「属性」），本文称A为「宿主对象」，B为「寄生对象」，这个比喻可能不是很好，为了更简单地表述，先就这么将就着吧。</p>
<p>下面来对这三个函数进行简单的介绍！</p>
<p>上述3个函数的第一个参数都是id类型，都是指「宿主对象」；</p>
<p>objc_setAssociatedObject函数和objc_getAssociatedObject函数的第二个参数是一个整型值，笔者曾一度认为这个参数应该是一个int型指针，用来存放新创建的对象地址值（现在想来这个想法太傻逼了），Objective-C只是要求这个值是Runtime时唯一标识值即可，在实际应用中，这个值常常是static char型变量的指针，譬如这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> kAssociatedObjectKey;</div><div class="line">objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kAssociatedObjectKey);</div></pre></td></tr></table></figure>
<p>但是Mattt Thompson的作者似乎更喜欢这样使用<code>@selector()</code>生成一个指针值，<code>@selector(XXOO)</code>中的参数XXOO可以随便填，但必须得保证唯一性，且objc_setAssociatedObject和objc_getAssociatedObject中必须保持一致。</p>
<p>objc_setAssociatedObject的第三个参数即上文所述的「寄生对象」；</p>
<p>objc_setAssociatedObject的第四个参数policy描述的是「宿主对象」对「寄生对象」的<br>持有策略，有OBJC_ASSOCIATION_ASSIGN、OBJC_ASSOCIATION_RETAIN_NONATOMIC等几个值，这些值分别对应property修饰符assign、strong等。</p>
<p>对于objc_removeAssociatedObjects，注意后缀<code>s</code>，关于其说明，文档的描述是：Removes all associations for a given object. 但似乎不能直接使用它来remove关联的「寄生对象」们，文档是这么说的：</p>
<blockquote>
<p>The main purpose of this function is to make it easy to return an object to a “pristine state”. You should not use this function for general removal of associations from objects, since it also removes associations that other clients may have added to the object. Typically you should use objc_setAssociatedObject with a nil value to clear an association.</p>
</blockquote>
<p>P.S：不太看得懂第一句！</p>
<h2 id="关联对象应用场景"><a href="#关联对象应用场景" class="headerlink" title="关联对象应用场景"></a>关联对象应用场景</h2><p>对于笔者而言，关联引用的最主要应用场景就是在category中为类动态添加<strong>属性</strong>，这方面的应用场景非常非常多，本文就不赘述了。但是《Effective Objective-C 2.0》举了另外一个应用场景的例子。</p>
<p>开发iOS时经常用到UIAlertView类，该类提供了一种标准视图，可向用户展示警告信息，当用户按下按钮关闭该视图时，需要用委托协议（delegate protocol）来处理此动作，但是，要想设置好这个委托机制，就得把创建警告视图和处理按钮动作的代码分开。由于代码分作两块，所以读起来有些乱。比如说，我们在使用UIAlertView时，一般都会这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)askUserAQuestion &#123;</div><div class="line">    <span class="built_in">UIAlertView</span> *alertView = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"Question"</span></div><div class="line">                                                        message:<span class="string">@"What do you want to do?"</span></div><div class="line">                                                       delegate:<span class="keyword">self</span></div><div class="line">                                              cancelButtonTitle:<span class="string">@"Cancel"</span></div><div class="line">                                              otherButtonTitles:<span class="string">@"Continue"</span>, <span class="literal">nil</span>];</div><div class="line">    [alertView show];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// UIAlertViewDelegate protocol method</span></div><div class="line">- (<span class="keyword">void</span>)alertView:(<span class="built_in">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex &#123;</div><div class="line">    <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> doCancel];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> doContinue];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，如果在同一个ViewController中需要多次使用UIAlertView，那么UIAlertViewDelegate方法<code>- (void)alertView:clickedButtonAtIndex:;</code>的实现代码就非常复杂了，譬如会这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UIAlertViewDelegate protocol method</span></div><div class="line">- (<span class="keyword">void</span>)alertView:(<span class="built_in">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex &#123;</div><div class="line">    <span class="keyword">if</span> (alertView == <span class="keyword">self</span>.question1Alert) &#123;</div><div class="line">        <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 巴拉巴拉</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 巴拉巴拉</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alertView == <span class="keyword">self</span>.question2Alert) &#123;</div><div class="line">        <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 巴拉巴拉</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 巴拉巴拉</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alertView == <span class="keyword">self</span>.question3Alert) &#123;</div><div class="line">        <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 巴拉巴拉</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 巴拉巴拉</span></div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要是在创建UIAlertView对象时就把相关的处理逻辑写好，那就简单多了。这可以通过关联对象来处理。简单来说，就是创建UIAlertView对象完成后，对其关联一个block，而在<code>alertView:clickedButtonAtIndex:</code>调用这个block即可。此方案的实现代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line">    </div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *alertViewBlockKey = &amp;alertViewBlockKey;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)askUserAQuestion &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">UIAlertView</span> *alertView = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"Question"</span></div><div class="line">                                                        message:<span class="string">@"What do you want to do?"</span></div><div class="line">                                                       delegate:<span class="keyword">self</span></div><div class="line">                                              cancelButtonTitle:<span class="string">@"Cancel"</span></div><div class="line">                                              otherButtonTitles:<span class="string">@"Continue"</span>, <span class="literal">nil</span>];</div><div class="line">    <span class="keyword">void</span> (^block)(<span class="built_in">NSInteger</span>) = ^(<span class="built_in">NSInteger</span> buttonIndex) &#123;</div><div class="line">        <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> doCancel];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [<span class="keyword">self</span> doContinue];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    objc_setAssociatedObject(alertView, alertViewBlockKey, block, OBJC_ASSOCIATION_COPY);</div><div class="line">    [alertView show];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// UIAlertViewDelegate protocol method</span></div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)alertView:(<span class="built_in">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^block)(<span class="built_in">NSInteger</span>) = objc_getAssociatedObject(alertView, alertViewBlockKey);</div><div class="line">    block(buttonIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《<a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">associated-objects</a>》</li>
<li>《Effective Objective-C 2.0》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Objective-C/">Objective-C</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-understanding-kvo" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/29/understanding-kvo/" class="article-date">
  	<time datetime="2015-04-29T02:00:01.000Z" itemprop="datePublished">2015-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/29/understanding-kvo/">深入理解KVO</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>程序设计语言中有各种各样的设计模式（pattern）和与此对应的反设计模式（anti-pattern），譬如singleton、factory、observer、MVC等等。对于基于Objective-C的iOS开发而言，有些设计模式几乎已经成为开发环境的一部分，譬如MVC，自打我们设计第一个页面开始就已经开始与之打交道了；KVO，即Key-Value Observing（根据我的理解它属于observer设计模式）也一样，只是它已经成为Objective-C事实标准了，作为一个iOS开发者，必须对它有相当的了解。</p>
<p>之前对KVO的了解仅限于使用层面，没有去想过它是如何实现的，更没有想过它会存在一些坑；甚至在刚接触它时，会尽可能创造机会使用它，譬如监听<code>UITextField#text</code>值的变化；但近几天接触了Objective-C的Runtime相关的知识，从Runtime层面了解到了KVO的实现原理（即KVO的消息转发机制），也通过阅读各位大神的博客了解到了它的坑。</p>
<p>本文首先分析KVO和Runtime的关系，阐述KVO的实现原理；然后结合大神们的博客整理KVO存在的坑以及避免掉坑的正确使用姿势。</p>
<h2 id="KVO和Runtime"><a href="#KVO和Runtime" class="headerlink" title="KVO和Runtime"></a>KVO和Runtime</h2><p>关于KVO，即Key-Value Observing，官方文档《Key-Value Observing Programming Guide》里的介绍比较简短明了：</p>
<blockquote>
<p>Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects.</p>
</blockquote>
<p><strong>KVO的实现</strong></p>
<p>KVO的实现也依赖于Objective-C的Runtime，官方文档《Key-Value Observing Programming Guide》中在《<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">Key-Value Observing Implementation Details</a>》部分简单提到它的实现：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling.<br>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.<br>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.<br>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
</blockquote>
<p>简单概述下KVO的实现：<br>当你观察一个对象（称该对象为<strong>被观察对象</strong>）时，一个新的类会动态被创建。这个类继承自<strong>被观察对象</strong>所对应类的，并重写该被观察属性的setter方法；针对setter方法的重写无非是在赋值语句前后加上相应的通知（或曰方法调用）；最后，把被观察对象的<code>isa</code>指针（<code>isa</code>指针告诉Runtime系统这个对象的类是什么）指向这个新创建的中间类，对象就神奇变成了新创建类的实例。</p>
<p>根据文档的描述，虽然被观察对象的<code>isa</code>指针被修改了，但是调用其<code>class</code>方法得到的类信息仍然是它之前所继承类的类信息，而不是这个新创建类的类信息。</p>
<p>补充：下面对<code>isa</code>指针和类方法<code>class</code>作以更多的说明。</p>
<p><code>isa</code>指针和类方法<code>class</code>的返回值都是<code>Class</code>类型，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">+ (Class)<span class="keyword">class</span>;</div></pre></td></tr></table></figure>
<p>根据我的理解，一般情况下，<code>isa</code>指针和<code>class</code>方法返回值都是一样的；但KVO底层实现时，动态创建的类只是重写了被观察属性的setter方法，并未重写类方法<code>class</code>，因此向被观察者发送<code>class</code>消息实际上仍然调用的是被观察者原先类的类方法<code>+(Class)class</code>，得到的类型信息当然是原先类的类信息，根据我的猜测，<code>isKindOfClass:</code>和<code>isMemberOfClass:</code>与<code>class</code>方法紧密相关。</p>
<p>国外的大神Mike Ash早在2009年就做了关于KVO的实现细节的探究，更多详细参考<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">这里</a>。</p>
<h2 id="KVO的槽点"><a href="#KVO的槽点" class="headerlink" title="KVO的槽点"></a>KVO的槽点</h2><p>AFNetworking作者Mattt Thompson在《<a href="http://nshipster.com/key-value-observing/" target="_blank" rel="external">Key-Value Observing</a>》中说：</p>
<blockquote>
<p>Ask anyone who’s been around the NSBlock a few times: Key-Value Observing has the worst API in all of Cocoa.</p>
</blockquote>
<p>另一位不认识的大神在《<a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a>》中也写道：</p>
<blockquote>
<p>KVO, or key-value observing, is a pattern that Cocoa provides for us for subscribing to changes to the properties of other objects. It’s hands down the most poorly designed API in all of Cocoa, and even when implemented perfectly, it’s still an incredibly dangerous tool to use, reserved only for when no other technique will suffice.</p>
</blockquote>
<p>总之，两位大神都认为KVO的API非常差劲！</p>
<p>其中《<a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a>》中对KVO的槽点有比较详细的阐述，这一部分内容就取材于此。</p>
<p>为了更好说明这些槽点，假设一个应用场景：<code>ZWTableViewController</code>继承自<code>UITableViewController</code>，它现在需要做一件事情，即监测<code>self.tableView.contentSize</code>的变化，现采用典型的方式（即KVO）处理这么个需求。</p>
<p><strong>所有的observe处理都放在一个方法里</strong></p>
<p>实现上述「监测<code>self.tableView.contentSize</code>的变化」的需求，最基本处理方式是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// register observer</span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    [_tableView addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"contentSize"</span> options:<span class="number">0</span> context:<span class="literal">NULL</span>];</div><div class="line">    <span class="comment">/* ... */</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// 处理observe</span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> configureView];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但考虑到<code>observeValueForKeyPath:ofObject:change:context:</code>中可能会很多其他的observe事务，所以<code>observeValueForKeyPath:ofObject:change:context:</code>更好的逻辑是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class="string">@"contentSize"</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> configureView];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但如果KVO处理的事情种类多且繁杂，这会造成<code>observeValueForKeyPath:ofObject:change:context:</code>代码特别长，极不优雅。</p>
<p><strong>严重依赖于string</strong></p>
<p>KVO严重依赖string，换句话说，KVO中的keyPath必须是<code>NSString</code>这个事实使得编译器没办法在编译阶段将错误的keyPath给找出来；譬如很容易将「contentSize」写成「contentsize」；</p>
<p><strong>需要自己处理superclass的observe事务</strong></p>
<p>对于Objective-C，很多时候Runtime系统都会自动帮助处理superclass的方法。譬如对于<code>dealloc</code>，假设类<code>Father</code>继承自<code>NSObject</code>，而类<code>Son</code>继承自<code>Father</code>，创建一个<code>Son</code>的实例<code>aSon</code>，在<code>aSon</code>被释放的时候，Runtime会先调用<code>Son#dealloc</code>，之后会自动调用<code>Father#dealloc</code>，而无需在<code>Son#dealloc</code>中显式执行<code>[super dealloc];</code>。但KVO不会这样，所以为了保证父类（父类可能也会自己observe事务要处理）的observe事务也能被处理，上述<code>observeValueForKeyPath:ofObject:change:context:</code>代码得改成这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class="string">@"contentSize"</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> configureView];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>多次相同的remove observer会导致crash</strong></p>
<p>写过KVO代码的人都知道，对同一个对象执行两次remove observer操作会导致程序crash。</p>
<p>在同一个文件中执行两次相同的remove observer属于粗心，比较容易debug出来；但是跨文件执行两次相同的remove observer就不是那么容易发现了。</p>
<p>我们一般会在<code>dealloc</code>中进行remove observer操作（这也是Apple所推荐的）。</p>
<p>譬如，假设上述的<code>ZWTableViewController</code>的父类<code>UITableViewController</code>也对<code>tableView.contentSize</code>注册了相同的监听；那么<code>UITableViewController#dealloc</code>中常常会写出如下这样的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[_tableView removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"contentSize"</span> context:<span class="literal">NULL</span>];</div></pre></td></tr></table></figure>
<p>按照一般习惯，<code>ZWTableViewController#dealloc</code>也会有相同的处理；那么当<code>ZWTableViewController</code>对象被释放时，<code>ZWTableViewController</code>的<code>dealloc</code>和其父类<code>UITableViewController</code>的<code>dealloc</code>都被调用，这样会导致相同的remove observer被执行两次，自然会导致crash。</p>
<p>《<a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a>》中还有很多其他的槽点，《<a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html" target="_blank" rel="external">Key-Value Observing Done Right</a>》也描述了一些，这里就不多说了，更多信息还是建议看原文。</p>
<p>不过好在上述的槽点「严重依赖于string」和「多次相同的remove observer会导致crash」有比较好的解决方案，如下会讲到。</p>
<h2 id="使用KVO"><a href="#使用KVO" class="headerlink" title="使用KVO"></a>使用KVO</h2><p>这一部分将阐述KVO的使用方法。</p>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>KVO中与订阅相关的API只有一个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure>
<p>对于这四个参数：</p>
<ul>
<li><strong>observer</strong>: The object to register for KVO notifications. The observer must implement the key-value observing method <code>observeValueForKeyPath:ofObject:change:context:</code>.</li>
<li><strong>keyPath</strong>: The key path, relative to the receiver, of the property to observe. This value must not be nil.</li>
<li><strong>options</strong>: A combination of the NSKeyValueObservingOptions values that specifies what is included in observation notifications. For possible values, see <code>NSKeyValueObservingOptions</code>.</li>
<li><strong>context</strong>: Arbitrary data that is passed to observer in <code>observeValueForKeyPath:ofObject:change:context:</code>.</li>
</ul>
<p>大神们认为这个API丑陋的重要原因是因为后面两个参数：options和context。</p>
<p>下面来对这两个参数进行详细介绍。</p>
<p>首先是<strong>options</strong>。options可选值是一个<code>NSKeyValueObservingOptions</code>枚举值，到目前为止，一共包括四个值，在介绍这四个值各自表示的意思之前，先得有一个概念，即KVO响应方法有一个<code>NSDictionary</code>类型参数change（下面<strong>响应</strong>中可以看到），这个字典中会有一个与被监听属性相关的值，譬如被改变之前的值、新值等，<code>NSDictionary</code>中有啥值由订阅时的options值决定，options可取值如下：</p>
<ul>
<li><code>NSKeyValueObservingOptionNew</code>: 指示change字典中包含新属性值；</li>
<li><code>NSKeyValueObservingOptionOld</code>: 指示change字典中包含旧属性值；</li>
<li><code>NSKeyValueObservingOptionInitial</code>: 相对复杂一些，NSKeyValueObserving.h文件中有详细说明，此处略过；</li>
<li><code>NSKeyValueObservingOptionPrior</code>: 相对复杂一些，NSKeyValueObserving.h文件中有详细说明，此处略过；</li>
</ul>
<p>现在细想，options这个参数也忒复杂了，难怪大神们觉得这个API丑陋（不过我等小民之前从未想过这个问题，=_=，没办法，Apple是个大帝国，我只是其中一个跪舔的小屁民）。</p>
<p>不过更糟心的是下面的context参数。</p>
<p>options信息量稍大，但其实蛮好理解的，然而对于context，在写这篇博客之前，一直不知道context参数有啥用（也没在意）。</p>
<p>context作用大了去了，在上面的<strong>KVO的槽点</strong>中提到一个槽点「多次相同的remove observer会导致crash」。导致「多次调用相同的remove observer」一个很重要的原因是我们经常在add observer时为context参数赋值<code>NULL</code>，关于如何使用context参数，下面会提到。</p>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>iOS的UI交互（譬如<code>UIButton</code>的一次点击）有一个非常不错的消息转发机制 – Target-Action模型，简单来说，为指定的event指定target和action处理方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span> *button = [<span class="built_in">UIButton</span> new];</div><div class="line">[button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buttonDidClicked:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>
<p>这种target-action模型逻辑非常清晰。作为对比，KVO的响应处理就非常糟糕了，所有的响应都对应是同一个方法<code>observeValueForKeyPath:ofObject:change:context:</code>，其原型如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure>
<p>除了<code>NSDictionary</code>类型参数change之外，其余几个参数都能在<code>addObserver:forKeyPath:options:context:</code>找到对应。</p>
<p>change参数上文已经讲过了，这里不多说了。下面将针对「严重依赖于string」和「多次相同的remove observer会导致crash」这两个槽点对keyPath和context参数进行阐述。</p>
<p><strong>keyPath</strong>。keyPath的类型是<code>NSString</code>，这导致了我们使用了错误的keyPath而不自知，譬如将<code>@&quot;contentSize&quot;</code>错误写成<code>@&quot;contentsize&quot;</code>，一个更好的方法是不直接使用<code>@&quot;xxxoo&quot;</code>，而是积极使用<code>NSStringFromSelector(SEL aSelector)</code>方法，即改<code>@&quot;contentSize&quot;</code>为<code>NSStringFromSelector(@selector(contentSize))</code>。</p>
<p><strong>context</strong>。对于context，上文已经提到一种场景：假如父类（设为<code>ClassA</code>）和子类（设为<code>ClassB</code>）都监听了同一个对象肿么办？是<code>ClassB</code>处理呢还是交给父类<code>ClassA</code>的<code>observeValueForKeyPath:ofObject:change:context:</code>处理呢？更复杂一点，如果子类的子类（设为<code>ClassC</code>）也监听了同一个对象，当<code>ClassB</code>接收到<code>ClassC</code>的<code>[super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</code>消息时又该如何处理呢？</p>
<p>这么一想，KVO的API还真的是设计非常糟糕。一般来说，比较靠谱的做法是自己的屁股自己擦。<code>ClassB</code>的observe事务在<code>ClassB</code>中处理，怎么知道是自己的事务还是<code>ClassC</code>传上来的事务呢？用context参数判断！</p>
<p>在add observer时为context参数设置一个独一无二的值即可，在responding处理时对这个context值进行检验。如此就解决了问题，但这需要靠用户（各个层级类的程序员用户）自觉遵守。</p>
<h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><p>和<strong>订阅</strong>以及<strong>响应</strong>不同，取消订阅有两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context;</div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div></pre></td></tr></table></figure>
<p>个人觉得应该尽可能使用第一个方法，保持「订阅-响应-取消订阅」的一致性嘛，养成好习惯！</p>
<p>此外，为了避免取消订阅时造成的crash，可以把取消订阅代码放在<code>@try-@catch</code>语句中，如下是一个比较全面的的KVO使用示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> * zwContentSize = &amp;zwContentSize;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">// 1. subscribe</span></div><div class="line">    [_tableView addObserver:<span class="keyword">self</span></div><div class="line">                 forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(contentSize))</div><div class="line">                    options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">                    context:zwContentSize];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// 2. responding</span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    <span class="keyword">if</span> (context == zwContentSize) &#123;</div><div class="line">        <span class="comment">// configure view</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    <span class="keyword">@try</span> &#123;</div><div class="line">        <span class="comment">// 3. unsubscribe</span></div><div class="line">        [_tableView removeObserver:<span class="keyword">self</span></div><div class="line">                        forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(contentSize))</div><div class="line">                           context:zwContentSize];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总之，KVO很强大，但也挺坑，使用它要养成好习惯，避免入坑！</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《Key-Value Observing Programming Guide》</li>
<li>《<a href="http://tech.glowing.com/cn/implement-kvo/" target="_blank" rel="external">如何自己动手实现KVO</a>》</li>
<li>《<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">KVO Implementation</a>》</li>
<li>《<a href="https://www.mikeash.com/pyblog/friday-qa-2010-11-6-creating-classes-at-runtime-in-objective-c.html" target="_blank" rel="external">Creating Classes at Runtime in Objective-C</a>》</li>
<li>《<a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html" target="_blank" rel="external">Key-Value Observing Done Right</a>》</li>
<li>《<a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a>》；</li>
<li>《<a href="http://nshipster.com/key-value-observing/" target="_blank" rel="external">Key-Value Observing</a>》</li>
<li>《<a href="http://objccn.io/issue-7-3/" target="_blank" rel="external">KVC和KVO</a>》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVO/">KVO</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>