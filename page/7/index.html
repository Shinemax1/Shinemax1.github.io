<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/7/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.67px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 15px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 18.33px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.67px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 20px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 13.33px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 16.67px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.67px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/Transition/" style="font-size: 13.33px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/js基础/" style="font-size: 10px;">js基础</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，Android开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-uiwebview-load-local-html" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/16/uiwebview-load-local-html/" class="article-date">
  	<time datetime="2015-06-16T08:38:39.000Z" itemprop="datePublished">2015-06-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/16/uiwebview-load-local-html/">UIWebView加载本地HTML文件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>写本文的原因是今天被要求「调研在iOS中加载本地HTML的相关技术」，好记性不如烂笔头，将一些东西给记录下来吧。</p>
<p>应用场景是这样的：手头的iOS App有一部分UI需要使用HTML完成，好处是这部分UI可以更灵活，即可以在任何不需要升级App的情况下更新这部分UI（包括样式、操作等等）。当下非常火的技术 – Facebook的React Native – 正是用来解决这种问题的，毕竟在传统的开发模式下，更新UI必须要升级App，而升级App是一个非常耗时的过程。使用Web App部分代替Native App已经成为当下移动客户端开发的一种思潮了。为了简便起见，也为了不给项目的接盘者制造更高的门槛，暂时决定不使用React Native（原因是多方面的）等著名框架去这种事情，从0开始探究。话说胡来，也许走了这么一遭之后，以后学习React Native会有更多的体会呢！</p>
<p>总之，目前的构想是这样的：</p>
<ol>
<li>App部分UI是由HTML+JS+CSS完成的，HTML+JS+CSS代码会随着App一起发布；</li>
<li>当后端决定更新App的部分UI（HTML）时，客户端从服务器下载最新的HTML+JS+CSS包，解压后代替本地的、旧的HTML+JS+CSS资源，将最新的呈现给用户，至此完成UI的更新；</li>
</ol>
<p>因此有这么些问题需要考虑：</p>
<ol>
<li>加载本地HTML+JS+CSS资源（在iOS中，通常使用UIWebView）；</li>
<li>解压从服务端下载的压缩文件（HTML+JS+   CSS包）；</li>
<li>JS代码和OC代码的互相调用；</li>
</ol>
<p>本文主要探究第一个问题！</p>
<h2 id="UIWebView介绍"><a href="#UIWebView介绍" class="headerlink" title="UIWebView介绍"></a>UIWebView介绍</h2><p>UIWebView是iOS中一个非常常用的控件，是内置的浏览器控件，可能也是最强大复杂的控件。可以用它来浏览网页、打开文档（譬如PDF文档）等等。</p>
<p>UIWebView既可以用来显示本地文档，也可以用来显示网络文档。无论是显示本地文件还是网络文件，此过程都可以统称为「加载」。与「加载」相关的方法不多，只有三个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Loading Local Content or Loading Content From the Network</span></div><div class="line">- (<span class="keyword">void</span>)loadRequest:(<span class="built_in">NSURLRequest</span> *)request;</div><div class="line">    </div><div class="line"><span class="comment">// 嵌入HTML结构的字符串</span></div><div class="line">- (<span class="keyword">void</span>)loadHTMLString:(<span class="built_in">NSString</span> *)string</div><div class="line">               baseURL:(<span class="built_in">NSURL</span> *)baseURL;</div><div class="line">    </div><div class="line"><span class="comment">// Loading Local Content</span></div><div class="line">- (<span class="keyword">void</span>)loadData:(<span class="built_in">NSData</span> *)data</div><div class="line">        MIMEType:(<span class="built_in">NSString</span> *)MIMEType</div><div class="line">textEncodingName:(<span class="built_in">NSString</span> *)textEncodingName</div><div class="line">         baseURL:(<span class="built_in">NSURL</span> *)baseURL;</div></pre></td></tr></table></figure>
<p>与UIWebView相关的知识点并不多（从某种角度来看，也可以认为是Apple封装得比较好吧），除了上述的三个方法之外，还有必要了解的是UIWebViewDelegate定义的一些delegate方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开始加载前调用</span></div><div class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line"> navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType;</div><div class="line"><span class="comment">// 开始加载时调用</span></div><div class="line">- (<span class="keyword">void</span>)webViewDidStartLoad:(<span class="built_in">UIWebView</span> *)webView;</div><div class="line"><span class="comment">// 加载成功时调用</span></div><div class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView;</div><div class="line"><span class="comment">// 加载失败时调用</span></div><div class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">UIWebView</span> *)webView didFailLoadWithError:(<span class="built_in">NSError</span> *)error;</div></pre></td></tr></table></figure>
<p>除此之外，UIWebView似乎有啥其他需要了解的内容，若有需要，以后再补充吧！</p>
<h2 id="加载本地HTML文件"><a href="#加载本地HTML文件" class="headerlink" title="加载本地HTML文件"></a>加载本地HTML文件</h2><p>加载本地HTML文件不是多么难的事情，但再简单的事情也有一个1-2-3-4，不是嘛？何况笔者比较笨，参考<a href="http://blog.csdn.net/kaitiren/article/details/17115085" target="_blank" rel="external">UIWebView加载本地HTML5文件</a>，也分几个步骤：</p>
<ol>
<li>准备HTML文件及其资源文件（主要是CSS文件和JS文件以及image文件）；</li>
<li>加载本地HTML文件；</li>
</ol>
<p>第一种：<br>loadRequest:<br>第二种：<br>loadHTMLString:baseURL:</p>
<p><strong>第一步，准备HTML文件及其资源文件。</strong></p>
<p>HTML及其资源文件比较容易获取，随便找个比较漂亮的web页面，将它保存起来即可！</p>
<p>显然HTML文件及其资源文件是需要添加到工程的，问题是如何添加呢？如何组织管理这些文件呢？沙盒？Bundle？</p>
<p><strong>Xcode工程添加文件有两种方式</strong></p>
<p>向项目中添加已有的文件（或资源文件，或第三方库）不是什么稀罕的事情，只是平时都没怎么注意。实际上，将「文件」或者「目录」添加到项目时，Xcode给了我们两个选项：Create groups以及Create folder references，如下图：</p>
<div class="imagediv" style="width: 730px; height: 126px;"></div>

<p>简单来说，若选择Create groups的方式添加文件夹，则文件夹的颜色是黄色的；若选择Create folder references的，则发现添加的文件夹在工程目录中的的颜色是蓝色的：</p>
<div class="imagediv" style="width: 400px; height: 120px;"></div>

<p>当然不只是颜色上的区别！主要是Xcode对加入的文件的路径处理不一样。</p>
<p>如果文件/文件夹以Create groups的方式添加到工程中，则不管加入项目的文件的目录结构如何，在APP中都可以通过mainBundlePath/filename这样结构来访问文件；反之，若文件/文件夹以Create folder references的方式添加到工程中，则会保留相对路径，访问文件的结构就变成了mainBundlePath/path/filename。</p>
<p>理解Create groups以及Create folder references并不难，自己动手试试就能感受二者的不同了。</p>
<p><strong>Bundle介绍</strong></p>
<p>上文谈到了向工程添加文件的两种方式，由此延伸，不得不提bundle，一直以来对bundle的理解非常模糊，知道它的本质是一个目录，也知道在OS X中就有此概念，但一直没get到<code>bundle</code>的存在意义，总感觉它没必要存在，事实上也没主动使用它。</p>
<p>借撰写本文这个机会，驱动一下自己，查查资料，争取对bundle理解更深入一点点吧！</p>
<p>参考《<a href="http://avatar-matrix.lofter.com/post/e4689_236e82" target="_blank" rel="external">Bundle in iOS</a>》和《<a href="http://www.cnblogs.com/BigPolarBear/archive/2012/03/28/2421802.html" target="_blank" rel="external">iOS开发里的Bundle是个啥玩意</a>》。</p>
<p>简单地讲，bundle就是一个内部结构按照标准规则组织的特殊目录，常用来存放一些资源文件，譬如图片，plist文件等，它不会成为编译的一部分，所以它不存放能够被编译的文件，譬如<code>.m</code>、<code>.h</code>文件等。</p>
<p>Bundle的主要用途是软件的国际化，想象一个应用场景：软件有美国、中国版本，软件的logo等图片不同，这时候，我们把相应的图片资源放到一个文件夹下，然后修改文件夹的名字，以<code>.bundle</code>作为后缀，然后添加到xcode中。</p>
<p>有过iOS开发经历的人都应该知道，每个project都有个mainBundle，那如何去获取自己定义的bundle内容呢？我们把自定义的bundle当成项目的一种资源，由mainBundle去获取<code>~</code>，然后我们用相同的方式获取自定义的bundle下的资源。即：</p>
<p>1、通过mainBundle去加载自定义的bundle；<br>2、通过获取到的自定义bundle去获取资源；</p>
<p>根据上述场景来写的demo项目结构如下：</p>
<div class="imagediv" style="width: 340px; height: 280px;"></div>

<p>此时，我容易联想到了在Windows世界经常使用的「汉化包」。根据我的理解，我们通过某种手段得到的「汉化包」和本文所谈及的bundle是类似的概念，它们的本质是一个目录，只是这个目录有些特别，特别之处在于它只存放一些资源文件，以及目录名后缀为<code>.bundle</code>，这让它看起来像个文件，但实际上又不是文件，开发者又特别想让普通用户以为它是一个文件…</p>
<p>总之，bundle就是这么个东东。</p>
<p>到了这里，应该弄清楚了该把HTML文件及其资源放在哪里了。</p>
<p>沙盒？显然不可能，沙盒可是App到设备之后才有的概念；所以我们只能让HTML资源成为工程的一部分呢，编译打包时作为安装包的一部分。</p>
<p>放在普通目录下还是组织成bundle，个人以为没必要组织成bundle，因为后者主要用来处理国际化问题，国际化问题面对的一般是图片资源、字符串资源等等，所以不需要组成成bundle，而是直接添加到工程的mainBundle中。</p>
<p>上文已经提到了Xcode工程添加文件有两种方式：Create groups和Create folder references，个人以为应该选择后者！</p>
<p>值得注意是，当被加入到项目中的文件包含js文件时，有可能因为操作不慎等原因，js文件成为了编译文件，若是这样，应该将它从<code>Compile Sources</code>给踢掉，让它成为<code>Copy Bundle Resources</code>的一部分，具体做法是在TARGETS-&gt;Build Phases中的<code>Compile Sources</code>中找到该js文件，并将其移到<code>Copy Bundle Resources</code>中，如下图所示：</p>
<div class="imagediv" style="width: 699px; height: 364px;"></div>

<p><strong>第二步，加载本地HTML。</strong></p>
<p>本文示例中，HTML文件及其资源文件被组织在一个叫<code>html</code>的目录中，目录结构如下图，index.html是要被加载的目标文件，index.html中访问css、js以及图片资源的方式都是使用相对路径，实现代码也给展示在下图中。</p>
<div class="imagediv" style="width: 926px; height: 400px;"></div>

<p>上图右侧代码区域加载策略是，先获取本地HTML文本，转为字符串，然后使用<code>loadHTMLString:baseURL:</code>方法加载；当然也可以使用<code>loadRequest:</code>方法，哪个更好？我暂时也不知道！</p>
<p><strong>关于baseURL</strong></p>
<p>上文<code>loadHTMLString:baseURL:</code>方法的第二个参数是baseURL，baseURL是HTML字符串中引用到资源的查找路径，当HTML中没有引用外部资源时，可以指定为<code>nil</code>；若引用了外部资源，一般情况下使用mainBundle的路径即可。在实际操作中，常常会出现「文本显示正常，图片无法显示」等情况，若HTML文本中引用外部资源都是使用相对路径，则出现这种问题的原因一般都是baseURL参数错误（有时甚至是<code>nil</code>）。</p>
<p>最后，本文的Demo详见<a href="https://github.com/sadjason/iOSDemos/tree/master/UIWebView%E9%9D%9E%E5%88%9D%E4%BD%93%E9%AA%8C" target="_blank" rel="external">这里</a>。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UIWebView/">UIWebView</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pragma" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/29/pragma/" class="article-date">
  	<time datetime="2015-04-29T08:12:35.000Z" itemprop="datePublished">2015-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/29/pragma/">预处理指令#pragma</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="pragma介绍"><a href="#pragma介绍" class="headerlink" title="#pragma介绍"></a>#pragma介绍</h2><p><code>#pragma</code>是一个预处理指令，pragma的中文意思是『编译指示』。它不是Objective-C中独有的东西（貌似在C/C++中使用比较多），最开始的设计初衷是为了保证代码在不同编译器之间的兼容性，但随着时间推移，它出现在了更多更丰富的应用场景中。</p>
<p><code>#pragma</code>代码是在编译期间处理的；它既不属于注释，也不属于逻辑代码的一部分；并且它和其他预处理命令譬如<code>#ifdef ... #endif</code>不同，它不会影响代码在运行时的逻辑处理，所以<code>#pragma</code>指令丝毫不会影响到程序在运行时的性能。根据Mattt Thompson大神的描述，在当前Xcode开发环境中，<code>#pragma</code>主要有两个应用场景：组织代码和屏蔽编译警告。</p>
<h2 id="pragma-mark组织代码"><a href="#pragma-mark组织代码" class="headerlink" title="#pragma mark组织代码"></a>#pragma mark组织代码</h2><p>组织代码是个人卫生问题，个人卫生不好（代码组织不好）不能反映人品（技术能力），但它在某种程度中影响了别人是否愿意和他搞基（合作）。在一个项目（尤其是多人合作的项目）中，应该有一个比较好的内部一致性编码习惯，不好的习惯或者缺乏一致性，会使得项目难以维持，协作也不便（这点笔者深有体会，笔者目前的项目有一个同事，编码能力尚可，但编码习惯实在太糟糕，代码紧凑，从来不空格，更妄谈空行和注释了，甚至经常不对齐，看他的代码，一点修改的欲望都没有，想的只是自己重写一遍=_=）。</p>
<p>在组织代码时充分使用<code>#pragma mark</code>就是写出『干净代码』的一个重要环节，就像这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - UIViewController</span></div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">#pragma mark - IBAction</span></div><div class="line">    </div><div class="line">- (<span class="keyword">IBAction</span>)loginNow:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">#pragma mark - UITableViewDataSource</span></div><div class="line">    </div><div class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">#pragma mark - UITableViewDelegate</span></div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中使用<code>#pragma mark</code>将@implementation中的代码（方法）分成了几个逻辑section，这种处理并没有改变程序逻辑，但我们在使用Xcode代码导航工具时可以在视觉上汲取片刻的欢愉：</p>
<div class="imagediv" style="width: 402px; height: 256px;"></div>

<p>组织N个方法为一个section的依据是什么呢？这个就见仁见智了。一般来说：</p>
<ul>
<li>将一个protocol的方法组织成一个section；</li>
<li>将target-action类型方法组织成一个section；</li>
<li>将notification相关方法组织成一个section；</li>
<li>将需要override的父类方法组成成一个section；</li>
</ul>
<h2 id="pragma屏蔽编译警告"><a href="#pragma屏蔽编译警告" class="headerlink" title="#pragma屏蔽编译警告"></a>#pragma屏蔽编译警告</h2><p>使用<code>#pragma mark</code>来组织代码使用比较普遍，相对而言，使用<code>#pragma</code>指令屏蔽编译器和静态分析器的警告相对来说就比较新鲜了。</p>
<p>You know what is even more annoying than poorly-formatted code? Code that generates warnings. 编译警告很可恶，应该尽可能修改代码干掉这些警告，但是有些时候有些警告无法避免，譬如我们在编写<code>@selector(aMethodName)</code>这样的代码时，如果aMethodName没有在上下文中出现，可能会出现含有『undeclared-selector』关键词的warning，有洁癖的程序员会想到干掉这个warning，此时<code>#pragma</code>指令就派上用场了。譬如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wundeclared-selector"</span></span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.selectedViewController respondsToSelector:<span class="keyword">@selector</span>(isReadyForEditing)]) &#123;</div><div class="line">        boolNumber = [<span class="keyword">self</span>.selectedViewController performSelector:<span class="keyword">@selector</span>(isReadyForEditing)];</div><div class="line">    &#125;</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div></pre></td></tr></table></figure>
<p>这是Clang编译器提供的一种解决方案，通过使用<code>#pragma clang diagnostic push/pop</code>来告诉编译器仅仅为某一特定部分代码（记得要在代码片段末尾使用pop将最初的diagnostic设置恢复哦）忽视特定警告。</p>
<p>上述示例中<code>#pragma clang diagnostic ignored</code>后面的<code>&quot;-Wundeclared-selector&quot;</code>指示的是『特定警告』，再别的应用场景中肿么知道该填写什么呢？网络是强大的，有一个（可能是N个）愤怒的网友对clang警告消息做了一个总结，之所以说这个网友“愤怒”，是因为其链接非常有意思：<a href="http://fuckingclangwarnings.com/。" target="_blank" rel="external">http://fuckingclangwarnings.com/。</a></p>
<p>Finally, you can read more about the LLVM’s use of #pragma in the <a href="http://clang.llvm.org/docs/UsersManual.html#diagnostics_pragmas" target="_blank" rel="external">Clang Compiler User’s Manual</a>.</p>
<p>最后，感谢大神Mattt Thompson，本文的参考资料完全来自于《<a href="http://nshipster.com/pragma/" target="_blank" rel="external">#pragma</a>》，本来想用自己的语言完成这篇博客，边读边写，最后发现几乎差不多了，没留下啥自己的东西，就这样吧！</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《<a href="http://nshipster.com/pragma/" target="_blank" rel="external">#pragma</a>》</li>
<li>《<a href="http://nshipster.com/clang-diagnostics/" target="_blank" rel="external">clang diagnostics</a>》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-associated-object" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/29/associated-object/" class="article-date">
  	<time datetime="2015-04-29T06:47:10.000Z" itemprop="datePublished">2015-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/29/associated-object/">关联对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关联对象概述"><a href="#关联对象概述" class="headerlink" title="关联对象概述"></a>关联对象概述</h2><p>Objective—C作为一门动态语言，它本身有一个非常大的弱点，即不能在类的category中方便地为类添加新的自定义属性。「关联对象」（Associated Objects）或曰「关联引用」（Associative References）是基于Objective-C 2.0的一个Runtime特性，它使得可以在Runtime为某个类对象绑定一个对象（通过简单的封装，可以让这个关联属性在使用上和普通属性有类似的体验）。</p>
<p>P.S：也可以绑定一个block。</p>
<p>与此相关有3个函数，都在<code>&lt;objc/runtime.h&gt;</code>中定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 绑定对象，类似setter</span></div><div class="line">objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy);</div><div class="line"><span class="comment">// 获取对象，类似于getter</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key);</div><div class="line"><span class="comment">// 移除绑定关系</span></div><div class="line">objc_removeAssociatedObjects(<span class="keyword">id</span> object);</div></pre></td></tr></table></figure>
<p>假设现在需要往对象A上绑定一个对象B（即B作为A的「属性」），本文称A为「宿主对象」，B为「寄生对象」，这个比喻可能不是很好，为了更简单地表述，先就这么将就着吧。</p>
<p>下面来对这三个函数进行简单的介绍！</p>
<p>上述3个函数的第一个参数都是id类型，都是指「宿主对象」；</p>
<p>objc_setAssociatedObject函数和objc_getAssociatedObject函数的第二个参数是一个整型值，笔者曾一度认为这个参数应该是一个int型指针，用来存放新创建的对象地址值（现在想来这个想法太傻逼了），Objective-C只是要求这个值是Runtime时唯一标识值即可，在实际应用中，这个值常常是static char型变量的指针，譬如这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> kAssociatedObjectKey;</div><div class="line">objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kAssociatedObjectKey);</div></pre></td></tr></table></figure>
<p>但是Mattt Thompson的作者似乎更喜欢这样使用<code>@selector()</code>生成一个指针值，<code>@selector(XXOO)</code>中的参数XXOO可以随便填，但必须得保证唯一性，且objc_setAssociatedObject和objc_getAssociatedObject中必须保持一致。</p>
<p>objc_setAssociatedObject的第三个参数即上文所述的「寄生对象」；</p>
<p>objc_setAssociatedObject的第四个参数policy描述的是「宿主对象」对「寄生对象」的<br>持有策略，有OBJC_ASSOCIATION_ASSIGN、OBJC_ASSOCIATION_RETAIN_NONATOMIC等几个值，这些值分别对应property修饰符assign、strong等。</p>
<p>对于objc_removeAssociatedObjects，注意后缀<code>s</code>，关于其说明，文档的描述是：Removes all associations for a given object. 但似乎不能直接使用它来remove关联的「寄生对象」们，文档是这么说的：</p>
<blockquote>
<p>The main purpose of this function is to make it easy to return an object to a “pristine state”. You should not use this function for general removal of associations from objects, since it also removes associations that other clients may have added to the object. Typically you should use objc_setAssociatedObject with a nil value to clear an association.</p>
</blockquote>
<p>P.S：不太看得懂第一句！</p>
<h2 id="关联对象应用场景"><a href="#关联对象应用场景" class="headerlink" title="关联对象应用场景"></a>关联对象应用场景</h2><p>对于笔者而言，关联引用的最主要应用场景就是在category中为类动态添加<strong>属性</strong>，这方面的应用场景非常非常多，本文就不赘述了。但是《Effective Objective-C 2.0》举了另外一个应用场景的例子。</p>
<p>开发iOS时经常用到UIAlertView类，该类提供了一种标准视图，可向用户展示警告信息，当用户按下按钮关闭该视图时，需要用委托协议（delegate protocol）来处理此动作，但是，要想设置好这个委托机制，就得把创建警告视图和处理按钮动作的代码分开。由于代码分作两块，所以读起来有些乱。比如说，我们在使用UIAlertView时，一般都会这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)askUserAQuestion &#123;</div><div class="line">    <span class="built_in">UIAlertView</span> *alertView = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"Question"</span></div><div class="line">                                                        message:<span class="string">@"What do you want to do?"</span></div><div class="line">                                                       delegate:<span class="keyword">self</span></div><div class="line">                                              cancelButtonTitle:<span class="string">@"Cancel"</span></div><div class="line">                                              otherButtonTitles:<span class="string">@"Continue"</span>, <span class="literal">nil</span>];</div><div class="line">    [alertView show];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// UIAlertViewDelegate protocol method</span></div><div class="line">- (<span class="keyword">void</span>)alertView:(<span class="built_in">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex &#123;</div><div class="line">    <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> doCancel];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> doContinue];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，如果在同一个ViewController中需要多次使用UIAlertView，那么UIAlertViewDelegate方法<code>- (void)alertView:clickedButtonAtIndex:;</code>的实现代码就非常复杂了，譬如会这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UIAlertViewDelegate protocol method</span></div><div class="line">- (<span class="keyword">void</span>)alertView:(<span class="built_in">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex &#123;</div><div class="line">    <span class="keyword">if</span> (alertView == <span class="keyword">self</span>.question1Alert) &#123;</div><div class="line">        <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 巴拉巴拉</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 巴拉巴拉</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alertView == <span class="keyword">self</span>.question2Alert) &#123;</div><div class="line">        <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 巴拉巴拉</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 巴拉巴拉</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alertView == <span class="keyword">self</span>.question3Alert) &#123;</div><div class="line">        <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 巴拉巴拉</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 巴拉巴拉</span></div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要是在创建UIAlertView对象时就把相关的处理逻辑写好，那就简单多了。这可以通过关联对象来处理。简单来说，就是创建UIAlertView对象完成后，对其关联一个block，而在<code>alertView:clickedButtonAtIndex:</code>调用这个block即可。此方案的实现代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line">    </div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *alertViewBlockKey = &amp;alertViewBlockKey;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)askUserAQuestion &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">UIAlertView</span> *alertView = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"Question"</span></div><div class="line">                                                        message:<span class="string">@"What do you want to do?"</span></div><div class="line">                                                       delegate:<span class="keyword">self</span></div><div class="line">                                              cancelButtonTitle:<span class="string">@"Cancel"</span></div><div class="line">                                              otherButtonTitles:<span class="string">@"Continue"</span>, <span class="literal">nil</span>];</div><div class="line">    <span class="keyword">void</span> (^block)(<span class="built_in">NSInteger</span>) = ^(<span class="built_in">NSInteger</span> buttonIndex) &#123;</div><div class="line">        <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> doCancel];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [<span class="keyword">self</span> doContinue];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    objc_setAssociatedObject(alertView, alertViewBlockKey, block, OBJC_ASSOCIATION_COPY);</div><div class="line">    [alertView show];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// UIAlertViewDelegate protocol method</span></div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)alertView:(<span class="built_in">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^block)(<span class="built_in">NSInteger</span>) = objc_getAssociatedObject(alertView, alertViewBlockKey);</div><div class="line">    block(buttonIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《<a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">associated-objects</a>》</li>
<li>《Effective Objective-C 2.0》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Objective-C/">Objective-C</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-understanding-kvo" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/29/understanding-kvo/" class="article-date">
  	<time datetime="2015-04-29T02:00:01.000Z" itemprop="datePublished">2015-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/29/understanding-kvo/">深入理解KVO</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>程序设计语言中有各种各样的设计模式（pattern）和与此对应的反设计模式（anti-pattern），譬如singleton、factory、observer、MVC等等。对于基于Objective-C的iOS开发而言，有些设计模式几乎已经成为开发环境的一部分，譬如MVC，自打我们设计第一个页面开始就已经开始与之打交道了；KVO，即Key-Value Observing（根据我的理解它属于observer设计模式）也一样，只是它已经成为Objective-C事实标准了，作为一个iOS开发者，必须对它有相当的了解。</p>
<p>之前对KVO的了解仅限于使用层面，没有去想过它是如何实现的，更没有想过它会存在一些坑；甚至在刚接触它时，会尽可能创造机会使用它，譬如监听<code>UITextField#text</code>值的变化；但近几天接触了Objective-C的Runtime相关的知识，从Runtime层面了解到了KVO的实现原理（即KVO的消息转发机制），也通过阅读各位大神的博客了解到了它的坑。</p>
<p>本文首先分析KVO和Runtime的关系，阐述KVO的实现原理；然后结合大神们的博客整理KVO存在的坑以及避免掉坑的正确使用姿势。</p>
<h2 id="KVO和Runtime"><a href="#KVO和Runtime" class="headerlink" title="KVO和Runtime"></a>KVO和Runtime</h2><p>关于KVO，即Key-Value Observing，官方文档《Key-Value Observing Programming Guide》里的介绍比较简短明了：</p>
<blockquote>
<p>Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects.</p>
</blockquote>
<p><strong>KVO的实现</strong></p>
<p>KVO的实现也依赖于Objective-C的Runtime，官方文档《Key-Value Observing Programming Guide》中在《<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">Key-Value Observing Implementation Details</a>》部分简单提到它的实现：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling.<br>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.<br>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.<br>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
</blockquote>
<p>简单概述下KVO的实现：<br>当你观察一个对象（称该对象为<strong>被观察对象</strong>）时，一个新的类会动态被创建。这个类继承自<strong>被观察对象</strong>所对应类的，并重写该被观察属性的setter方法；针对setter方法的重写无非是在赋值语句前后加上相应的通知（或曰方法调用）；最后，把被观察对象的<code>isa</code>指针（<code>isa</code>指针告诉Runtime系统这个对象的类是什么）指向这个新创建的中间类，对象就神奇变成了新创建类的实例。</p>
<p>根据文档的描述，虽然被观察对象的<code>isa</code>指针被修改了，但是调用其<code>class</code>方法得到的类信息仍然是它之前所继承类的类信息，而不是这个新创建类的类信息。</p>
<p>补充：下面对<code>isa</code>指针和类方法<code>class</code>作以更多的说明。</p>
<p><code>isa</code>指针和类方法<code>class</code>的返回值都是<code>Class</code>类型，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">+ (Class)<span class="keyword">class</span>;</div></pre></td></tr></table></figure>
<p>根据我的理解，一般情况下，<code>isa</code>指针和<code>class</code>方法返回值都是一样的；但KVO底层实现时，动态创建的类只是重写了被观察属性的setter方法，并未重写类方法<code>class</code>，因此向被观察者发送<code>class</code>消息实际上仍然调用的是被观察者原先类的类方法<code>+(Class)class</code>，得到的类型信息当然是原先类的类信息，根据我的猜测，<code>isKindOfClass:</code>和<code>isMemberOfClass:</code>与<code>class</code>方法紧密相关。</p>
<p>国外的大神Mike Ash早在2009年就做了关于KVO的实现细节的探究，更多详细参考<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">这里</a>。</p>
<h2 id="KVO的槽点"><a href="#KVO的槽点" class="headerlink" title="KVO的槽点"></a>KVO的槽点</h2><p>AFNetworking作者Mattt Thompson在《<a href="http://nshipster.com/key-value-observing/" target="_blank" rel="external">Key-Value Observing</a>》中说：</p>
<blockquote>
<p>Ask anyone who’s been around the NSBlock a few times: Key-Value Observing has the worst API in all of Cocoa.</p>
</blockquote>
<p>另一位不认识的大神在《<a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a>》中也写道：</p>
<blockquote>
<p>KVO, or key-value observing, is a pattern that Cocoa provides for us for subscribing to changes to the properties of other objects. It’s hands down the most poorly designed API in all of Cocoa, and even when implemented perfectly, it’s still an incredibly dangerous tool to use, reserved only for when no other technique will suffice.</p>
</blockquote>
<p>总之，两位大神都认为KVO的API非常差劲！</p>
<p>其中《<a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a>》中对KVO的槽点有比较详细的阐述，这一部分内容就取材于此。</p>
<p>为了更好说明这些槽点，假设一个应用场景：<code>ZWTableViewController</code>继承自<code>UITableViewController</code>，它现在需要做一件事情，即监测<code>self.tableView.contentSize</code>的变化，现采用典型的方式（即KVO）处理这么个需求。</p>
<p><strong>所有的observe处理都放在一个方法里</strong></p>
<p>实现上述「监测<code>self.tableView.contentSize</code>的变化」的需求，最基本处理方式是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// register observer</span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    [_tableView addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"contentSize"</span> options:<span class="number">0</span> context:<span class="literal">NULL</span>];</div><div class="line">    <span class="comment">/* ... */</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// 处理observe</span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> configureView];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但考虑到<code>observeValueForKeyPath:ofObject:change:context:</code>中可能会很多其他的observe事务，所以<code>observeValueForKeyPath:ofObject:change:context:</code>更好的逻辑是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class="string">@"contentSize"</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> configureView];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但如果KVO处理的事情种类多且繁杂，这会造成<code>observeValueForKeyPath:ofObject:change:context:</code>代码特别长，极不优雅。</p>
<p><strong>严重依赖于string</strong></p>
<p>KVO严重依赖string，换句话说，KVO中的keyPath必须是<code>NSString</code>这个事实使得编译器没办法在编译阶段将错误的keyPath给找出来；譬如很容易将「contentSize」写成「contentsize」；</p>
<p><strong>需要自己处理superclass的observe事务</strong></p>
<p>对于Objective-C，很多时候Runtime系统都会自动帮助处理superclass的方法。譬如对于<code>dealloc</code>，假设类<code>Father</code>继承自<code>NSObject</code>，而类<code>Son</code>继承自<code>Father</code>，创建一个<code>Son</code>的实例<code>aSon</code>，在<code>aSon</code>被释放的时候，Runtime会先调用<code>Son#dealloc</code>，之后会自动调用<code>Father#dealloc</code>，而无需在<code>Son#dealloc</code>中显式执行<code>[super dealloc];</code>。但KVO不会这样，所以为了保证父类（父类可能也会自己observe事务要处理）的observe事务也能被处理，上述<code>observeValueForKeyPath:ofObject:change:context:</code>代码得改成这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (object == _tableView &amp;&amp; [keyPath isEqualToString:<span class="string">@"contentSize"</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> configureView];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>多次相同的remove observer会导致crash</strong></p>
<p>写过KVO代码的人都知道，对同一个对象执行两次remove observer操作会导致程序crash。</p>
<p>在同一个文件中执行两次相同的remove observer属于粗心，比较容易debug出来；但是跨文件执行两次相同的remove observer就不是那么容易发现了。</p>
<p>我们一般会在<code>dealloc</code>中进行remove observer操作（这也是Apple所推荐的）。</p>
<p>譬如，假设上述的<code>ZWTableViewController</code>的父类<code>UITableViewController</code>也对<code>tableView.contentSize</code>注册了相同的监听；那么<code>UITableViewController#dealloc</code>中常常会写出如下这样的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[_tableView removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"contentSize"</span> context:<span class="literal">NULL</span>];</div></pre></td></tr></table></figure>
<p>按照一般习惯，<code>ZWTableViewController#dealloc</code>也会有相同的处理；那么当<code>ZWTableViewController</code>对象被释放时，<code>ZWTableViewController</code>的<code>dealloc</code>和其父类<code>UITableViewController</code>的<code>dealloc</code>都被调用，这样会导致相同的remove observer被执行两次，自然会导致crash。</p>
<p>《<a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a>》中还有很多其他的槽点，《<a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html" target="_blank" rel="external">Key-Value Observing Done Right</a>》也描述了一些，这里就不多说了，更多信息还是建议看原文。</p>
<p>不过好在上述的槽点「严重依赖于string」和「多次相同的remove observer会导致crash」有比较好的解决方案，如下会讲到。</p>
<h2 id="使用KVO"><a href="#使用KVO" class="headerlink" title="使用KVO"></a>使用KVO</h2><p>这一部分将阐述KVO的使用方法。</p>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>KVO中与订阅相关的API只有一个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure>
<p>对于这四个参数：</p>
<ul>
<li><strong>observer</strong>: The object to register for KVO notifications. The observer must implement the key-value observing method <code>observeValueForKeyPath:ofObject:change:context:</code>.</li>
<li><strong>keyPath</strong>: The key path, relative to the receiver, of the property to observe. This value must not be nil.</li>
<li><strong>options</strong>: A combination of the NSKeyValueObservingOptions values that specifies what is included in observation notifications. For possible values, see <code>NSKeyValueObservingOptions</code>.</li>
<li><strong>context</strong>: Arbitrary data that is passed to observer in <code>observeValueForKeyPath:ofObject:change:context:</code>.</li>
</ul>
<p>大神们认为这个API丑陋的重要原因是因为后面两个参数：options和context。</p>
<p>下面来对这两个参数进行详细介绍。</p>
<p>首先是<strong>options</strong>。options可选值是一个<code>NSKeyValueObservingOptions</code>枚举值，到目前为止，一共包括四个值，在介绍这四个值各自表示的意思之前，先得有一个概念，即KVO响应方法有一个<code>NSDictionary</code>类型参数change（下面<strong>响应</strong>中可以看到），这个字典中会有一个与被监听属性相关的值，譬如被改变之前的值、新值等，<code>NSDictionary</code>中有啥值由订阅时的options值决定，options可取值如下：</p>
<ul>
<li><code>NSKeyValueObservingOptionNew</code>: 指示change字典中包含新属性值；</li>
<li><code>NSKeyValueObservingOptionOld</code>: 指示change字典中包含旧属性值；</li>
<li><code>NSKeyValueObservingOptionInitial</code>: 相对复杂一些，NSKeyValueObserving.h文件中有详细说明，此处略过；</li>
<li><code>NSKeyValueObservingOptionPrior</code>: 相对复杂一些，NSKeyValueObserving.h文件中有详细说明，此处略过；</li>
</ul>
<p>现在细想，options这个参数也忒复杂了，难怪大神们觉得这个API丑陋（不过我等小民之前从未想过这个问题，=_=，没办法，Apple是个大帝国，我只是其中一个跪舔的小屁民）。</p>
<p>不过更糟心的是下面的context参数。</p>
<p>options信息量稍大，但其实蛮好理解的，然而对于context，在写这篇博客之前，一直不知道context参数有啥用（也没在意）。</p>
<p>context作用大了去了，在上面的<strong>KVO的槽点</strong>中提到一个槽点「多次相同的remove observer会导致crash」。导致「多次调用相同的remove observer」一个很重要的原因是我们经常在add observer时为context参数赋值<code>NULL</code>，关于如何使用context参数，下面会提到。</p>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>iOS的UI交互（譬如<code>UIButton</code>的一次点击）有一个非常不错的消息转发机制 – Target-Action模型，简单来说，为指定的event指定target和action处理方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span> *button = [<span class="built_in">UIButton</span> new];</div><div class="line">[button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buttonDidClicked:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>
<p>这种target-action模型逻辑非常清晰。作为对比，KVO的响应处理就非常糟糕了，所有的响应都对应是同一个方法<code>observeValueForKeyPath:ofObject:change:context:</code>，其原型如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure>
<p>除了<code>NSDictionary</code>类型参数change之外，其余几个参数都能在<code>addObserver:forKeyPath:options:context:</code>找到对应。</p>
<p>change参数上文已经讲过了，这里不多说了。下面将针对「严重依赖于string」和「多次相同的remove observer会导致crash」这两个槽点对keyPath和context参数进行阐述。</p>
<p><strong>keyPath</strong>。keyPath的类型是<code>NSString</code>，这导致了我们使用了错误的keyPath而不自知，譬如将<code>@&quot;contentSize&quot;</code>错误写成<code>@&quot;contentsize&quot;</code>，一个更好的方法是不直接使用<code>@&quot;xxxoo&quot;</code>，而是积极使用<code>NSStringFromSelector(SEL aSelector)</code>方法，即改<code>@&quot;contentSize&quot;</code>为<code>NSStringFromSelector(@selector(contentSize))</code>。</p>
<p><strong>context</strong>。对于context，上文已经提到一种场景：假如父类（设为<code>ClassA</code>）和子类（设为<code>ClassB</code>）都监听了同一个对象肿么办？是<code>ClassB</code>处理呢还是交给父类<code>ClassA</code>的<code>observeValueForKeyPath:ofObject:change:context:</code>处理呢？更复杂一点，如果子类的子类（设为<code>ClassC</code>）也监听了同一个对象，当<code>ClassB</code>接收到<code>ClassC</code>的<code>[super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</code>消息时又该如何处理呢？</p>
<p>这么一想，KVO的API还真的是设计非常糟糕。一般来说，比较靠谱的做法是自己的屁股自己擦。<code>ClassB</code>的observe事务在<code>ClassB</code>中处理，怎么知道是自己的事务还是<code>ClassC</code>传上来的事务呢？用context参数判断！</p>
<p>在add observer时为context参数设置一个独一无二的值即可，在responding处理时对这个context值进行检验。如此就解决了问题，但这需要靠用户（各个层级类的程序员用户）自觉遵守。</p>
<h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><p>和<strong>订阅</strong>以及<strong>响应</strong>不同，取消订阅有两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context;</div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div></pre></td></tr></table></figure>
<p>个人觉得应该尽可能使用第一个方法，保持「订阅-响应-取消订阅」的一致性嘛，养成好习惯！</p>
<p>此外，为了避免取消订阅时造成的crash，可以把取消订阅代码放在<code>@try-@catch</code>语句中，如下是一个比较全面的的KVO使用示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> * zwContentSize = &amp;zwContentSize;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">// 1. subscribe</span></div><div class="line">    [_tableView addObserver:<span class="keyword">self</span></div><div class="line">                 forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(contentSize))</div><div class="line">                    options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">                    context:zwContentSize];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// 2. responding</span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    <span class="keyword">if</span> (context == zwContentSize) &#123;</div><div class="line">        <span class="comment">// configure view</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    <span class="keyword">@try</span> &#123;</div><div class="line">        <span class="comment">// 3. unsubscribe</span></div><div class="line">        [_tableView removeObserver:<span class="keyword">self</span></div><div class="line">                        forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(contentSize))</div><div class="line">                           context:zwContentSize];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总之，KVO很强大，但也挺坑，使用它要养成好习惯，避免入坑！</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《Key-Value Observing Programming Guide》</li>
<li>《<a href="http://tech.glowing.com/cn/implement-kvo/" target="_blank" rel="external">如何自己动手实现KVO</a>》</li>
<li>《<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">KVO Implementation</a>》</li>
<li>《<a href="https://www.mikeash.com/pyblog/friday-qa-2010-11-6-creating-classes-at-runtime-in-objective-c.html" target="_blank" rel="external">Creating Classes at Runtime in Objective-C</a>》</li>
<li>《<a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html" target="_blank" rel="external">Key-Value Observing Done Right</a>》</li>
<li>《<a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a>》；</li>
<li>《<a href="http://nshipster.com/key-value-observing/" target="_blank" rel="external">Key-Value Observing</a>》</li>
<li>《<a href="http://objccn.io/issue-7-3/" target="_blank" rel="external">KVC和KVO</a>》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVO/">KVO</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-initialize-and-load-in-objective-c" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/28/initialize-and-load-in-objective-c/" class="article-date">
  	<time datetime="2015-04-28T06:14:13.000Z" itemprop="datePublished">2015-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/28/initialize-and-load-in-objective-c/">Objective-C中的+initialize和+load</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>近几天花了一些时间了解了一下Objective-C runtime相关的东西，其中涉及到了<code>+load</code>方法，譬如method swizzling通常在category的<code>+load</code>方法中完成。之前对initializer和load的使用就比较疑惑，但一直没有详细去对比了解，以此为契机，集各方资源，分析一下吧！</p>
<p>关于了解<code>+initialize</code>和<code>+load</code>，个人感觉参考官方文档《NSObject Class Reference》就够了。</p>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h2><p>关于<code>+initialize</code>方法，《NSObject Class Reference》的介绍如下：</p>
<blockquote>
<p>Initializes the class before it receives its first message.</p>
</blockquote>
<p>可以理解<code>+initialize</code>的作用是为了该Class在使用前创建合适的环境；</p>
<p>关于其使用，《NSObject Class Reference》的说明如下：</p>
<blockquote>
<p>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses. The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize].</p>
</blockquote>
<p>这上面这段话，可以得出如下这么一些意思：</p>
<ul>
<li><code>+initialize</code>方法是在runtime被调用的；</li>
<li>对于某个类，其类<code>+initialize</code>方法都会在该对象接受任何消息之前被调用；</li>
<li>如果父类和子类的<code>+initialize</code>方法都被调用，父类的调用一定在子类之前，这是系统自动完成的，子类<code>+initialize</code>中没必要显式调用<code>[super initialize];</code>；</li>
<li>runtime系统处理<code>+initialize</code>消息的方式是线程安全的，所以没必要在<code>+initialize</code>中为了保证线程安全而使用lock、mutex之类的线程安全工具；</li>
<li>某个类的<code>+initialize</code>的方法不一定只被调用一次，至少有两种情况会被调用多次：<ul>
<li>子类显式调用<code>[super initialize];</code>；</li>
<li>子类没有实现<code>+initialize</code>方法；</li>
</ul>
</li>
</ul>
<p>下面以示例演示某个类的<code>+initialize</code>被多次执行的现象。</p>
<p>定义三个类：<code>Person</code>、<code>Student</code>、<code>Teacher</code>，<code>Student</code>和<code>Teacher</code>继承自<code>Person</code>，<code>Person</code>继承自<code>NSObject</code>。<code>Person</code>和<code>Student</code>都实现了<code>+initialize</code>方法，<code>Teacher</code>没有实现该方法，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person的+initialize方法的实现</span></div><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Person initialize"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// Student的+initialize方法的实现</span></div><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Student initialize"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行效果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    Student *aStudent = [[Student alloc] init];</div><div class="line">    Teacher *aTeacher = [[Teacher alloc] init];</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/* 输出：</span></div><div class="line">Person initialize</div><div class="line">Student initialize</div><div class="line">Person initialize</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>可以看到，对于<code>Student</code>，在其<code>+initialize</code>方法被调用之前，其super class（<code>Person</code>）的<code>+initialize</code>方法被率先调用；对于<code>Teacher</code>，没有定义<code>+initialize</code>方法，所以它会直接调用super class（Person）的<code>+initialize</code>方法，这就导致了Person的<code>+initialize</code>方法被执行两次。</p>
<p>有没有办法避免<code>Person</code>的<code>+initialize</code>方法被多次调用？当然可以：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person的+initialize方法的实现</span></div><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">BOOL</span> b = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (!b) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Person initialize"</span>);</div><div class="line">        b = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person的+initialize方法的实现</span></div><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [Person <span class="keyword">class</span>]) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Person initialize"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>《NSObject Class Reference》中还对<code>+initialize</code>方法的使用做了一些警告：</p>
<blockquote>
<p>Because initialize is called in a thread-safe manner and the order of initialize being called on different classes is not guaranteed, it’s important to do the minimum amount of work necessary in initialize methods. Specifically, any code that takes locks that might be required by other classes in their initialize methods is liable to lead to deadlocks. Therefore you should not rely on initialize for complex initialization, and should instead limit it to straightforward, class local initialization.</p>
</blockquote>
<p>总结一下，就是这样：不要在<code>+initialize</code>中处理复杂的逻辑！</p>
<p>那么<code>+initialize</code>可以做些什么事情呢？可以做一些简单的初始化工作，譬如对于某个继承自<code>UICollectionViewCell</code>的自定义类<code>PhotoViewCell</code>，<code>PhotoViewCell</code>的对象可能会有一些公用资源，譬如label color，label font等等，没必要在<code>-initXXOO</code>方法中创建这些完全一样的资源，此时就可以放在<code>PhotoViewCell</code>中的<code>+initialize</code>中完成，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">    titleFont       = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12</span>];</div><div class="line">    titleHeight     = <span class="number">20.0</span>f;</div><div class="line">    videoIcon       = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CTAssetsPickerVideo"</span>];</div><div class="line">    titleColor      = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">    checkedIcon     = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CTAssetsPickerChecked"</span>];</div><div class="line">    selectedColor   = [<span class="built_in">UIColor</span> colorWithWhite:<span class="number">1</span> alpha:<span class="number">0.3</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>+initialize</code>终究还是带来惊人的信息量，颇为失望。</p>
<h2 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h2><p>关于<code>+load</code>方法，《NSObject Class Reference》的介绍如下：</p>
<blockquote>
<p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>
</blockquote>
<p>关于其使用，《NSObject Class Reference》的说明如下：</p>
<blockquote>
<p>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p>
<p>The order of initialization is as follows:</p>
<blockquote>
<ol>
<li>All initializers in any framework you link to.</li>
<li>All +load methods in your image.</li>
<li>All C++ static initializers and C/C++ <strong>attribute</strong>(constructor) functions in your image.</li>
<li>All initializers in frameworks that link to you.</li>
</ol>
</blockquote>
<p>In addition:</p>
<ul>
<li>A class’s +load method is called after all of its superclasses’ +load methods.</li>
<li>A category +load method is called after the class’s own +load method.<br>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</li>
</ul>
</blockquote>
<p>从这段文字可以读出如下信息：</p>
<ul>
<li>在一个程序（main函数）运行之前，所用到的库被加载到runtime之后，被添加到的runtime系统的各种类和category的<code>+load</code>方法就被调用；（关于这点很容易通过打印语句来验证）；</li>
<li>如果父类和子类的<code>+load</code>方法都被调用，父类的调用一定在子类之前，这是系统自动完成的，子类<code>+load</code>中没必要显式调用<code>[super load];</code>；</li>
<li>文档没有讲明<code>+load</code>的执行是否是线程安全的，但考虑到它是在runtime之前就调用，所以谈论它是否是线程安全没啥必要，根据我的理解，多线程在runtime才有谈论意义；</li>
<li>若某个类由一个主类和多个category组成，则允许主类和category中各自有自己的<code>+load</code>方法，只是category中的<code>+load</code>的执行在主类的<code>+load</code>之后；</li>
</ul>
<p>关于<code>+load</code>的使用场景，笔者知道的至少有一个，method swizzling的处理一般都在category的<code>+load</code>中完成的，参考<a href="/unstanding-objective-c-runtime-part-4/">这里</a>。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《NSObject Class Reference》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>