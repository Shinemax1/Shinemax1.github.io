<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/7/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.25px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 13.75px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 16.25px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.25px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 18.75px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 12.5px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.25px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 13.75px;">Tools</a> <a href="/tags/Transition/" style="font-size: 12.5px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 17.5px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js基础/" style="font-size: 20px;">js基础</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，Android开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-non-interactive-animation-basics-in-ios" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/13/non-interactive-animation-basics-in-ios/" class="article-date">
  	<time datetime="2016-06-13T01:35:14.000Z" itemprop="datePublished">2016-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/non-interactive-animation-basics-in-ios/">非交互式动画基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Animation-Properties"><a href="#Animation-Properties" class="headerlink" title="Animation Properties"></a>Animation Properties</h2><p>所谓的动画，其本质是物体（譬如view）的某些属性或属性组合在时间线上的变化。<a href="https://dn-motion-design.qbox.me/" target="_blank" rel="external">Motion Design for iOS</a>将这些属性总结为6种：position、opacity、color、scale、rotation、3D。</p>
<p>这种说法对iOS环境下<code>UIView</code>同样适合，<code>UIView</code>中与animation相关的属性包括：</p>
<ol>
<li><code>UIView#frame</code>/<code>UIView#center</code>/<code>UIView#bounds</code>: position</li>
<li><code>UIView#alpha</code>: alpha</li>
<li><code>UIView#backgroundColor</code>: color</li>
<li><code>UIView#transform</code>: position, scale, rotation</li>
<li><code>UIView#layer.transform</code>: 3D</li>
</ol>
<p>最后一个，<code>UIView#layer.transform</code>的类型是<code>CATransform3D</code>，能够控制layer级别的3D变换；其余几种能够控制<code>UIView</code>的2D变换，其中第4个，<code>UIView#transform</code>的类型是<code>CGAffineTransform</code>，能够控制<code>UIView</code>的平移、缩放、旋转。</p>
<p>这一部分内容着重于分析<code>CGAffineTransform</code>和<code>CATransform3D</code>，其他几个属性相对简单得多。</p>
<h2 id="Affine-Transforms"><a href="#Affine-Transforms" class="headerlink" title="Affine Transforms"></a>Affine Transforms</h2><p>国内博客在谈及<code>CGAffineTransform</code>时，常常会讲到一个词语：<strong>仿射变换</strong>，它是affine transformation的中文翻译。</p>
<p><code>CGAffineTransform</code>是个结构体类型，属于Core Graphics框架，它有6个变量：a、b、c、d、tx、ty。这6个变量和另外3个固定值构成了一个3x3矩阵，如下图：</p>
<div class="imagediv" style="width: 232px; height: 206px"></div>

<p><code>UIView</code>的本质是由像素点组成的矩形块，每个像素点的相对位置可以抽象为坐标<code>(x, y)</code>，将这个坐标称之为某像素点的<strong>原坐标</strong>，<strong>原坐标</strong>的<code>x</code>、<code>y</code>以及<code>1</code>构成一个1x3的向量<code>(x, y, 1)</code>，所谓的仿射变换指的是让该1x3向量与3x3矩阵进行相乘，得到一个新的1x3向量，称之为<code>(_x, _y, 1)</code>，而<code>(_x, _y)</code>即<code>(x, y)</code>反射变换后的新坐标。将<code>UIView</code>的每一个像素点都进行这样的处理，即可完成整个<code>UIView</code>的反射变换。更形象的描述如下图所示：</p>
<div class="imagediv" style="width: 676px; height: 220px"></div>

<p>显然，仿射变换的关键是生成<code>CGAffineTransform</code>实例了，如果没学过计算机图形学，计算<code>CGAffineTransform</code>的参数值还是蛮麻烦的，不过好在iOS已经为我们提供了快捷API。</p>
<p>仿射变换实现的效果包括平移、缩放、旋转以及它们的组合，如下是这三种仿射变换的快速生成APIs：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 平移</span></div><div class="line"><span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">_</span>:<span class="number">_</span>:)</div><div class="line"><span class="comment">// CGAffineTransformMakeTranslation(tx, ty)</span></div><div class="line"></div><div class="line"><span class="comment">// 缩放</span></div><div class="line"><span class="type">CGAffineTransformMakeScale</span>(<span class="number">_</span>:<span class="number">_</span>:)</div><div class="line"><span class="comment">// CGAffineTransformMakeScale(sx, sy)</span></div><div class="line"></div><div class="line"><span class="comment">// 旋转</span></div><div class="line"><span class="type">CGAffineTransformMakeRotation</span>(<span class="number">_</span>:)</div><div class="line"><span class="comment">// CGAffineTransformMakeRotation(angle)</span></div></pre></td></tr></table></figure>
<p>除此之外还有一个其他APIs，此处略过。Wiki还提供了一些常见反射变换及对应的矩阵值，如下图：</p>
<div class="imagediv" style="width: 512px; height: 683px"></div>

<blockquote>
<p>Note: 在iOS环境中，对<code>UIView</code>进行反射变换所参考的坐标点是<code>UIView.layer.archorPoint</code>，<a href="layer-geometry-in-ios.md">《iOS图层几何学》</a>里有阐述。</p>
</blockquote>
<h2 id="3D-Transforms"><a href="#3D-Transforms" class="headerlink" title="3D Transforms"></a>3D Transforms</h2><p>3D变换要复杂得多，恐怕得花很多时间才能搞清楚，暂时略过。</p>
<p><a href="https://zsisme.gitbooks.io/ios-/content/chapter5/3d-transform.html" target="_blank" rel="external">iOS核心动画高级技巧–3D变换</a>有比较好的介绍。</p>
<p><code>UIView#transform</code>和<code>UIView#layer.transform</code>的关系？将一个归位后另外一个会是啥变化？</p>
<h2 id="Planning-Animations"><a href="#Planning-Animations" class="headerlink" title="Planning Animations"></a>Planning Animations</h2><p>如何规划动画？先问自己这么几个问题：</p>
<ul>
<li>What are the initial properties of the item?</li>
<li>What are the final properties of the item?</li>
<li>How long should the animation take?</li>
<li>What’s happening while this item is animating?</li>
<li>What will happen once this item is done animating?</li>
</ul>
<h2 id="Animation-Curve-of-An-Easing-type-Motion"><a href="#Animation-Curve-of-An-Easing-type-Motion" class="headerlink" title="Animation Curve of An Easing-type Motion"></a>Animation Curve of An Easing-type Motion</h2><p>所谓的动画，无非是animation properties在时间轴上的变化过程。</p>
<p>以时间为x轴，属性值为y轴，可以构建一个二维坐标系，属性值从<code>a</code>到<code>b</code>，有无数种走向。换句话说，动画类型的丰富程度是无限的。</p>
<p>但在实际应用中，可接受的（看起来比较爽的）动画类型是不多的，其中一种类型叫：<strong>easing-type motion</strong>，一图胜千言：</p>
<div class="imagediv" style="width: 460px; height: 340px"></div>

<p>图中所展示的是4种最为常见的easing-type motion曲线，<a href="http://easings.net/zh-cn" target="_blank" rel="external">缓动函数速查表</a>里能够看到更多。</p>
<p>在iOS中使用<code>UIView.animateWithDuration(...)</code>系列方法处理动画时，可以通过设置<code>options</code>来选择对应的easing type，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.2</span>, delay: <span class="number">0.0</span>, options: .<span class="type">CurveEaseInOut</span>, animations: &#123; <span class="comment">/*...*/</span> &#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p><code>options</code>可以设置结构体类型<code>UIViewAnimationOptions</code>的变量值，该类型有很多变量值，easing-type motion相关的有四个：</p>
<ul>
<li><code>CurveLinear</code>, linear</li>
<li><code>CurveEaseInOut</code>, ease in, ease out</li>
<li><code>CurveEaseIn</code>, ease in</li>
<li><code>CurveEaseOut</code>, ease out</li>
</ul>
<blockquote>
<p>Note: 这些easing curves本质上是3次贝塞尔曲线（cubic Bézier curve），通过控制4个变量可以得到各种各样的3次贝塞尔曲线，只是iOS貌似没有提供控制这些参数的API，<a href="http://cubic-bezier.com/" target="_blank" rel="external">Cubic Bezier On Line</a>提供了更为丰富的体验。</p>
</blockquote>
<h2 id="Animation-Curve-of-A-Spring-like-Motion"><a href="#Animation-Curve-of-A-Spring-like-Motion" class="headerlink" title="Animation Curve of A Spring-like Motion"></a>Animation Curve of A Spring-like Motion</h2><p>另一种动画类型叫：<strong>spring-like motion</strong>。<a href="https://dn-motion-design.qbox.me/guide-3.html" target="_blank" rel="external">这里</a>对spring-like motion有较为细致的描述，此处就不再赘述，这一部分重点在于分析控制spring-like motion的关键参数。</p>
<p>参考<a href="https://dn-motion-design.qbox.me/guide-3.html" target="_blank" rel="external">Natural Motion</a>的分析，控制spring-like motion的关键参数有三个：</p>
<ul>
<li><strong>Mass</strong>. The mass is the weight or heft of the object attached to the end of the spring.</li>
<li><strong>stiffness.</strong> The stiffness is how difficult it is to stretch out the spring, which typically corresponds to its thickness and how tightly it’s coiled. </li>
<li><strong>damping.</strong> The damping is the resistive force or friction, like when you drag your hand through water and feel the forces pushing against it as you try to move quicker through the water.</li>
</ul>
<p>iOS自iOS 7起引入了支持spring-like motion的API：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animateWithDuration(duration: <span class="type">NSTimeInterval</span>,</div><div class="line">                           delay: <span class="type">NSTimeInterval</span>, </div><div class="line">                           usingSpringWithDamping dampingRatio: <span class="type">CGFloat</span>,</div><div class="line">                           initialSpringVelocity velocity: <span class="type">CGFloat</span>,</div><div class="line">                           options: <span class="type">UIViewAnimationOptions</span>,</div><div class="line">                           animations: () -&gt; <span class="type">Void</span>,</div><div class="line">                           completion: ((<span class="type">Bool</span>) -&gt; <span class="type">Void</span>)?)</div></pre></td></tr></table></figure>
<p>相对而言，该Spring Animation API对spring-like motion的控制简化了，只提供了两个参数：<code>dampingRatio</code>和<code>velocity</code></p>
<p><code>dampingRatio</code>的取值范围是0.0-1.0，数值越小，「弹簧」的震动效果越明显。下图演示了在<code>dampingRatio</code>为<code>0.0</code>的情况下，<code>dampingRatio</code>分别取<code>0.2</code>，<code>0.5</code>和<code>1.0</code>的情况。</p>
<div class="imagediv" style="width: 314px; height: 321px"></div>

<p><code>velocity</code>表示初识的速度，数值越大一开始移动越快。下图演示了在<code>dampingRatio</code>为<code>1.0</code>时，<code>velocity</code>分别取<code>5.0</code>，<code>15.0</code>和<code>25.0</code>的情况。值得注意的是，初始速度取值较高而时间较短时，也会出现反弹情况。</p>
<div class="imagediv" style="width: 314px; height: 321px"></div>

<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://dn-motion-design.qbox.me/" target="_blank" rel="external">Motion Design for iOS</a></li>
<li><a href="http://www.jianshu.com/p/6c09d138b31d" target="_blank" rel="external">iOS仿射变换CGAffineTransform详解</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2" target="_blank" rel="external">仿射变换</a></li>
<li><a href="https://zsisme.gitbooks.io/ios-/content/chapter5/affine-fransforms.html" target="_blank" rel="external">iOS核心动画高级技巧–仿射变换</a></li>
<li><a href="https://zsisme.gitbooks.io/ios-/content/chapter5/3d-transform.html" target="_blank" rel="external">iOS核心动画高级技巧–3D变换</a></li>
<li><a href="http://easings.net/zh-cn" target="_blank" rel="external">缓动函数速查表</a></li>
<li><a href="http://cubic-bezier.com/" target="_blank" rel="external">Cubic Bezier On Line</a></li>
<li><a href="https://www.renfei.org/blog/ios-8-spring-animation.html" target="_blank" rel="external">使用iOS 8 Spring Animation API创建动画</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Animation/">Animation</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-navigation-transitions-in-ios" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/11/navigation-transitions-in-ios/" class="article-date">
  	<time datetime="2016-06-11T02:30:03.000Z" itemprop="datePublished">2016-06-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/11/navigation-transitions-in-ios/">Navigation Transition</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="../modal-transitions-in-ios/">Modal Transition概述</a>对自定义transition进行了简单概述，<a href="../using-uipercentdriveninteractivetransition">Using UIPercentDrivenInteractiveTransition</a>介绍了可交互转场的基本实现思路。本文旨在总结实现<strong>自定义navigation转场</strong>的基本套路。</p>
<p>此外，还对自己写的相关demo做一个汇总。</p>
<h2 id="Basic-Methods-Of-Custom-Navigation-Transition"><a href="#Basic-Methods-Of-Custom-Navigation-Transition" class="headerlink" title="Basic Methods Of Custom Navigation Transition"></a>Basic Methods Of Custom Navigation Transition</h2><p>在<code>UINavigationController</code>的基础上实现自定义custom navigation transition，只需要让自定义view controller遵循<code>UINavigationControllerDelegate</code>协议，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewController</span>: <span class="title">UIViewController</span>, <span class="title">UINavigationControllerDelegate</span> </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    navigationController?.delegate = <span class="keyword">self</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认情况下，<code>UINavigationController#delegate</code>为<code>nil</code>，此时push和pop动画全部采用系统默认transition。</p>
<p><code>UINavigationControllerDelegate</code>定义了6个方法，与transition直接相关的有两个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为push和pop操作提供animation controller</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(navigationController: UINavigationController,</span></span></div><div class="line">  animationControllerForOperation operation: UINavigationControllerOperation,</div><div class="line">  fromViewController fromVC: UIViewController,</div><div class="line">  toViewController toVC: UIViewController)</div><div class="line">  -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>?</div><div class="line"></div><div class="line"><span class="comment">// 为push和pop操作提供interaction controller</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(</span></span></div><div class="line">  navigationController: UINavigationController,</div><div class="line">  interactionControllerForAnimationController animationController: UIViewControllerAnimatedTransitioning)</div><div class="line">  -&gt; <span class="type">UIViewControllerInteractiveTransitioning</span>?</div></pre></td></tr></table></figure>
<p>站在这两个方法的角度来看，<code>UINavigationControllerDelegate</code>有点类似于<code>UIViewControllerTransitioningDelegate</code>，后者为transition动画提供animation controller和interaction controller，前者的作用也类似。</p>
<h2 id="Some-Demos"><a href="#Some-Demos" class="headerlink" title="Some Demos"></a>Some Demos</h2><p><strong>可交互的简单push/pop实现 – 仿知乎</strong></p>
<!-- <div class="imagediv" style="width: 320px; height: 566px"></div> –&gt;
<p><img src="/navigation-transitions-in-ios/BasicInteractiveCustomNavigationTransitionDemo.gif" alt="ssss"></p>
<p>代码详见<a href="https://github.com/sadjason/BasicInteractiveCustomNavigationTransitionDemo">这里</a>。</p>
<p>如下是一些不错的开源custom navigation transition实现：</p>
<ul>
<li><a href="https://github.com/recruit-mp/RMPZoomTransitionAnimator">RMPZoomTransitionAnimator</a></li>
<li><a href="https://github.com/DenHeadless/ZoomInteractiveTransition">ZoomInteractiveTransition</a></li>
<li><a href="https://github.com/NewAmsterdamLabs/ZOZolaZoomTransition">ZOZolaZoomTransition</a></li>
<li><a href="https://github.com/hebertialmeida/HAPaperViewController">HAPaperViewController</a></li>
<li><a href="https://github.com/boycechang/BCMagicTransition">BCMagicTransition</a></li>
<li><a href="https://github.com/JakeLin/IBAnimatable">IBAnimatable</a></li>
</ul>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="http://stackoverflow.com/questions/26569488/navigation-controller-custom-transition-animation">Navigation Controller Custom Transition Animation</a></li>
</ul>
-->
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Transition/">Transition</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-using-uipercentdriveninteractivetransition" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/10/using-uipercentdriveninteractivetransition/" class="article-date">
  	<time datetime="2016-06-10T09:06:55.000Z" itemprop="datePublished">2016-06-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/10/using-uipercentdriveninteractivetransition/">使用UIPercentDrivenInteractiveTransition</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>实现可交互的自定义转场动画的关键在于：定义遵循<code>UIViewControllerInteractiveTransitioning</code>协议的类。</p>
<p><code>UIViewControllerInteractiveTransitioning</code>协议的内容如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">UIViewControllerInteractiveTransitioning</span> : <span class="title">NSObjectProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">startInteractiveTransition</span><span class="params">(transitionContext: UIViewControllerContextTransitioning)</span></span></div><div class="line">    </div><div class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">completionSpeed</span><span class="params">()</span></span> -&gt; <span class="type">CGFloat</span></div><div class="line">    <span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">completionCurve</span><span class="params">()</span></span> -&gt; <span class="type">UIViewAnimationCurve</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到现在我都没搞明白如何定义遵循<code>UIViewControllerInteractiveTransitioning</code>的类。</p>
<p>但正如Apple<a href="https://developer.apple.com/library/prerelease/content/featuredarticles/ViewControllerPGforiPhoneOS/CustomizingtheTransitionAnimations.html" target="_blank" rel="external">文档</a>所言：</p>
<blockquote>
<p>The easiest way to make your animations interactive is to use a <code>UIPercentDrivenInteractiveTransition</code> object.</p>
</blockquote>
<p>简单来说，创建遵循<code>UIViewControllerInteractiveTransitioning</code>协议的类型的最简单方式是继承<code>UIPercentDrivenInteractiveTransition</code>类。</p>
<p>这是一个遵循<code>UIViewControllerInteractiveTransitioning</code>协议的类，为我们预先实现和提供了一系列便利的方法，可以用一个百分比来控制交互式切换的过程。</p>
<p>该类的内容及介绍如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIPercentDrivenInteractiveTransition</span> : <span class="title">NSObject</span>, <span class="title">UIViewControllerInteractiveTransitioning</span> </span>&#123;</div><div class="line">    </div><div class="line">  <span class="comment">// 只读，对应的是animation controller的transitionDuration(_:)返回值</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">var</span> duration: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    </div><div class="line">  <span class="comment">// 交互动画完成度（百分比），updateInteractiveTransition(_:)会改变该值</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">var</span> percentComplete: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    </div><div class="line">  <span class="comment">// 影响completion animation duration，一般设置为1.0（默认值），</span></div><div class="line">  <span class="comment">// 对应的completion animation duration为(1 - percentComplete)*duration.</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">var</span> completionSpeed: <span class="type">CGFloat</span></div><div class="line">    </div><div class="line">  <span class="comment">// completion animation的timing curve，默认是.EaseInOut</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">var</span> completionCurve: <span class="type">UIViewAnimationCurve</span></div><div class="line"></div><div class="line">  <span class="comment">/* 这三个方法在gesture recognizer的处理逻辑中调用 */</span></div><div class="line">  <span class="comment">// 更新百分比，一般通过手势识别的长度之类的来计算一个值，然后进行更新</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">updateInteractiveTransition</span><span class="params">(percentComplete: CGFloat)</span></span></div><div class="line">  <span class="comment">// 报告交互取消，返回切换前的状态</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">cancelInteractiveTransition</span><span class="params">()</span></span></div><div class="line">  <span class="comment">// 报告交互完成，更新到切换后的状态</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">finishInteractiveTransition</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>UIPercentDrivenInteractiveTransition</code>的内容并不复杂，使用时需要注意的是，interaction controller不能孤立存在，需要配合animation controller工作；换句话说，具体的transition仍然在animation controller的<code>animateTransition(_:)</code>中完成。</p>
<p>此外，在定义animation controller的<code>animateTransition(_:)</code>方法时，不要忘记调用<code>UIViewControllerContextTransitioning</code>的<code>completeTransition(_:)</code>方法。</p>
<blockquote>
<p>P.S: 根据我的理解并验证，<code>UIViewControllerContextTransitioning#completeTransition(true)</code>的作用效果之一是将from view从container view中移除掉。</p>
</blockquote>
<p>基于<code>UIPercentDrivenInteractiveTransition</code>做了个简单的Demo，如下图：</p>
<div class="imagediv" style="width: 320px; height: 568px"></div>

<p>代码详见<a href="https://github.com/sadjason/ShrinkingModalInteractiveTransitionDemo" target="_blank" rel="external">Github</a>。</p>
<p><code>UIViewControllerTransitioning.h</code>中对<code>UIPercentDrivenInteractiveTransition</code>有一段说明，不是特别理解：</p>
<blockquote>
<p>This style of interaction controller should only be used with an animator that implements a CA style transition in the animator’s animateTransition: method.</p>
</blockquote>
<p>掌握使用<code>UIPercentDrivenInteractiveTransition</code>并不难，但是该类有哪些限制（或缺陷）呢？我有该如何抛开该类自定义实现interaction controller呢？</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://onevcat.com/2013/10/vc-transition-in-ios7/" target="_blank" rel="external">WWDC 2013 Session笔记 - iOS7中的ViewController切换</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerInteractiveTransitioning_protocol/" target="_blank" rel="external">UIViewControllerInteractiveTransitioning Protocol Reference</a></li>
<li><a href="http://initwithfunk.com/blog/2014/05/22/interactive-animated-transitions-on-ios/" target="_blank" rel="external">Interactive Animated Transitions on iOS</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Transition/">Transition</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-modal-transitions-in-ios" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/09/modal-transitions-in-ios/" class="article-date">
  	<time datetime="2016-06-09T11:43:39.000Z" itemprop="datePublished">2016-06-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/09/modal-transitions-in-ios/">Modal Transition</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文旨在分析modal transition自定义过场动画的实现过程，总结一些基本套路。</p>
<p>视图控制器的转场动画涉及几大组件：</p>
<ol>
<li><strong>转场上下文</strong>（transition context）</li>
<li><strong>转场代理</strong>（transitioning delegation）</li>
<li><strong>动画控制器</strong>（animation controller）</li>
<li><strong>交互控制器</strong>（interaction controller）</li>
<li><strong>转场协调器</strong>（transition coordination）</li>
<li><strong>呈现控制器</strong>（presentation controller）</li>
</ol>
<p>其中前5个是iOS 7中引入的，都以<strong>协议</strong>的形式定义，利用这5个接口可以实现丰富转场动画（不光是modal transition），详细内容参考<a href="../viewcontroller-transitions-basics/">iOS转场动画概述</a>；第6个是Apple在iOS 8中引入的，以类（<code>UIPresentationController</code>）的形式定义，在modal transition中可能会用到。</p>
<p>下文若涉及如上这些概念，均以对应的英文代指。</p>
<p>在iOS中，modal transition涉及两个控制器：presenting view controller和presented view controller。transition结束后，后者盖在前者上面。</p>
<p>过场动画说到底是对view的动画处理，根据我的分析，相关的view包括：key window、presenting controller’s view、container view、presented controller’s view，完成transition后，它们的层次结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">|--key window</div><div class="line">   |--presenting controller&apos;s view</div><div class="line">   |--container view</div><div class="line">      |--presented controller&apos;s view</div><div class="line"></div><div class="line"># 说明：</div><div class="line"># a. 此处presenting view controller是keyWindow的rootViewController；</div><div class="line"># b. container view并不一定是presented controller&apos;s view的super view，但一定是它的ancestor view；</div></pre></td></tr></table></figure>
<p>为叙述简单起见，下文中的<strong>presented view</strong>等价于上述的<strong>presented controller’s view</strong>，<strong>presenting view</strong>则等价于<strong>presenting controller’s view</strong>。</p>
<p>如上的层次结构是我通过阅读文档和测试得出的结论，可以看出，presenting view和presented view并没有包含关系。container view是什么呢？在transition过程中，系统先创建一个临时的view，把它纳入到key window的层次结构中，然后将presented view加入到container view中。</p>
<p>对于modal transition，一般来说，container view是系统产生的。</p>
<blockquote>
<p>P.S: 根据我的认知，貌似只有在自定义容器控制器时，才需要指定container view。</p>
</blockquote>
<h2 id="简单的自定义Modal过场动画"><a href="#简单的自定义Modal过场动画" class="headerlink" title="简单的自定义Modal过场动画"></a>简单的自定义Modal过场动画</h2><p>把相关的view层次关系理清，实现简单的自定义过场动画就不难了，先来一个最简单的：presented view渐进显示（alpha从0.0到1.0），效果如下：</p>
<div class="imagediv" style="width: 320px; height: 568px"></div>

<p>上述demo中涉及两个view controller，本文将它们对应的类命名为：PresentingViewController和PresentedViewController。</p>
<p>从PresentingViewController过渡到PresentedViewController非常容易，一行代码解决：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">presentViewController(<span class="type">PresentedViewController</span>(), animated: <span class="literal">true</span>)</div></pre></td></tr></table></figure>
<p>默认情况下，PresentedViewController会从底部升起，现在想让它执行自定义动画（alpha从0.0到1.0），需要对PresentedViewController稍作处理，首先是设置其modal style为Custom，并指定其过场动画的代理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PresentedViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> presenter: <span class="type">UIViewControllerTransitioningDelegate</span>?</div><div class="line">  <span class="keyword">init</span>() &#123;</div><div class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</div><div class="line">    commonSetup()</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</div><div class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</div><div class="line">    commonSetup()</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">commonSetup</span><span class="params">()</span></span> &#123;</div><div class="line">    modalPresentationStyle = .<span class="type">Custom</span></div><div class="line">    presenter = <span class="type">SimpleModalPresenter</span>()</div><div class="line">    transitioningDelegate = presenter</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>modalPresentationStyle=.Custom</code>告诉系统自定义过场处理，而<code>transitioningDelegate</code>属性指定transitioning delegation，值得一提的是，<code>transitioningDelegate</code>属性被<code>weak</code>修饰，不强持有所指向的资源，故而<code>commonSetup()</code>不能写成如下这样（曾在这里栽过跟头）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">commonSetup</span><span class="params">()</span></span> &#123;</div><div class="line">  modalPresentationStyle = .<span class="type">Custom</span></div><div class="line">  transitioningDelegate = <span class="type">SimpleModalPresenter</span>()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目前为止（当前最新版本为iOS 9），transitioning delegation有5个可选回调，作用有三个：</p>
<ul>
<li>提供animation controllers（遵循<code>UIViewControllerAnimatedTransitioning</code>协议的对象）；</li>
<li>提供interaction controllers（遵循<code>UIViewControllerInteractiveTransitioning</code>协议的对象）；</li>
<li>提供presentation controller（<code>UIPresentationController</code>对象）；</li>
</ul>
<p><code>SimpleModalPresenter</code>的实现非常简单，实现两个回调，分别为presentation transition和dismissal transition提供animation controller（暂时不考虑交互，因此略过interaction controller，<code>UIPresentationController</code>下文会提到）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleModalPresenter</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerTransitioningDelegate</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="comment">// 非交互动画</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animationControllerForPresentedController</span><span class="params">(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? &#123;</div><div class="line">    <span class="keyword">let</span> animator = <span class="type">SimpleModalAnimator</span>()</div><div class="line">    animator.isPresentation = <span class="literal">true</span></div><div class="line">    <span class="keyword">return</span> animator</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animationControllerForDismissedController</span><span class="params">(dismissed: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? &#123;</div><div class="line">    <span class="keyword">let</span> animator = <span class="type">SimpleModalAnimator</span>()</div><div class="line">    animator.isPresentation = <span class="literal">false</span></div><div class="line">    <span class="keyword">return</span> animator</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Animation controller的实现也非常简单，无非是利用系统提供transition context信息进行简单的动画处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleModalAnimator</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> isPresentation: <span class="type">Bool</span> = <span class="literal">false</span></div><div class="line">  </div><div class="line">  <span class="comment">// 定义过场动画时间，其他地方可能会用到这个</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">NSTimeInterval</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1.0</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 过场动画的具体执行</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> containerView = transitionContext.containerView()</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> presentedView: <span class="type">UIView</span>?</div><div class="line">    <span class="keyword">if</span> isPresentation &#123;</div><div class="line">      presentedView = transitionContext.viewForKey(<span class="type">UITransitionContextToViewKey</span>)</div><div class="line">      presentedView?.frame = (containerView?.bounds)!</div><div class="line">      presentedView?.alpha = <span class="number">0.0</span></div><div class="line">      containerView?.addSubview(presentedView!)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      presentedView = transitionContext.viewForKey(<span class="type">UITransitionContextFromViewKey</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="type">UIView</span>.animateWithDuration(transitionDuration(transitionContext), animations: &#123;</div><div class="line">      presentedView?.alpha = <span class="keyword">self</span>.isPresentation ? <span class="number">1.0</span> : <span class="number">0.0</span></div><div class="line">      &#125;) &#123; (finished) <span class="keyword">in</span></div><div class="line">        transitionContext.completeTransition(finished)</div><div class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.isPresentation &#123;</div><div class="line">          presentedView?.removeFromSuperview()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SimpleModalAnimator</code>将presentation和dismissal二合一，定义<code>isPresentation</code>属性以便区分。</p>
<p>综上，实现简单的modal transition只需要三个步骤：</p>
<ol>
<li>在presented view controller中指定modal style和transition delegate；</li>
<li>实现transition delegate，即定义遵循<code>UIViewControllerTransitioningDelegate</code>协议的类，transition delegate为presented view controller提供animation controllers；</li>
<li>实现animation controllers，即定义遵循<code>UIViewControllerAnimatedTransitioning</code>协议的类，animation controller利用系统所提供的transition context信息，处理一些简单的view animation。</li>
</ol>
<h2 id="UIPresentationController"><a href="#UIPresentationController" class="headerlink" title="UIPresentationController"></a>UIPresentationController</h2><p>Presentation controller是iOS 8引入的新概念，能够帮助我们更方便快捷地实现view controller的自定义过渡效果，与animation controller等不同，它不是以协议的方式定义，而是定义了一个名为<code>UIPresentationController</code>的类。</p>
<blockquote>
<p>P.S: 很好奇为什么不把presentation controller也定义成protocol。</p>
</blockquote>
<p>简单来说，presentation controller和animation controller有些类似，它们都不是视图控制器，没有<code>view</code>属性，都拥有container view、presented view等访问权，都由transitioning delegation提供；presentation controller的主要使命是提供一些回调，系统在presentation transition的开始/结束、dismissal transition的开始/结束会调用这些回调，有点类似视图控制器的<code>viewWillAppear(_:)</code>、<code>viewDidAppear(_:)</code>，常用的回调如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// presentation transition</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentationTransitionWillBegin</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentationTransitionDidEnd</span><span class="params">(completed: Bool)</span></span></div><div class="line"><span class="comment">// dismissal transition</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismissalTransitionWillBegin</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismissalTransitionDidEnd</span><span class="params">(completed: Bool)</span></span></div><div class="line"></div><div class="line"><span class="comment">/* Position of the presented view in the container view </span></div><div class="line"> * by the end of the presentation transition.</div><div class="line"> * (Default: container view bounds)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">frameOfPresentedViewInContainerView</span><span class="params">()</span></span> -&gt; <span class="type">CGRect</span></div><div class="line"></div><div class="line"><span class="comment">/* Indicate whether the view controller's view we are transitioning from </span></div><div class="line"> * will be removed from the window in the end of the presentation transition</div><div class="line"> * (Default: NO)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldRemovePresentersView</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></div></pre></td></tr></table></figure>
<p>可以看到，相较于animation controller，presentation controller所涉及的过场讯息更加精细。</p>
<blockquote>
<p>Note: <code>UIPresentationController</code>实例的初始化不能使用<code>init()</code>，必须要使用<code>init(presentedViewController:presentingViewController:)</code>。</p>
</blockquote>
<p>刚开始接触presentation controller时有些疑点：</p>
<ul>
<li>Presentation controller一定要配合animation controller使用？可以单独使用吗？</li>
<li>Presentation controller和animation controller都可以访问container view和presented view，都能处理过场动画，如何让它们俩协调工作？</li>
</ul>
<p>首先，presentation controller是可以单独使用的！也就是说，transitioning delegation可以只提供presentation controller，而不提供animation controller，如下这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 转场代理只提供presentation controller</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleModalPresenter</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerTransitioningDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">presentationControllerForPresentedViewController</span><span class="params">(presented: UIViewController, presentingViewController presenting: UIViewController, sourceViewController source: UIViewController)</span></span> -&gt; <span class="type">UIPresentationController</span>? &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">SimplePresentationController</span>(presentedViewController: presented, presentingViewController: presenting)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StackOverFlow中有一个简单的<a href="http://stackoverflow.com/questions/29219688/present-modal-view-controller-in-half-size-parent-controller/29220983#29220983" target="_blank" rel="external">用例</a>：让presented view占据屏幕的下半部分，而不是全屏。重载自定义presentation controller的<code>frameOfPresentedViewInContainerView() -&gt; CGRect</code>方法即可实现。</p>
<blockquote>
<p>Note: 当transitioning delegation同时提供自定义的animation controller和presentation controller时，presentation controller的<code>frameOfPresentedViewInContainerView() -&gt; CGRect</code>方法不管用了，不晓得什么原因，非常诡异！除了这种方式，还可以在animation controller的<code>animateTransition(_:)</code>设置presented view的<code>frame</code>。</p>
</blockquote>
<p>然后来分析presentation controller和animation controller如何协同工作。</p>
<p>如上文所述，二者拥有对presented view和container view的访问权…在我看来，它们所能做的事情有些重叠，modal呈现presented view controller的一个重要步骤是<code>containerView.addSubview(presentedView)</code>，这行代码在哪里执行呢？可以在animation controller的<code>animateTransition(_:)</code>方法中处理，也可以在presentation controller的回调<code>presentationTransitionWillBegin()</code>中处理。此外，presentation controller的很多用法是在container view和presented view中加入一层view（充当遮罩或者蒙板），比如<a href="http://www.cocoachina.com/industry/20140707/9053.html" target="_blank" rel="external">这样</a>；这种事情显然也可以在animation controller的<code>animateTransition(_:)</code>方法中完成。</p>
<p>总之，在我看来，presentation controller不是必要的，它所能做的事情，animation controller的<code>animateTransition(_:)</code>都能做，只是presentation controller把工作给简化了一些。</p>
<blockquote>
<p>Note: 把presentation controller看作是animation controller和interaction controller的扩展。</p>
</blockquote>
<p>个人感觉，presentation controller虽然简化了自定义modal transition的实现，但是让逻辑更复杂了，甚至更混乱了。</p>
<p>因此，有必要将presentation controller和animation controller的工作给分清楚。我是这么想的：presented view相关的设置与动画处理都放在animation controller中完成，而presentation view（一般是夹在container view和presented view之间的临时view）相关设置和处理都放在presentation controller中处理。</p>
<p>在presentation transition和dismissal transition过程中，animation controller的<code>animateTransition(_:)</code>和presentation controller的几个回调的执行顺序是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># presentation transition</div><div class="line">presentationTransitionWillBegin()</div><div class="line">animateTransition(_:)</div><div class="line">presentationTransitionDidEnd(_:)</div><div class="line"></div><div class="line"># dismissal transition</div><div class="line">dismissalTransitionWillBegin()</div><div class="line">animateTransition(_:)</div><div class="line">dismissalTransitionDidEnd(_:)</div></pre></td></tr></table></figure>
<h2 id="Presentation-Style"><a href="#Presentation-Style" class="headerlink" title="Presentation Style"></a>Presentation Style</h2><p><code>UIViewController</code>有个属性<code>modalPresentationStyle</code>，上文中用到了该属性，只是用得稀里糊涂，这一部分对它进行进一步说明。</p>
<p>Apple文档对<code>modalPresentationStyle</code>属性的解释如下：</p>
<blockquote>
<p>The presentation style determines how a modally presented view controller is displayed onscreen. In a horizontally compact environment, modal view controllers are always presented full-screen. In a horizontally regular environment, there are several different presentation options. For a list of possible presentation styles, and their compatibility with the available transition styles, see the <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/#//apple_ref/c/tdef/UIModalPresentationStyle" target="_blank" rel="external">UIModalPresentationStyle</a> constant descriptions.</p>
</blockquote>
<p>该属性是个枚举值，包括9个case，其中大多数都与iPad环境有关，这里只介绍iPhone开发环境中会常常涉及到的3个枚举值：</p>
<ul>
<li><code>.FullScreen</code> – A presentation style in which the presented view covers the screen. The views belonging to the presenting view controller are removed after the presentation completes.</li>
<li><code>.OverFullScreen</code> – A view presentation style in which the presented view covers the screen. The views beneath the presented content are not removed from the view hierarchy when the presentation finishes. So if the presented view controller does not fill the screen with opaque content, the underlying content shows through.</li>
<li><code>.Custom</code> – A custom view presentation style that is managed by a custom presentation controller and one or more custom animator objects. All of these objects are provided by the presented view controller’s transitioning delegate.</li>
</ul>
<p>简单来说，当<code>modalPresentationStyle</code>属性赋值<code>.FullScreen</code>或者<code>.OverFullScreen</code>时，transitioning delegation提供的自定义presentation controller就没什么卵用。换句话说，如果想使用自定义的presentation controller，必须对<code>modalPresentationStyle</code>属性赋值<code>.Custom</code>。</p>
<p>它们仨有啥不同呢？</p>
<p><code>.FullScreen</code>所对应的内置presentation controller，会在presentation transition结束时，将presenting view从key window的view hierarchy中移除掉。</p>
<p>而<code>.OverFullScreen</code>所对应的内置presentation controller，则不会在presentation transition结束时移除掉presenting view。</p>
<p>在<code>.Custom</code>模式下，不会使用任何一种系统内置presentation controller，它依赖于用户自定义presentation controller，即实现一个<code>UIPresentationController</code>子类，该子类有一个<code>shouldRemovePresentersView() -&gt; Bool</code>方法。单从对待presenting view的角度来看，当该方法返回<code>false</code>时，<code>.Custom</code>与<code>.OverFullScreen</code>一致，反之，当该方法返回<code>true</code>时，<code>.Custom</code>与<code>.FullScreen</code>一致。</p>
<p>我为什么会关注<code>modalPresentationStyle</code>属性呢？</p>
<p>这是因为我在animation controller的<code>animateTransition(_:)</code>方法中无法访问presenting view，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">  <span class="keyword">let</span> presentingView = transitionContext.viewForKey(<span class="type">UITransitionContextFromViewKey</span>)</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查了半天资料，发现这个<a href="http://stackoverflow.com/questions/24338700/from-view-controller-disappears-using-uiviewcontrollercontexttransitioning/25901154#25901154" target="_blank" rel="external">说法</a>比较靠谱。大概的意思是：</p>
<ul>
<li>如果在presentation transition结束时仍然将presenting view保留到key window中，iOS（iOS 8及以后版本）认为没有必要让你再操控presenting view，故而通过<code>viewForKey(UITransitionContextFromViewKey)</code>访问presenting view得到的结果为<code>nil</code>；</li>
<li>如果在presentation transition结束时将presenting view从key window中移除掉，iOS认为你可能需要在presentation transition过程中对presenting view做一个动画，故而通过<code>viewForKey(UITransitionContextFromViewKey)</code>能够访问到presenting view。</li>
</ul>
<p>UIKit的UIViewControllerTransitioning.h文件中也有对这种说法的佐证：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Currently only two keys are defined by the system -</span></div><div class="line"><span class="comment">// UITransitionContextFromViewKey, and UITransitionContextToViewKey</span></div><div class="line"><span class="comment">// viewForKey: may return nil which would indicate that the animator should not</span></div><div class="line"><span class="comment">// manipulate the associated view controller's view.</span></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">viewForKey</span><span class="params">(key: String)</span></span> -&gt; <span class="type">UIView</span>?</div></pre></td></tr></table></figure>
<p>对于这种做法，我的下意识是：What The Fuck!</p>
<p>当然，如果非要访问presenting view，除了通过<code>viewForKey(_:)</code>，还可以曲线救国：先通过<code>viewControllerForKey(_:)</code>访问presenting view controller，然后再访问view。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="http://www.cocoachina.com/industry/20140707/9053.html" target="_blank" rel="external">iOS 8的PresentationController</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIPresentationController_class/" target="_blank" rel="external">UIPresentationController Class Reference</a></li>
<li><a href="https://developer.apple.com/library/prerelease/content/featuredarticles/ViewControllerPGforiPhoneOS/CustomizingtheTransitionAnimations.html" target="_blank" rel="external">Customizing the Transition Animations</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Transition/">Transition</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-practice-in-uiscrollview" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/21/practice-in-uiscrollview/" class="article-date">
  	<time datetime="2016-05-21T05:41:28.000Z" itemprop="datePublished">2016-05-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/21/practice-in-uiscrollview/">使用UIScrollView</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="UIScrollViewDelegate"><a href="#UIScrollViewDelegate" class="headerlink" title="UIScrollViewDelegate"></a>UIScrollViewDelegate</h2><p>简单介绍一下UIScrollViewDelegate定义的一些方法，这里只涉及与scroll相关的方法，zoom相关的方法略过不表。</p>
<ul>
<li><code>scrollViewDidScroll(_:)</code></li>
</ul>
<p>这个方法在任何方式触发<code>contentOffset</code>变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控<code>contentOffset</code>的变化，并根据当前的<code>contentOffset</code>对其他view做出随动调整。</p>
<ul>
<li><code>scrollViewWillBeginDragging(_:)</code></li>
</ul>
<p>用户开始拖动scroll view的时候被调用。</p>
<ul>
<li><code>scrollViewWillEndDragging(_:withVelocity:targetContentOffset:)</code></li>
</ul>
<p>这个方法是iOS 5之后引入的，可在它的基础上实现更为丰富的自定义paging。</p>
<ul>
<li><code>scrollViewDidEndDragging(_:willDecelerate:)</code></li>
</ul>
<p>在用户结束拖动后被调用，<code>willDecelerate</code>为YES时，结束拖动后会有减速过程（惯性）。</p>
<ul>
<li><code>scrollViewWillBeginDecelerating(_:)</code></li>
</ul>
<p>减速动画开始前被调用。</p>
<ul>
<li><code>scrollViewDidEndDecelerating(_:)</code></li>
</ul>
<p>减速动画结束时被调用，这里有一种特殊情况：当一次减速动画尚未结束的时候再次drag scroll view，该方法不会被调用，并且这时scroll view的<code>dragging</code>和<code>decelerating</code>属性都是<code>YES</code>。新的dragging如果有加速度，那么<code>scrollViewWillBeginDecelerating(_:)</code>会再一次被调用，然后才是<code>scrollViewDidEndDecelerating(_:)</code>；如果没有加速度，虽然<code>scrollViewWillBeginDecelerating(_:)</code>不会被调用，但前一次留下的<code>scrollViewDidEndDecelerating(_:)</code>会被调用。</p>
<blockquote>
<p>P.S: 以上的解释比较拗口，动手体验一下就明白了。</p>
</blockquote>
<ul>
<li><code>scrollViewDidEndScrollingAnimation(_:)</code></li>
</ul>
<p>当通过代码滑动scroll view时（<code>setContentOffset(_:animated:)</code>或者<code>scrollRectVisible(_:animated:)</code>），动画结束时会调用该方法；值得一提的是，当且仅当动画存在时才会调用该方法。</p>
<h2 id="Scrolling-With-Finger"><a href="#Scrolling-With-Finger" class="headerlink" title="Scrolling With Finger"></a>Scrolling With Finger</h2><p>我总结了一些手指控制UIScrollView滑动的场景，将相关的回调给列出来了。</p>
<p><strong>场景一：一次正常的滑动-减速-停止</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 手指介入</span></div><div class="line">scrollViewWillBeginDragging(<span class="number">_</span>:)</div><div class="line"><span class="comment">// 开始滑动</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)                     <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)                     <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指离开屏幕（scrolling继续，并未停滞）</span></div><div class="line">scrollViewWillEndDragging(scrollView:withVelocity:targetContentOffset:)</div><div class="line">scrollViewDidEndDragging(<span class="number">_</span>:willDecelerate:) <span class="comment">// 拖拽结束（willDecelerate=true）</span></div><div class="line">scrollViewWillBeginDecelerating(<span class="number">_</span>:)         <span class="comment">// 减速</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)                     <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)                     <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">scrollViewDidEndDecelerating(<span class="number">_</span>:)            <span class="comment">// 减速结束</span></div></pre></td></tr></table></figure>
<p><strong>场景二：减速过程中的手指介入（点停）</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 手指介入</span></div><div class="line">scrollViewWillBeginDragging(<span class="number">_</span>:)</div><div class="line"><span class="comment">// 开始滑动</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指离开屏幕（scrolling继续，并未停滞）</span></div><div class="line">scrollViewWillEndDragging(scrollView:withVelocity:targetContentOffset:)</div><div class="line">scrollViewDidEndDragging(<span class="number">_</span>:willDecelerate:) <span class="comment">// 拖拽结束（willDecelerate=true）</span></div><div class="line">scrollViewWillBeginDecelerating(<span class="number">_</span>:)         <span class="comment">// 减速</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指介入（scrolling停止 -- 之前的操作被取消）</span></div><div class="line">scrollViewWillBeginDragging(<span class="number">_</span>:)</div><div class="line"><span class="comment">// 手指离开屏幕</span></div><div class="line">scrollViewWillEndDragging(scrollView:withVelocity:targetContentOffset:)</div><div class="line">scrollViewDidEndDragging(<span class="number">_</span>:willDecelerate:)     <span class="comment">// 拖拽结束（willDecelerate=false）</span></div><div class="line">scrollViewDidEndDecelerating(<span class="number">_</span>:)                <span class="comment">// 减速结束</span></div></pre></td></tr></table></figure>
<p><strong>场景三：减速过程中的手指介入（乱滑）</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 手指介入</span></div><div class="line">scrollViewWillBeginDragging(<span class="number">_</span>:)</div><div class="line"><span class="comment">// 开始滑动</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指离开屏幕（scrolling继续，并未停滞）</span></div><div class="line">scrollViewWillEndDragging(scrollView:withVelocity:targetContentOffset:)</div><div class="line">scrollViewDidEndDragging(<span class="number">_</span>:willDecelerate:) <span class="comment">// 拖拽结束（willDecelerate=true）</span></div><div class="line">scrollViewWillBeginDecelerating(<span class="number">_</span>:)         <span class="comment">// 减速</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指介入--重新拖拽（scrolling停止 -- 之前的操作被取消）</span></div><div class="line">scrollViewWillBeginDragging(<span class="number">_</span>:)</div><div class="line"><span class="comment">// 开始滑动</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指离开屏幕（scrolling继续，并未停滞）</span></div><div class="line">scrollViewWillEndDragging(scrollView:withVelocity:targetContentOffset:)</div><div class="line">scrollViewDidEndDragging(<span class="number">_</span>:willDecelerate:) <span class="comment">// 拖拽结束（willDecelerate=true）</span></div><div class="line">scrollViewWillBeginDecelerating(<span class="number">_</span>:)         <span class="comment">// 减速</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line">scrollViewDidScroll(<span class="number">_</span>:)             <span class="comment">// scrolling...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 手指介入--点停（scrolling停止 -- 之前的操作被取消）</span></div><div class="line">scrollViewWillBeginDragging(<span class="number">_</span>:)</div><div class="line"></div><div class="line"><span class="comment">// 手指离开屏幕</span></div><div class="line">scrollViewWillEndDragging(scrollView:withVelocity:targetContentOffset:)</div><div class="line">scrollViewDidEndDragging(<span class="number">_</span>:willDecelerate:)     <span class="comment">// 拖拽结束（willDecelerate=false）</span></div><div class="line">scrollViewDidEndDecelerating(<span class="number">_</span>:)                <span class="comment">// 减速结束</span></div></pre></td></tr></table></figure>
<h2 id="Scrolling-Programmatically"><a href="#Scrolling-Programmatically" class="headerlink" title="Scrolling Programmatically"></a>Scrolling Programmatically</h2><p><strong>Scrolling to a Specific Offset</strong></p>
<p>可通过设置content offset让scrollView滚动到某个指定位置，有两种方式：一是直接给<code>contentOffset</code>属性赋值，二是调用<code>setContentOffset(_:animated:)</code>方法。对于第二种，当<code>animated</code>参数设置为NO，等效于第一种方式。</p>
<p>无论是哪一种情况，<code>delegate</code>都会接收到<code>scrollViewDidScroll(_:)</code>消息。</p>
<p>只是当禁止动画时，<code>delegate</code>只会收到一次<code>scrollViewDidScroll(_:)</code>消息；当允许动画时，<code>delegate</code>会在动画过程中接收到一系列<code>scrollViewDidScroll(_:)</code>消息，并且当动画结束时，<code>delegate</code>还会接收到<code>scrollViewDidEndScrollingAnimation(_:)</code>消息。</p>
<p><strong>Making a rectangle visible</strong></p>
<p>还可以调用<code>scrollRectToVisible(_:animated:)</code>方法让scrollView滚动到一个合适的位置以使指定区域可见，<code>animated</code>参数依然是用来控制动画开关的。当关闭动画时，<code>delegate</code>会接收到一次<code>scrollViewDidScroll(_:)</code>消息；当允许动画时，<code>delegate</code>会在动画过程中接收到一系列<code>scrollViewDidScroll(_:)</code>消息，并且当动画结束时，<code>delegate</code>还会接收到<code>scrollViewDidEndScrollingAnimation(_:)</code>消息。</p>
<p><strong>Scroll To Top</strong></p>
<p><code>UITableView</code>等子类还实现了Scroll To Top功能，这里不赘述了，详细参考<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/UIScrollView_pg/ScrollingViewContent/ScrollingViewContent.html" target="_blank" rel="external">这里</a>。</p>
<h2 id="Tracking-The-Start-and-Completion-Of-A-Scroll-Action"><a href="#Tracking-The-Start-and-Completion-Of-A-Scroll-Action" class="headerlink" title="Tracking The Start and Completion Of A Scroll Action"></a>Tracking The Start and Completion Of A Scroll Action</h2><p>Implement the scrollViewWillBeginDragging: method to receive notification that dragging will begin.</p>
<p>当编程实现滚动（设置<code>contentOffset</code>、）时，<code>scrollViewWillBeginDragging:</code>也会被调用吗？</p>
<p>To determine when scrolling is complete you must implement two delegate methods: scrollViewDidEndDragging:willDecelerate: and scrollViewDidEndDecelerating:. Scrolling is completed either when the delegate receives the scrollViewDidEndDragging:willDecelerate: message with NO as the decelerate parameter, or when your delegate receives the scrollViewDidEndDecelerating: method. In either case, scrolling is complete.</p>
<p><strong>编程实现滚动时抗干扰</strong></p>
<p>在开始和结束时设置<code>userInteractionEnabled</code>属性即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">scrollView.userInteractionEnabled = <span class="literal">false</span></div><div class="line">scrollView.setContentOffset(<span class="type">CGPointZero</span>, animated: <span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndScrollingAnimation</span><span class="params">(scrollView: UIScrollView)</span></span> &#123;</div><div class="line">  scrollView.userInteractionEnabled = <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h2><p><strong>不可描述的问题</strong></p>
<p>一般来说，在UIScrollView静止状态下，点击（只是轻点一下）不会触发UIScrollViewDelegate相关的回调，但曾在开发中遇到了一件诡异的事情，点击静止状态下的UIScrollView会触发<code>scrollViewWillBeginDecelerating(_:)</code>和<code>scrollViewDidEndDecelerating(_:)</code>回调，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">  [<span class="keyword">super</span> viewDidLoad];</div><div class="line">  </div><div class="line">  <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">  </div><div class="line">  <span class="built_in">UIScrollView</span> *scrollView = [[<span class="built_in">UIScrollView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">30</span>, <span class="number">100</span>, <span class="number">200</span>)];</div><div class="line">  scrollView.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">  scrollView.bounces = <span class="literal">NO</span>;</div><div class="line">  scrollView.contentSize = <span class="built_in">CGSizeMake</span>(<span class="number">160</span>, <span class="number">200</span>);</div><div class="line">  scrollView.pagingEnabled = <span class="literal">YES</span>;</div><div class="line">  scrollView.showsHorizontalScrollIndicator = <span class="literal">NO</span>;</div><div class="line">  scrollView.delegate = <span class="keyword">self</span>;</div><div class="line">  </div><div class="line">  [<span class="keyword">self</span>.view addSubview:scrollView];</div><div class="line">  </div><div class="line">  <span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">60</span>, <span class="number">200</span>)];</div><div class="line">  view1.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">  [scrollView addSubview:view1];</div><div class="line">  </div><div class="line">  <span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">60</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>)];</div><div class="line">  view2.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</div><div class="line">  [scrollView addSubview:view2];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>排查了好久，最终发现问题出在<code>scrollView.pagingEnabled = YES</code>这里，以上的scroll view允许paging，然而，其<code>contentSize.width</code>并不是<code>size.width</code>的整数倍，这会让它显式最后一页时没办法达到稳定状态，该情况下点击UIScrollView会触发<code>scrollViewWillBeginDecelerating(_:)</code>和<code>scrollViewDidEndDecelerating(_:)</code>。该情景不太容易描述…</p>
<p><strong>UIScrollView Custom Paging</strong></p>
<p>通过回调<code>scrollViewWillEndDragging(_:withVelocity:targetContentOffset:)</code>可以在<code>UIScrollView#pagingEnabled</code>设为<code>false</code>的情况下自己实现paging效果。然而，用户体验并不好，至少不如<code>UIScrollView#pagingEnabled = true</code>顺畅，参考<a href="http://stackoverflow.com/questions/6945964/uiscrollview-custom-paging" target="_blank" rel="external">这里</a>，不晓得有没什么办法改善操作体验。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/UIScrollView_pg/ScrollingViewContent/ScrollingViewContent.html" target="_blank" rel="external">Scroll View Programming Guide for iOS</a></li>
<li><a href="http://tech.glowing.com/cn/practice-in-uiscrollview/" target="_blank" rel="external">UIScrollView实践经验</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UIScrollView/">UIScrollView</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>