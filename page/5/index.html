<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/5/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/iOS/">Android相关</a></li>
				        
							<li><a href="/categories/essay">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.67px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 15px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 18.33px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.67px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 20px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 13.33px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 16.67px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.67px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/Transition/" style="font-size: 13.33px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，Android开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/iOS/">Android相关</a></li>
		        
					<li><a href="/categories/essay">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-beginning-auto-layout-part-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/16/beginning-auto-layout-part-1/" class="article-date">
  	<time datetime="2015-07-16T01:10:31.000Z" itemprop="datePublished">2015-07-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/16/beginning-auto-layout-part-1/">深入理解Auto Layout 第一弹</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>iOS的的布局机制「auto layout」不是一个新概念，它早在iOS 6中就推出来了，当下距离iOS 9正式版面世已不远矣，我却对它的了解还比较初级。</p>
<p>我之前对auto layout机制的理解非常粗浅，几乎把它和「constraint」对等。对它的使用有这么几个阶段：</p>
<ol>
<li>Storyboard中通过拖拽设置constraints；</li>
<li>学习VFL（Visual Format Language）语法使用代码设置constraints；</li>
<li>使用大杀器<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">Masonry</a>。</li>
</ol>
<blockquote>
<p>P.S: iOS的VFL语法实在太罗嗦了，又臭又长且可读性差难于调试，无法忍受，Masonry正是解决这一痛点的第三方库，非常好用，学习成本非常低。</p>
</blockquote>
<p>近期因为项目，我需要实现一个能够自适应文本自动调整高度的table view cell。网上有相关丰富的资源（category、博客等），思路都非常简单，比如这篇：<a href="http://www.cocoachina.com/industry/20140604/8668.html" target="_blank" rel="external">动态计算UITableViewCell高度详解</a>。但即便如此，我对有些东西理解起来还有障碍，譬如<code>systemLayoutSizeFittingSize:</code>和<code>sizeThatFits:</code>之类的，想到我都将近有大半年的开发经验了，居然还无法理解这么简单的东西，不能忍！</p>
<p>导致这种结果的主要原因有俩：一是之前项目比较简单，涉及auto layout相关的知识无非是add/update/remove constraints；二是自己太轻浮，把auto layout想得太简单；</p>
<p>通过对各种资讯梳理，大概搞明白了自己最大的问题是对auto layout相关的各种API不熟悉或者完全陌生，这导致了无法在一些实际问题中使用正确的策略解决问题。本文的着重点正是结合各种资料加上自己的理解对这些API进行分析。<br>本文涉及的API包括：</p>
<ul>
<li><code>sizeThatFits:</code>和<code>sizeToFit</code></li>
<li><code>systemLayoutSizeFittingSize:</code></li>
<li><code>intrinsicContentSize</code></li>
</ul>
<blockquote>
<p>P.S: 这几个API都是与size相关，该如何使用它们呢？这曾让笔者一时非常困惑。以上这几个API都是UIView的实例方法，除此之外，本文还涉及一些属性，譬如<code>preferredMaxLayoutWidth</code>。</p>
</blockquote>
<h2 id="iOS布局机制"><a href="#iOS布局机制" class="headerlink" title="iOS布局机制"></a>iOS布局机制</h2><p>iOS布局机制大概分这么几个层次：</p>
<ul>
<li>frame layout</li>
<li>autoresizing</li>
<li>auto layout</li>
</ul>
<p><strong>frame layout</strong></p>
<p>frame layout最简单直接，简单来说，即通过设置view的<code>frame</code>属性值进而控制view的位置（相对于superview的位置）和大小。</p>
<p><strong>autoresizing</strong></p>
<p>autoresizing和frame layout一样，从一开始存在，它算是后者的补充，基于autoresizing机制，能够让subview和superview维持一定的布局关系，譬如让subview的大小适应superview的大小，随着后者的改变而改变。</p>
<p>站在代码接口的角度来看，autoresizing主要体现在几个属性上，包括（但不限于）：</p>
<ol>
<li><code>translatesAutoresizingMaskIntoConstraints</code></li>
<li><code>autoresizingMask</code></li>
</ol>
<p>第一个属性标识view是否愿意被autoresize；<br>第二个属性是一个枚举值，决定了当superview的size改变时，subview应该做出什么样的调整；</p>
<p>关于autoresizing的更详细使用说明，参考：<a href="http://www.cocoachina.com/ios/20141216/10652.html" target="_blank" rel="external">自动布局之autoresizingMask使用详解</a>。</p>
<p><strong>auto layout</strong></p>
<p>autoresizing存在的不足是非常显著的，通过<code>autoresizingMask</code>的可选枚举值可以看出：基于autoresizing机制，我们只能让view在superview的大小改变时做些调整；而无法处理兄弟view之间的关系，譬如处理与兄弟view的间隔；更无法反向处理，譬如让superview依据subview的大小进行调整。</p>
<p>Auto Layout是随着iOS 6推出来的，关于它的介绍，官方文档《Auto Layout Guide》的描述非常精炼：</p>
<blockquote>
<p>Auto Layout is a system that lets you lay out your app’s user interface by creating a mathematical description of the relationships between the elements. You define these relationships in terms of constraints either on individual elements, or between sets of elements. Using Auto Layout, you can create a dynamic and versatile interface that responds appropriately to changes in screen size, device orientation, and localization.</p>
</blockquote>
<p>简单来说，它是一种基于约束的布局系统，可以根据你在元素（对象）上设置的约束自动调整元素（对象）的位置和大小。</p>
<p>值得一提的是，对于某个view的布局方式，autoresizing和auto layout只能二选一，简单来说，若要对某个view采用auto layout布局，则需要设置其<code>translatesAutoresizingMaskIntoConstraints</code>属性值为<code>NO</code>。</p>
<h2 id="几个重要的API"><a href="#几个重要的API" class="headerlink" title="几个重要的API"></a>几个重要的API</h2><p><strong>intrinsicContentSize方法</strong></p>
<p>在介绍<code>intrinsicContentSize</code>方法之前，先来看一个应用场景：</p>
<p>场景一：某个UILabel用于显示<strong>单行</strong>文本，让其能够自适应文本，即根据文本自动调整其大小。</p>
<p>让UILabel自适应文本，在auto layout之前，一般做法是先给定字体，进而计算文本内容所占据的宽度width和高度height，然后使用得来的width和height设置其<code>frame</code>属性值。</p>
<p>但是使用auto layout非常简单，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () </span>&#123;</div><div class="line">    <span class="built_in">UILabel</span> *testLabel;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">    </div><div class="line">    testLabel = (&#123;</div><div class="line">        <span class="built_in">UILabel</span> *label        = [[<span class="built_in">UILabel</span> alloc] init];</div><div class="line">        label.textAlignment   = <span class="built_in">NSTextAlignmentCenter</span>;</div><div class="line">        label.font            = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">14.0</span>];</div><div class="line">        label.textColor       = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">        label.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">        label;</div><div class="line">    &#125;);</div><div class="line">    [<span class="keyword">self</span>.view addSubview:testLabel];</div><div class="line">    </div><div class="line">    <span class="comment">// 使用Masonry添加constraints</span></div><div class="line">    [testLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.top.equalTo(<span class="keyword">self</span>.view.mas_top).offset(<span class="number">40</span>);</div><div class="line">        make.left.equalTo(<span class="keyword">self</span>.view.mas_left).offset(<span class="number">10</span>);</div><div class="line">    &#125;];</div><div class="line">    testLabel.text = <span class="string">@"天地玄黄 宇宙洪荒 日月盈昃 辰宿列张"</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testLabel.origin = %@"</span>, <span class="built_in">NSStringFromCGPoint</span>(testLabel.frame.origin));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testLabel.size = %@"</span>, <span class="built_in">NSStringFromCGSize</span>(testLabel.frame.size));</div><div class="line">    <span class="comment">// print: "testLabel.origin = &#123;10, 40&#125;"</span></div><div class="line">    <span class="comment">// print: "testLabel.size = &#123;236.5, 17&#125;"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<div class="imagediv" style="width: 320px; height: 100px"></div>

<p>问题来了，auto layout system知道testLabel的size呢？</p>
<p>OK，就此引入API <code>intrinsicContentSize</code>。</p>
<p><code>intrinsicContentSize</code>是UIView的基础方法（Available in iOS 6.0 and later），<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/" target="_blank" rel="external">UIView Class References</a>对它的描述如下：</p>
<blockquote>
<p>Returns the natural size for the receiving view, considering only properties of the view itself.<br>&nbsp;<br><strong>Return Value</strong><br>A size indicating the natural size for the receiving view based on its intrinsic properties.<br>&nbsp;<br><strong>Discussion</strong><br>Custom views typically have content that they display of which the layout system is unaware. Overriding this method allows a custom view to communicate to the layout system what size it would like to be based on its content. This intrinsic size must be independent of the content frame, because there’s no way to dynamically communicate a changed width to the layout system based on a changed height, for example.<br>If a custom view has no intrinsic size for a given dimension, it can return UIViewNoIntrinsicMetric for that dimension.</p>
</blockquote>
<p>「intrinsic content size」在中文世界里常被译作：「固有内容大小」，简单来说，<strong>它被用来告诉auto layout system应该给它分配多大的size</strong>。</p>
<p>所以呢，在上文代码（<strong>场景一</strong>的Solution）中，根据我的理解，layout工作流程是这样的：在layout时，auto layout system会去回调testLabel的实例方法<code>intrinsicContentSize</code>，该方法能够根据「文本内容+字体」计算出content的size，进而根据此size对testLabel进行布局。</p>
<p>为了验证这个说法，对上述代码做些改变。</p>
<p>首先定义一个继承自UILabel的类ZWLabel，重写ZWLabel的<code>intrinsicContentSize</code>方法，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZWLabel</span> : <span class="title">UILabel</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div><div class="line">    </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZWLabel</span></span></div><div class="line">    </div><div class="line">- (<span class="built_in">CGSize</span>)intrinsicContentSize &#123;</div><div class="line">    <span class="built_in">CGSize</span> size = [<span class="keyword">super</span> intrinsicContentSize];</div><div class="line">    size.width  += <span class="number">20</span>;</div><div class="line">    size.height += <span class="number">20</span>;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>然后让上文的<code>testLabel</code>从<code>UILabel</code>的实例改为<code>ZWLabel</code>的实例，其余不变：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">testLabel = (&#123;</div><div class="line">    ZWLabel *label = [[ZWLabel alloc] init];</div><div class="line">    <span class="comment">//...</span></div><div class="line">    label;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<div class="imagediv" style="width: 320px; height: 110px"></div>

<p>效果明显，本示例较为直观说明了<code>intrinsicContentSize</code>这个API的作用了，这个API是为auto layout system的callback提供的！</p>
<p>P.S：笔者刚开始对<code>intrinsicContentSize</code>这个API的用法感到非常疑惑，在我的理解里，它有两种可能：</p>
<ol>
<li>Auto Layout System会根据content为view设置一个合适的size，开发者有时需要知道这个size，因此可以通过<code>intrinsicContentSize</code>获取；</li>
<li>Auto Layout System在layout时，不知道该为view分配多大的size，因此回调view的<code>intrinsicContentSize</code>方法，该方法会给auto layout system一个合适的size，system根据此size对view的大小进行设置；</li>
</ol>
<p>现在看来，第二种理解更靠谱！</p>
<p>对于上文所用到的<code>UILabel</code>，想必Cocoa在实现<code>intrinsicContentSize</code>方法时已经根据<code>text</code>属性值和<code>font</code>属性值进行了计算。那是不是每个原生view都实现了<code>intrinsicContentSize</code>呢？</p>
<p>NO！《<a href="https://developer.apple.com/library/watchos/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutConcepts/AutoLayoutConcepts.html" target="_blank" rel="external">Auto Layout Guide</a>》在谈论「intrinsic content size」时，总会与另外一个词语「leaf-level views」相关联，譬如：</p>
<blockquote>
<p><strong>Intrinsic Content Size</strong><br>Leaf-level views such as buttons typically know more about what size they should be than does the code that is positioning them. This is communicated through the <strong>intrinsic content size</strong>, which tells the layout system that a view contains some content that it doesn’t natively understand, and indicates how large that content is, intrinsically.</p>
</blockquote>
<p>「leaf-level views」指的是那种一般不包含任何subview的view，譬如<code>UILabel</code>、<code>UIButton</code>等，这类的view往往能够直接计算出content（譬如<code>UILabel</code>的text、<code>UIButton</code>的title，<code>UIImageView</code>的image）的大小。</p>
<p>但是有些view不包含content，譬如<code>UIView</code>，这种view被认为「has no intrinsic size」，它们的<code>intrinsicContentSize</code>返回的值是<code>(-1,-1)</code>。</p>
<blockquote>
<p>P.S: 官方文档中说的是：UIView’s default implementation is to return (UIViewNoIntrinsicMetric, UIViewNoIntrinsicMetric)，而UIViewNoIntrinsicMetric等于<code>-1</code>，为什么是<code>-1</code>而不是<code>0</code>，我猜是<code>0</code>是一个有效的width/height，而<code>-1</code>不是，更容易区分处理。</p>
</blockquote>
<p>还有一种view虽然包含content，但是<code>intrinsicContentSize</code>返回值也是<code>(-1,-1)</code>，这类view往往是<code>UIScrollView</code>的子类，譬如<code>UITextView</code>，它们是可滚动的，因此auto layout system在对这类view进行布局时总会存在一些未定因素，Cocoa干脆让这些view的<code>intrinsicContentSize</code>返回<code>(-1,-1)</code>。</p>
<p><strong>preferredMaxLayoutWidth属性</strong></p>
<p>基于上述<strong>场景一</strong>，我们来分析更复杂一点的UILabel自适应问题。</p>
<p>场景二：某个UILabel用于显示<strong>多行</strong>文本，让其能够自适应文本，即根据文本自动调整其大小；</p>
<p>对于单行文本UILabel，UILabel的<code>intrinsicContentSize</code>在计算content size时比较容易；但对于多行文本的UILabel，同样的content，譬如「天地玄黄宇宙洪荒」这八个字，摆放方式可以是1x8，可以是2x4，可以是4x2，auto layout system该如何处理呢？UILabel的属性<code>preferredMaxLayoutWidth</code>正是用来应对这个问题的。</p>
<p><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UILabel_Class/" target="_blank" rel="external">UILabel Class References</a>对它的描述如下：</p>
<blockquote>
<p>The preferred maximum width (in points) for a multiline label.<br>&nbsp;<br><strong>Discussion</strong><br>This property affects the size of the label when layout constraints are applied to it. During layout, if the text extends beyond the width specified by this property, the additional text is flowed to one or more new lines, thereby increasing the height of the label.</p>
</blockquote>
<p><code>preferredMaxLayoutWidth</code>的作用顾名思义，用来限制UILabel content size的最大宽度值。如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">testLabel = (&#123;</div><div class="line">    <span class="built_in">UILabel</span> *label                = [[<span class="built_in">UILabel</span> alloc] init];</div><div class="line">    label.textAlignment           = <span class="built_in">NSTextAlignmentCenter</span>;</div><div class="line">    label.font                    = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">14.0</span>];</div><div class="line">    label.textColor               = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">    label.numberOfLines           = <span class="number">0</span>;      <span class="comment">// mark</span></div><div class="line">    label.preferredMaxLayoutWidth = <span class="number">100</span>;    <span class="comment">// mark</span></div><div class="line">    label.backgroundColor         = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">    label;</div><div class="line">&#125;);</div><div class="line">[<span class="keyword">self</span>.view addSubview:testLabel];</div><div class="line">    </div><div class="line"><span class="comment">// 使用Masonry添加constraints</span></div><div class="line">[testLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.top.equalTo(<span class="keyword">self</span>.view.mas_top).offset(<span class="number">40</span>);</div><div class="line">    make.left.equalTo(<span class="keyword">self</span>.view.mas_left).offset(<span class="number">10</span>);</div><div class="line">&#125;];</div><div class="line">    </div><div class="line">testLabel.text = <span class="string">@"天地玄黄 宇宙洪荒 日月盈昃 辰宿列张"</span>;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<div class="imagediv" style="width: 320px; height: 120px"></div>

<p>那么最后<code>testLabel</code>的width是不是就是<code>preferredMaxLayoutWidth</code>的属性值呢？No，最终<code>testLabel</code>的属性值小于等于<code>preferredMaxLayoutWidth</code>的属性值。</p>
<p><strong>sizeThatFits:方法和sizeToFit方法</strong></p>
<p>上文已经提到，<code>UITextView</code>继承自<code>UIScrollView</code>，是可以滚动的，它的<code>intrinsicContentSize</code>方法返回值是<code>(-1,-1)</code>，auto layout system在处理UITextView对象时，为其设置的size是<code>(0,0)</code>。如此看来，似乎<code>UITextView</code>无法体验到auto layout带来的好处了。</p>
<p>继续结合应用场景引出<code>sizeThatFits:</code>方法和<code>sizeToFit</code>方法。</p>
<p>场景三：某个<code>UITextView</code>用于显示文本，让其能够自适应文本，即根据文本自动调整其大小；</p>
<p>既然UITextView的content计算方法<code>intrinsicContentSize</code>无法向auto layout system传递我们想要传达的值，我们就应该另想别的方法。</p>
<p>好在iOS有直接的接口可供我们使用。</p>
<p>先谈<code>sizeThatFits:</code>方法，<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/" target="_blank" rel="external">UIView Class References</a>对它的描述如下：</p>
<blockquote>
<p>Asks the view to calculate and return the size that best fits the specified size.<br>&nbsp;<br><strong>Return Value</strong><br>A new size that fits the receiver’s subviews.<br>&nbsp;<br><strong>Discussion</strong><br>The default implementation of this method returns the existing size of the view. Subclasses can override this method to return a custom value based on the desired layout of any subviews. For example, a UISwitch object returns a fixed size value that represents the standard size of a switch view, and a UIImageView object returns the size of the image it is currently displaying.</p>
</blockquote>
<p>简单来说，调用<code>sizeThatFits:</code>方法意味着「根据文本计算最适合UITextView的size」。从功能来讲，<code>sizeThatFits:</code>和<code>intrinsicContentSize</code>方法比较类似，都是用来计算view的size的。笔者曾一度对二者的关系非常疑惑，甚至觉得二者存在相互调用的关系。后来通过验证发现不是这么回事儿，后文会通过示例说明。</p>
<p>对于显示多行文本的<code>UILabel</code>，为了方便<code>intrinsicContentSize</code>方法更方便计算content size，需要指定<code>preferredMaxLayoutWidth</code>属性值；对于<code>UITextView</code>的<code>sizeThatFits:</code>，似乎有类似的需求，毕竟<code>UITextView</code>也可能会显示多行啊，这样说来，<code>UITextView</code>也有一个<code>preferredMaxLayoutWidth</code>属性？</p>
<p>No！<code>preferredMaxLayoutWidth</code>属性是iOS 6才引入的，<code>sizeThatFits:</code>方法则早得多，况且，<code>UITextView</code>是可以滚动的，哪怕文本不会全部呈现出来，但也可以通过左右或者上下滚动浏览所有内容；传给<code>sizeThatFits:</code>的参数（假设为size）是<code>CGSize</code>类型，size.width的功能和<code>UILabel</code>的<code>preferredMaxLayoutWidth</code>差不多，指定了<code>UITextView</code>区域的最大宽度，size.height则指定了<code>UITextView</code>区域的最大高度；可能有人问，若传给<code>sizeThatFits:</code>的size小于<code>UITextView</code>的text面积怎么办，岂不是有些内容无法显示出来？傻啊，可以滚啊！</p>
<p>值得一提的是，调用<code>sizeThatFits:</code>并不改变view的size，它只是让view根据已有content和给定size计算出最合适的view.size。</p>
<p>那么<code>sizeToFit</code>方法是干嘛的呢？很简单：</p>
<blockquote>
<p>calls sizeThatFits: with current view bounds and changes bounds size.</p>
</blockquote>
<p>P.S：有点不太理解，这个「current view」指的是啥？self？还是superview？<br>P.P.S：经过验证，这里的「current view」指的是<code>self</code>。简单来说，<code>sizeToFit</code>等价于：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// calls sizeThatFits</span></div><div class="line"><span class="built_in">CGSize</span> size = [<span class="keyword">self</span> sizeThatFits:<span class="keyword">self</span>.bounds.size];</div><div class="line"><span class="comment">// change bounds size</span></div><div class="line"><span class="built_in">CGRect</span> bounds = <span class="keyword">self</span>.bounds;</div><div class="line">bounds.size.width = size.width;</div><div class="line">bounds.size.height = size.width;</div><div class="line"><span class="keyword">self</span>.bounds = bounds;</div></pre></td></tr></table></figure>
<p>P.S：值得一提的是，经过测试发现，当调用<code>sizeThatFits:</code>的<code>size=(width, height)</code>，当width/height的值为0时，width/height似乎就被认为是无穷大！</p>
<p><strong>systemLayoutSizeFittingSize:方法</strong></p>
<p>首先来看一个应用场景。</p>
<p>场景四：某个<code>UIView</code>，宽度等于屏幕宽度，包含两个<code>UILabel</code>，两个label都可能显示多行文本，要求结合auto layout让<code>UIView</code>大小能够自适应subviews。</p>
<p>Easy，给出如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">    </div><div class="line">    bgView = (&#123;</div><div class="line">        <span class="built_in">UIView</span> *view         = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">        view.backgroundColor = [<span class="built_in">UIColor</span> grayColor];</div><div class="line">        view;</div><div class="line">    &#125;);</div><div class="line">    [<span class="keyword">self</span>.view addSubview:bgView];</div><div class="line">    </div><div class="line">    label1 = (&#123;</div><div class="line">        <span class="built_in">UILabel</span> *label                = [[<span class="built_in">UILabel</span> alloc] init];</div><div class="line">        label.font                    = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">14.0</span>];</div><div class="line">        label.preferredMaxLayoutWidth = <span class="keyword">self</span>.view.frame.size.width<span class="number">-20</span>;</div><div class="line">        label.numberOfLines           = <span class="number">0</span>;</div><div class="line">        label.textColor               = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">        label.backgroundColor         = [<span class="built_in">UIColor</span> purpleColor];</div><div class="line">        label;</div><div class="line">    &#125;);</div><div class="line">    [bgView addSubview:label1];</div><div class="line">    </div><div class="line">    label2 = (&#123;</div><div class="line">        <span class="built_in">UILabel</span> *label                = [[<span class="built_in">UILabel</span> alloc] init];</div><div class="line">        label.font                    = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">18.0</span>];</div><div class="line">        label.preferredMaxLayoutWidth = <span class="keyword">self</span>.view.frame.size.width<span class="number">-20</span>;</div><div class="line">        label.numberOfLines           = <span class="number">0</span>;</div><div class="line">        label.textColor               = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">        label.backgroundColor         = [<span class="built_in">UIColor</span> redColor];</div><div class="line">        label;</div><div class="line">    &#125;);</div><div class="line">    [bgView addSubview:label2];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加约束（基于Masonry）</span></div><div class="line">    [bgView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.left.equalTo(<span class="keyword">self</span>.view.mas_left);</div><div class="line">        make.top.equalTo(<span class="keyword">self</span>.view.mas_top).offset(<span class="number">10</span>);</div><div class="line">        make.width.equalTo(<span class="keyword">self</span>.view.mas_width);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [label1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.left.equalTo(bgView.mas_left).offset(<span class="number">10</span>);</div><div class="line">        make.right.lessThanOrEqualTo(bgView.mas_right).offset(<span class="number">-10</span>);</div><div class="line">        make.top.equalTo(bgView.mas_top).offset(<span class="number">10</span>);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [label2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.left.equalTo(label1.mas_left);</div><div class="line">        make.right.lessThanOrEqualTo(bgView.mas_right).offset(<span class="number">-10</span>);</div><div class="line">        make.top.equalTo(label1.mas_bottom).offset(<span class="number">10</span>);</div><div class="line">        make.bottom.equalTo(bgView.mas_bottom).offset(<span class="number">-10</span>);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    label1.text = <span class="string">@"天地玄黄 宇宙洪荒 日月盈昃 辰宿列张 寒来暑往 秋收冬藏 闰余成岁 律吕调阳"</span>;</div><div class="line">    label2.text = <span class="string">@"天地玄黄 宇宙洪荒 日月盈昃 辰宿列张 寒来暑往 秋收冬藏 闰余成岁 律吕调阳"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码看得有些枯燥，简单来说，bgView（UIView）中嵌入两个能显示多行文本的label1（UILabel）和label2（UILabel），设置约束如下：</p>
<div class="imagediv" style="width: 280px; height: 310px"></div>

<p>代码运行后的显示效果：</p>
<div class="imagediv" style="width: 320px; height: 170px"></div>

<p>代码中除了添加各种各样的constraints，没有任何设置frame的代码，显然都是基于auto layout的。</p>
<p>那么问题来了，理解label1和label2的布局没啥子问题，因为它们的<code>intrinsicContentSize</code>方法会将content size告诉auto layout system，进而后者会为它们的size设置对应值；但对于bgView，它可是一个<code>UIView</code>对象，它的<code>intrinsicContentSize</code>回调方法的返回值为<code>(-1,-1)</code>，那么auto layout system是如何为它设置合适的size的呢？</p>
<p>根据我的理解，auto layout system在处理某个view的size时，参考值包括：</p>
<ul>
<li>自身的<code>intrinsicContentSize</code>方法返回值；</li>
<li>subviews的<code>intrinsicContentSize</code>方法返回值；</li>
<li>自身和subviews的constraints；</li>
</ul>
<div class="imagediv" style="width: 570px; height: 340px"></div>

<p>OK，根据笔者理解，结合上图，我认为auto layout system是这样计算一下bgView的size的：</p>
<p>width=max{10+size1.width+10, 10+size2.width+10, size3.width}<br>height=max{10+size1.height+10+size2.height+10, size3.height}</p>
<p>我们在<code>viewDidAppear:</code>方法中将相关值打印出来瞧瞧看：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</div><div class="line">    </div><div class="line">    <span class="built_in">CGSize</span> size1 = [label1 intrinsicContentSize];</div><div class="line">    <span class="built_in">CGSize</span> size2 = [label2 intrinsicContentSize];</div><div class="line">    <span class="built_in">CGSize</span> size3 = [bgView intrinsicContentSize];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"size1 = %@"</span>, <span class="built_in">NSStringFromCGSize</span>(size1));    <span class="comment">// print: "size1 = &#123;300, 33.5&#125;"</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"size2 = %@"</span>, <span class="built_in">NSStringFromCGSize</span>(size2));    <span class="comment">// print: "size2 = &#123;290.5, 64.5&#125;"</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"size3 = %@"</span>, <span class="built_in">NSStringFromCGSize</span>(size3));    <span class="comment">// print: "size3 = &#123;-1, -1&#125;"</span></div><div class="line">    </div><div class="line">    <span class="built_in">CGSize</span> bgViewSize = bgView.frame.size;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"bgViewSize = %@"</span>, <span class="built_in">NSStringFromCGSize</span>(bgViewSize));  <span class="comment">// print: "bgViewSize = &#123;320, 128&#125;"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完全吻合我理解的auto layout size计算公式。</p>
<p>P.S：然而，我知道，事实往往并没有这么简单，当处理自定义View时，当constraints设置不完整或者冲突时，事情总会变得复杂起来，也总会得到意想不到的结果。但，暂且就这么理解吧！</p>
<p>啰里啰嗦写了这么多，还没引出<code>systemLayoutSizeFittingSize:</code>方法…</p>
<p>OK，再来看另外一个应用场景。</p>
<p>场景五：某个<code>UIView</code>，宽度等于屏幕宽度，包含一个<code>UILabel</code>和一个<code>UITextView</code>，二者都可能显示多行文本，要求结合auto layout让<code>UIView</code>大小能够自适应subviews。</p>
<p>在场景四代码基础上将label2改为UITextView对象textView1，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">    </div><div class="line">    bgView = (&#123;</div><div class="line">        <span class="built_in">UIView</span> *view         = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">        view.backgroundColor = [<span class="built_in">UIColor</span> grayColor];</div><div class="line">        view;</div><div class="line">    &#125;);</div><div class="line">    [<span class="keyword">self</span>.view addSubview:bgView];</div><div class="line">    </div><div class="line">    label1 = (&#123;</div><div class="line">        <span class="built_in">UILabel</span> *label                = [[<span class="built_in">UILabel</span> alloc] init];</div><div class="line">        label.font                    = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">14.0</span>];</div><div class="line">        label.preferredMaxLayoutWidth = <span class="keyword">self</span>.view.frame.size.width<span class="number">-20</span>;</div><div class="line">        label.numberOfLines           = <span class="number">0</span>;</div><div class="line">        label.textColor               = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">        label.backgroundColor         = [<span class="built_in">UIColor</span> purpleColor];</div><div class="line">        label;</div><div class="line">    &#125;);</div><div class="line">    [bgView addSubview:label1];</div><div class="line">    </div><div class="line">    textView1 = (&#123;</div><div class="line">        <span class="built_in">UITextView</span> *label     = [[<span class="built_in">UITextView</span> alloc] init];</div><div class="line">        label.font            = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">18.0</span>];</div><div class="line">        label.textColor       = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">        label.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">        label;</div><div class="line">    &#125;);</div><div class="line">    [bgView addSubview:textView1];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加约束（基于Masonry）</span></div><div class="line">    [bgView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.left.equalTo(<span class="keyword">self</span>.view.mas_left);</div><div class="line">        make.top.equalTo(<span class="keyword">self</span>.view.mas_top).offset(<span class="number">10</span>);</div><div class="line">        make.width.equalTo(<span class="keyword">self</span>.view.mas_width);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [label1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.left.equalTo(bgView.mas_left).offset(<span class="number">10</span>);</div><div class="line">        make.right.lessThanOrEqualTo(bgView.mas_right).offset(<span class="number">-10</span>);</div><div class="line">        make.top.equalTo(bgView.mas_top).offset(<span class="number">10</span>);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [textView1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.left.equalTo(label1.mas_left);</div><div class="line">        make.right.lessThanOrEqualTo(bgView.mas_right).offset(<span class="number">-10</span>);</div><div class="line">        make.top.equalTo(label1.mas_bottom).offset(<span class="number">10</span>);</div><div class="line">        make.bottom.equalTo(bgView.mas_bottom).offset(<span class="number">-10</span>);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    label1.text = <span class="string">@"天地玄黄 宇宙洪荒 日月盈昃 辰宿列张 寒来暑往 秋收冬藏 闰余成岁 律吕调阳"</span>;</div><div class="line">    textView1.text = <span class="string">@"天地玄黄 宇宙洪荒 日月盈昃 辰宿列张 寒来暑往 秋收冬藏 闰余成岁 律吕调阳"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<div class="imagediv" style="width: 320px; height: 110px"></div>

<p>这显然不是我们想要的结果，至少存在这么两个问题：</p>
<ol>
<li>textView1不见了；</li>
<li>bgView的大小不是我们想要的；</li>
</ol>
<p>为什么会有出现这样的问题呢？</p>
<p>首先正如上文所提到的那样，textView1是UITextView的对象，而UITextView是UIScrollView的子类，它的<code>intrinsicContentSize:</code>方法的返回值是<code>(-1,-1)</code>，这意味着textView1对bgView的auto layout size没有产生影响。</p>
<p>那textView1为什么不见了呢？或者说，为什么textView1的size为CGSizeZero呢？根据我对auto layout system的理解，auto layout system在处理view的size时，受三个因素影响：</p>
<ul>
<li>自身的<code>intrinsicContentSize</code>方法返回值；</li>
<li>subviews的<code>intrinsicContentSize</code>方法返回值；</li>
<li>自身和subviews的constraints；</li>
</ul>
<p>对于textView1，前两个因素可以忽略掉，简而言之，textView1的size由它自身的constraints决定。而根据上述代码的约束可以计算出textView1的height：<br>height = bgView.height-10-label1.height-10-10;</p>
<p>而bgView.height=10+label1.height+10+10；意味着textView1的height值为0；当然就看不到了textView1了。</p>
<p>因此，若想要让textView1正常可见，至少有这么一种策略：直接为textView1添加约束设置width和height；</p>
<p>简单来说，override回调方法<code>viewWillLayoutSubviews</code>，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewWillLayoutSubviews &#123;</div><div class="line">    [<span class="keyword">super</span> viewWillLayoutSubviews];</div><div class="line"></div><div class="line">    <span class="built_in">CGSize</span> textViewFitSize = [textView1 sizeThatFits:<span class="built_in">CGSizeMake</span>(<span class="keyword">self</span>.view.frame.size.width<span class="number">-20</span>, <span class="number">0</span>)];</div><div class="line">    [textView1 mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.width.equalTo([<span class="built_in">NSNumber</span> numberWithFloat:textViewFitSize.width]);</div><div class="line">        make.height.equalTo([<span class="built_in">NSNumber</span> numberWithFloat:textViewFitSize.height]);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种做法是有效的，运行效果如下：</p>
<div class="imagediv" style="width: 320px; height: 190px"></div>

<p>若将这种场景切换到table view cell中会如何呢？简单来说，如果将上述的bgView换成UITableViewCell（或其子类）对象又会如何呢？</p>
<p>在table view中，我们可以使用<code>- (CGFloat)tableView:heightForRowAtIndexPath:</code>接口，该回调方法会返回CGFloat值，该值指示了对应cell的高度；假设auto layout system为cell分配的size是autoSize，在处理返回值时额外加上textViewFitSize.height即可。</p>
<p>但问题是，我们如何获取这个autoSize的值呢？毕竟此时cell还未布局完成啊，直接读取cell.frame.size肯定是不行的。</p>
<p><code>systemLayoutSizeFittingSize:</code>方法正是用于处理这个问题的。</p>
<p><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/" target="_blank" rel="external">UIView Class References</a>对该方法描述如下：</p>
<blockquote>
<p>Returns the size of the view that satisfies the constraints it holds.<br>&nbsp;<br><strong>Return Value</strong><br>The size of the view that satisfies the constraints it holds.<br>&nbsp;<br><strong>Discussion</strong><br>Determines the best size of the view considering all constraints it holds and those of its subviews.</p>
</blockquote>
<p>我是这么理解<code>systemLayoutSizeFittingSize:</code>的：对于使用auto layout机制布局的view，auto layout system会在布局过程中综合各种约束的考虑为之设置一个size，在布局完成后，该size的值即为view.frame.size的值；这包含的另外一层意思，即在布局完成前，我们是不能通过view.frame.size准确获取view的size的。但有时候，我们需要在auto layout system对view完成布局前就知道它的size，<code>systemLayoutSizeFittingSize:</code>方法正是能够满足这种要求的API。<code>systemLayoutSizeFittingSize:</code>方法会根据其constraints返回一个合适的size值。</p>
<p><code>systemLayoutSizeFittingSize:</code>方法可传入一个参数，目前有两个值可以传入：</p>
<ul>
<li>UILayoutFittingCompressedSize : The option to use the smallest possible size.</li>
<li>UILayoutFittingExpandedSize : The option to use the largest possible size.</li>
</ul>
<p>值得一提的是，在使用<code>[view systemLayoutSizeFittingSize:]</code>时，要注意尽量确保view的constraints的完整性，这样参数UILayoutFittingCompressedSize和UILayoutFittingExpandedSize得到的结果是一样的。否则，举个例子，若view的right属性没有设置，则这两个参数得到<code>systemLayoutSizeFittingSize:</code>返回值size是不一样的，前者size.width=0，后者size.width=1000。<br>P.S：这纯属个人使用体验。</p>
<p>至于<code>systemLayoutSizeFittingSize:</code>的使用场景，<a href="http://www.cocoachina.com/industry/20140604/8668.html" target="_blank" rel="external">动态计算UITableViewCell高度详解</a>非常值得参考！</p>
<p><strong>对比几种API</strong></p>
<p>在刚开始接触这几个API时感到非常困惑。分不清<code>intrinsicContentSize</code>、<code>sizeThatFits:</code>以及<code>systemLayoutSizeFittingSize:</code>的区别。经过这么将近一天的折腾，现在大概有了基本的判断。</p>
<p>首先说<code>intrinsicContentSize</code>，它的最主要作用是告诉auto layout system一些信息，可以认为它是后者的回调方法，auto layout system在对view进行布局时会参考这个回调方法的返回值；一般很少像<code>CGSize size = [view intrinsicContentSize]</code>去使用<code>intrinsicContentSize</code> API。</p>
<p>再来看<code>sizeThatFits:</code>和<code>systemLayoutSizeFittingSize:</code>，它们俩非常相似，都是为开发者直接服务的API（而不是回调方法）。所不同的是，<code>sizeThatFits:</code>是auto layout之前就存在的，一般在leaf-level views中用得比较多，在计算size过程中，它可不会考虑constraints神马的；对于<code>systemLayoutSizeFittingSize:</code>，它是随着auto layout（iOS 6）引入的，用于在view完成布局前获取size值，如果view的constraints确保了完整性和正确性，通常它的返回值就是view完成布局之后的view.frame.size的值。</p>
<p>它们之前存在相互调用的关系吗？经过测试发现，三者之前没有直接的调用关系。但是能得出这样的结论：<code>intrinsicContentSize</code>的返回值会直接影响<code>systemLayoutSizeFittingSize:</code>的返回值。至于底层是如何处理的不得而知。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>本博客写了好多个小时，非常勉强，写完后不忍直视，臭又长。进一步意识到把博客写长不难，难的是把它写短同时传递足够多的信息。这在方面，我需要极大的提升啊！</p>
<p>用人话把技术讲清楚。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://stackoverflow.com/questions/24127032/proper-usage-of-intrinsiccontentsize-and-sizethatfits-on-uiview-subclass-with-a" target="_blank" rel="external">Proper usage of intrinsicContentSize and sizeThatFits: on UIView Subclass with autolayout</a></li>
<li><a href="http://stackoverflow.com/questions/27711853/how-to-set-a-labels-preferredmaxlayoutwidth-to-automatic-programmatically" target="_blank" rel="external">How to set a label’s preferredMaxLayoutWidth to automatic programmatically?</a></li>
<li><a href="http://stackoverflow.com/questions/18118021/how-to-resize-superview-to-fit-all-subviews-with-autolayout/18155803#18155803" target="_blank" rel="external">How to resize superview to fit all subviews with autolayout?</a></li>
<li><a href="http://stackoverflow.com/questions/18746929/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-variable-row-heights/18746930#18746930" target="_blank" rel="external">Using Auto Layout in UITableView for dynamic cell layouts &amp; variable row heights</a></li>
<li><a href="http://xuexuefeng.com/autolayout/" target="_blank" rel="external">iOS开发实践之Auto Layout</a></li>
<li><a href="http://www.cocoachina.com/industry/20140604/8668.html" target="_blank" rel="external">动态计算UITableViewCell高度详解</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Auto-Layout/">Auto Layout</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-objective-c-new-features-in-2015" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/26/objective-c-new-features-in-2015/" class="article-date">
  	<time datetime="2015-06-26T06:39:28.000Z" itemprop="datePublished">2015-06-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/26/objective-c-new-features-in-2015/">2015 Objective-C新特性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>转载说明</strong></p>
<p>本文完全转载自<a href="http://blog.sunnyxx.com/" target="_blank" rel="external">@sunnyxx</a>的博文《<a href="http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/" target="_blank" rel="external">2015 Objective-C 新特性</a>》。</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>自WWDC 2015推出和开源Swift 2.0后，大家对Swift的热情又一次高涨起来，在羡慕创业公司的朋友们大谈Swift新特性的同时，也有很多像我一样工作上依然需要坚守着Objective-C语言的开发者们。今年的WWDC中介绍了几个Objective-C语言的新特性，还是在「与Swift协同工作」这种Topic里讲的，越发凸显这门语言的边缘化了，不过有新特性还是极好的，接下来，本文将介绍下面三个主要的新特性：</p>
<ul>
<li>Nullability</li>
<li>Lightweight Generics</li>
<li>__kindof</li>
</ul>
<h2 id="Nullability"><a href="#Nullability" class="headerlink" title="Nullability"></a>Nullability</h2><p>然而Nullability并不算新特性了，从上一个版本的llvm 6.1 (Xcode 6.3) 就已经支持。这个简版的<code>Optional</code>，没有Swift中<code>?</code>和<code>!</code>语法糖的支持，在Objective-C中就显得非常啰嗦了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nonnull</span>) Sark *sark;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSArray</span> *friends;</div><div class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)friendWithName:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)name;</div></pre></td></tr></table></figure>
<p>假如用来修饰一个变量，前面还要加双下划线，放到block里面就更加诡异，比如一个Request的start方法可以写成：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)startWithCompletionBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSError</span> * __<span class="keyword">nullable</span> error))block;</div></pre></td></tr></table></figure>
<p>除了这俩外，还有个<code>null_resettable</code>来表示setter nullable，但是getter nonnull，绕死了，最直观例子就是UIViewController中的view属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">null_resettable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *view;</div></pre></td></tr></table></figure>
<p>它可以被设成<code>nil</code>，但是调用getter时会触发<code>-loadView</code>从而创建并返回一个非nil的view。<br>从iOS9 SDK中可以发现，头文件中所有API都已经增加了Nullability相关修饰符，想了解这个特性的用法，翻几个系统头文件就差不离了。接口中<code>nullable</code>的是少数，所以为了防止写一大堆<code>nonnull</code>，Foundation还提供了一对儿宏，包在里面的对象默认加<code>nonnull</code>修饰符，只需要把<code>nullable</code>的指出来就行，黑话叫Audited Regions：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *workingCompany;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *friends;</div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)gayFriend;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></div></pre></td></tr></table></figure>
<p>Nullability在编译器层面提供了空值的类型检查，在类型不符时给出warning，方便开发者第一时间发现潜在问题。不过我想更大的意义在于能够更加清楚的描述接口，是主调者和被调者间的一个协议，比多少句文档描述都来得清晰，打个比方：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)URLWithString:(<span class="built_in">NSString</span> *)URLString;</div></pre></td></tr></table></figure>
<p>NSURL的这个API前面加了<code>nullable</code>后，更加显式的指出了这个接口可能因为URLString的格式错误而创建失败，使用时自然而然的就考虑到了判空处理。<br>不仅是属性和方法中的对象，对于局部的对象、甚至C指针都可以用带双下划线的修饰符，可以理解成能用const关键字的地方都能用Nullability。<br>所以Nullability总的来说就是，写着丑B，用着舒服 - -</p>
<h2 id="Lightweight-Generics"><a href="#Lightweight-Generics" class="headerlink" title="Lightweight Generics"></a>Lightweight Generics</h2><p><strong>Lightweight Generics</strong>轻量级泛型，轻量是因为这是个纯编译器的语法支持（llvm 7.0），和Nullability一样，没有借助任何objc runtime的升级，也就是说，这个新语法在Xcode 7上可以使用且完全向下兼容（更低的 iOS 版本）。</p>
<p><strong>带泛型的容器</strong></p>
<p>这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *strings = @[<span class="string">@"sun"</span>, <span class="string">@"yuan"</span>];</div><div class="line"><span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSNumber</span> *&gt; *mapping = @&#123;<span class="string">@"a"</span>: @<span class="number">1</span>, <span class="string">@"b"</span>: @<span class="number">2</span>&#125;;</div></pre></td></tr></table></figure>
<p>返回值的<code>id</code>被替换成具体的类型后，令人感动的代码提示也出来了：</p>
<div class="imagediv" style="width: 348px; height: 43px"></div>

<p>假如向泛型容器中加入错误的对象，编译器会不开心的：</p>
<div class="imagediv" style="width: 444px; height: 53px"></div>

<p>系统中常用的一系列容器类型都增加了泛型支持，甚至连NSEnumerator都支持了，这是非常Nice的改进。和Nullability一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *imageURLs;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *imageURLs;</div></pre></td></tr></table></figure>
<p>不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。</p>
<p><strong>自定义泛型类</strong></p>
<p>比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Stack</span>&lt;<span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)pushObject:(ObjectType)object;</div><div class="line">- (ObjectType)popObject;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;ObjectType&gt; *allObjects;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个<code>ObjectType</code>是传入类型的placeholder，它只能在@interface上定义（类声明、类扩展、Category），如果你喜欢用<strong>T</strong>表示也ok，这个类型在@interface和@end区间的作用域有效，可以把它作为入参、出参、甚至内部NSArray属性的泛型类型，应该说一切都是符合预期的。我们还可以给ObjectType增加类型限制，比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只接受 NSNumber * 的泛型</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Stack</span>&lt;<span class="title">ObjectType</span>: <span class="title">NSNumber</span> *&gt; : <span class="title">NSObject</span></span></div><div class="line"><span class="comment">// 只接受满足 NSCopying 协议的泛型</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Stack</span>&lt;<span class="title">ObjectType</span>: <span class="title">id</span>&lt;<span class="title">NSCopying</span>&gt;&gt; : <span class="title">NSObject</span></span></div></pre></td></tr></table></figure>
<p>若什么都不加，表示接受任意类型（<code>id</code>）；当类型不满足时编译器将产生error。<br>实例化一个Stack，一切工作正常：</p>
<div class="imagediv" style="width: 417px; height: 72px"></div>

<p>对于多参数的泛型，用逗号隔开，其他都一样，可以参考NSDictionary的头文件。</p>
<p><strong>协变性和逆变性</strong></p>
<p>当类支持泛型后，它们的Type发生了变化，比如下面三个对象看上去都是Stack，但实际上属于三个Type：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Stack *stack; <span class="comment">// Stack *</span></div><div class="line">Stack&lt;<span class="built_in">NSString</span> *&gt; *stringStack; <span class="comment">// Stack&lt;NSString *&gt;</span></div><div class="line">Stack&lt;<span class="built_in">NSMutableString</span> *&gt; *mutableStringStack; <span class="comment">// Stack&lt;NSMutableString *&gt;</span></div></pre></td></tr></table></figure>
<p>当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：</p>
<div class="imagediv" style="width: 660px; height: 179px"></div>

<p>我们可以看到，不指定泛型类型的Stack可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的<strong>协变性</strong>和<strong>逆变性</strong>修饰符了：</p>
<ul>
<li><code>__covariant</code> - 协变性，子类型可以强转到父类型（里氏替换原则）</li>
<li><code>__contravariant</code> - 逆变性，父类型可以强转到子类型（WTF?）</li>
</ul>
<p>协变：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Stack</span>&lt;<span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span></span></div></pre></td></tr></table></figure>
<p>效果：</p>
<div class="imagediv" style="width: 697px; height: 103px"></div>

<p>逆变：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Stack</span>&lt;<span class="title">__contravariant</span> <span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span></span></div></pre></td></tr></table></figure></p>
<p>效果：</p>
<div class="imagediv" style="width: 695px; height: 97px"></div>

<p>协变是非常好理解的，像NSArray的泛型就用了协变的修饰符，而逆变我还没有想到有什么实际的使用场景。</p>
<h2 id="kindof"><a href="#kindof" class="headerlink" title="__kindof"></a>__kindof</h2><p><code>__kindof</code>这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的UITableView的这个方法来说：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)dequeueReusableCellWithIdentifier:(<span class="built_in">NSString</span> *)identifier;</div></pre></td></tr></table></figure>
<p>使用时前面基本会使用UITableViewCell子类型的指针来接收返回值，所以这个API为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了<code>id</code>类型，而这个API实际上的意思是返回一个UITableViewCell或UITableViewCell子类的实例，于是新的<code>__kindof</code>关键字解决了这个问题：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (__kindof <span class="built_in">UITableViewCell</span> *)dequeueReusableCellWithIdentifier:(<span class="built_in">NSString</span> *)identifier;</div></pre></td></tr></table></figure>
<p>既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView的subviews属性被修改成了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">UIView</span> *&gt; *subviews;</div></pre></td></tr></table></figure>
<p>这样，写下面的代码时就没有任何警告了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span> *button = view.subviews.lastObject;</div></pre></td></tr></table></figure>
<h2 id="Where-to-go"><a href="#Where-to-go" class="headerlink" title="Where to go"></a>Where to go</h2><p>有了上面介绍的这些新特性以及如<strong>instancetype</strong>这样的历史更新，Objective-C这门古老语言的类型检测和类型推断终于有所长进，现在不论是接口还是代码中的id类型都越来越少，更多潜在的类型错误可以被编译器的静态检查发现。</p>
<p>同时，个人感觉新版的Xcode对继承链构造器的检测也加强了，<strong>NS_DESIGNATED_INITIALIZER</strong>这个宏并不是新面孔，可以使用它标志出像Swift一样的指定构造器和便捷构造器。</p>
<p>最后，附上一段用上了所有新特性的代码，Swift是发展趋势，如果你暂时依然要写Objective-C代码，把所有新特性都用上，或许能让你到新语言的迁移更无痛一点。</p>
<div class="imagediv" style="width: 637px; height: 210px"></div>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://msdn.microsoft.com/zh-cn/library/dd799517.aspx" target="_blank" rel="external">泛型中的协变和逆变</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ibinspectable-and-ibdesignable" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/22/ibinspectable-and-ibdesignable/" class="article-date">
  	<time datetime="2015-06-22T02:50:45.000Z" itemprop="datePublished">2015-06-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/22/ibinspectable-and-ibdesignable/">IBInspectable和IBDesignable</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>第一次遇到<code>IBInspectable</code>是在<a href="https://github.com/romaonthego/RESideMenu" target="_blank" rel="external">RESideMenu</a>中，RESideMenu是github上非常著名的一个开源库，主要是实现侧滑菜单，到今天已经有四千多stars了；关于RESideMenu的更多信息，可以移步到github中去查找。</p>
<p>在使用RESideMenu的过程中，看到这样的场景：</p>
<div class="imagediv" style="width: 390px; height: 450px"></div>

<p>当时就勾起了我的好奇心，因为我早就想着Apple啥时候能让自定义View或ViewController能够在Interface Builder中进行配置（编辑属性）。</p>
<p>后来查看RESideMenu.h文件，看到一个从未见过的关键字<code>IBInspectable</code>：</p>
<div class="imagediv" style="width: 670px; height: 510px"></div>

<p>问题似乎变得很清晰了，<code>IBInspectable</code>指令能够让我们在Interface Builder中编辑对应类的属性。</p>
<p>接着在搜索引擎中搜索<code>IBInspectable</code>关键字，才搞明白<code>IBInspectable</code>是Xcode6新引入的指令，同时引入的还有另外一个指令<code>IBDesignable</code>。</p>
<p><strong>IBInspectable和IBDesignable</strong></p>
<p>Apple的官方文档《<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html" target="_blank" rel="external">Using Swift With Cocoa and Objective-C</a>》中有关于<code>IBInspectable</code>和<code>IBDesignable</code>的介绍，如下：</p>
<div class="imagediv" style="width: 684px; height: 352px"></div>

<p>简单来说，<code>IBInspectable</code>使得在Interface Builder的Attribute Inspector（属性检查器）中能够查看类的属性，而<code>IBDesignable</code>能实时更新视图，很厉害吧！</p>
<p>P.S: inspectable表示「可视的」。</p>
<p>下面将以实际例子更加生动说明<code>IBInspectable</code>和<code>IBDesignable</code>的使用方法和效果。</p>
<p><strong>使用IBInspectable</strong></p>
<p>举个栗子，定义一个继承自UIView的类CustomView，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CustomView</span> : <span class="title">UIView</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) IBInspectable <span class="built_in">CGFloat</span> customWidth;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) IBInspectable <span class="built_in">CGFloat</span> customHeight;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) IBInspectable <span class="built_in">NSString</span> *customTitle;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) IBInspectable <span class="built_in">UIColor</span> *customColor;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) IBInspectable <span class="built_in">BOOL</span> customHidden;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>再在Interface Builder中创建一个View，该View的Custom Class指向到刚刚创建的类Custom View，在其Attributes Inspector中果然能够实时看到如下信息：</p>
<div class="imagediv" style="width: 304px; height: 143px"></div>

<p>这使得我们能够添加一些自定义的运行时属性，这些属性将会在view加载时设置它的初始值。</p>
<div class="imagediv" style="width: 304px; height: 151px"></div>

<p><strong>使用IBDesignable</strong></p>
<p>上文已经讲过：<code>IBDesignable</code>能实时更新视图。具体是怎么回事儿呢？</p>
<p>关于<code>IBDesignable</code>的内容摘自[IBInspectable/IBDesignable]（<a href="http://www.cocoachina.com/ios/20150227/11202.html）" target="_blank" rel="external">http://www.cocoachina.com/ios/20150227/11202.html）</a></p>
<p>当应用到UIView或NSView子类中的时候，IBDesignable让Interface Builder知道它应该在画布上直接渲染视图。你会看到你的自定义视图在每次更改后不必编译并运行你的应用程序就会显示。</p>
<p>标记一个自定义视图为Designable，只需在类名前加上IBDesignable的前缀（Objective-C中加上IB_DESIGNABLE）。你的初始化、布置和绘制方法将被用来在画布上渲染你的自定义视图：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IB_DESIGNABLE</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CustomView</span> : <span class="title">UIView</span></span></div><div class="line">    ...</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<div class="imagediv" style="width: 452px; height: 148px"></div>

<p>从这个功能上节约的时间是不能被低估的。加上<code>IBInspectable</code>，一个设计师或开发人员可以轻松地调整自定义控件的呈现，以得到她想要的确切的结果。任何改变，无论是从代码或属性检查器中，都将立即呈现在画布上。</p>
<p>由于在Interface Builder中呈现自定义视图不会有应用程序的完整上下文，你可能需要生成模拟数据以便显示，例如一个默认用户头像图片或仿制的天气数据。有两种方法可以为这个特殊的上下文添加代码。</p>
<p>第一种是使用<code>prepareForInterfaceBuilder()</code>方法。<br><code>prepareForInterfaceBuilder()</code>方法与你代码的其余部分一起编译，但只有当视图正在准备在Interface Builder显示时执行。</p>
<p>第二种是使用<code>#if TARGET_INTERFACE_BUILDER</code>宏。<br><code>#if TARGET_INTERFACE_BUILDER</code>预处理宏在Objective-C或Swift下都是工作的，它会视情况编译正确代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if !TARGET_INTERFACE_BUILDER</span></div><div class="line">    <span class="comment">// this code will run in the app itself</span></div><div class="line"><span class="meta">#else</span></div><div class="line">    <span class="comment">// this code will execute only in IB</span></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p><strong>IBDesignable和IBInspectable结合使用</strong></p>
<p>把自定义IBDesignable视图和视图里的IBInspectable属性结合在一起，你能干点啥？作为一个例子，让我们更新老式经典<a href="http://www.folklore.org/StoryView.py?story=Calculator_Construction_Set.txt" target="_blank" rel="external">Apple folklore</a>：在“Steve Jobs Roll Your Own Calculator Construction Set”，Xcode 6的风格：</p>
<div class="imagediv" style="width: 445px; height: 460px"></div>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>介绍<code>IBDesignable</code>的内容完全摘自《<a href="http://www.cocoachina.com/ios/20150227/11202.html" target="_blank" rel="external">IBInspectable/IBDesignable</a>》，还不是非常理解，至少对<code>IBDesignable</code>的强大功能的体会还不够深，希望以后能够补充更多的示例说明。</p>
<p>最后，再次让我感觉到iOS开发不是我想象中那么简单的，我甚至连很多工具都没使用好，路漫漫其修远兮！</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="http://www.cocoachina.com/industry/20140619/8883.html" target="_blank" rel="external">如何在iOS 8中使用Swift和Xcode 6制作精美的UI组件</a></li>
<li><a href="http://www.weheartswift.com/make-awesome-ui-components-ios-8-using-swift-xcode-6/" target="_blank" rel="external">How to make awesome UI components in iOS 8 using Swift and XCode 6</a></li>
<li><a href="http://www.cocoachina.com/ios/20150227/11202.html" target="_blank" rel="external">IBInspectable/IBDesignable</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Xcode/">Xcode</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-using-webviewjavascriptbridge" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/16/using-webviewjavascriptbridge/" class="article-date">
  	<time datetime="2015-06-16T08:53:35.000Z" itemprop="datePublished">2015-06-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/16/using-webviewjavascriptbridge/">使用WebViewJavascriptBridge</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在App中使用Web代替一些Native UI已经成为移动客户端开发的一种思潮。在App中嵌入Web有一个重要的基础问题：Objective-C和JavaScript的交互。</p>
<p>近期的项目需要，笔者开始着手这方面的问题学习。很容易想到：一定存在某个引擎能够在OC和JS之间转换。去github中搜索关键字<code>iOS JavaScript</code>得到的选择并不多，第三方库<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>的Stars遥遥领先，自然选择它作为OC和JS的交互引擎了。</p>
<p>本文是笔者了解WebViewJavascriptBridge过程中的一些学习记录，好记性不如烂笔头嘛！</p>
<h2 id="使用WebViewJavascriptBridge"><a href="#使用WebViewJavascriptBridge" class="headerlink" title="使用WebViewJavascriptBridge"></a>使用WebViewJavascriptBridge</h2><p>WebViewJavascriptBridge的使用不难，<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>提供的Example比较直观的展示了各种接口的使用。</p>
<p>App中嵌入Web一般需要使用UIWebView（除非你自己写一个），WebViewJavascriptBridge正是配合UIWebView进行工作的。</p>
<p><strong>初始化</strong></p>
<p>和其他第三库一样，使用WebViewJavascriptBridge需要做一些初始化，只是WebViewJavascriptBridge的初始化包括两部分：「Objective-C初始化」和「JavaScript初始化」。</p>
<ul>
<li>OC初始化</li>
</ul>
<p>OC中初始化WebViewJavascriptBridge的前提是存在一个UIWebView对象，每个WebViewJavascriptBridge对象都应该与一个UIWebView对象绑定。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建UIWebView对象</span></div><div class="line"><span class="built_in">UIWebView</span> * webView = [[<span class="built_in">UIWebView</span> alloc] initWithFrame:<span class="keyword">self</span>.view.bounds];</div><div class="line">    </div><div class="line"><span class="comment">// 配置logging</span></div><div class="line">[WebViewJavascriptBridge enableLogging];</div><div class="line">    </div><div class="line"><span class="comment">// 创建WebViewJavascriptBridge对象并与UIWebView对象绑定</span></div><div class="line"><span class="keyword">self</span>.bridge = (&#123;</div><div class="line">    WebViewJavascriptBridge* bridge =</div><div class="line">    [WebViewJavascriptBridge bridgeForWebView:webView</div><div class="line">                              webViewDelegate:<span class="keyword">self</span></div><div class="line">                                      handler:^(<span class="keyword">id</span> data, WVJBResponseCallback responseCallback) &#123;</div><div class="line">                                          <span class="comment">// do something</span></div><div class="line">                                          <span class="comment">// responseCallback(responseData)</span></div><div class="line">                                      &#125;</div><div class="line">     ];</div><div class="line">    bridge;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用类方法创建一个WebViewJavascriptBridge对象，其中有一个<code>block</code>类型的handler。这个handler用来处理来自于JavaScript发送的消息，<strong>handler的形参与JavaScript中的send方法的形参对应</strong>，一般有两个参数，第一个参数是JS send传入的参数（可以是任意类类型），第二个是JS send传入的回调handler。</p>
<p>P.S：看客可能像我当初一样不太理解第二个参数：responseCallback，后文会对此进行详细说明。</p>
<ul>
<li>JS初始化</li>
</ul>
<p>除了OC外，JS中也得执行针对WebViewJavascriptBridge的初始化代码。这意味着，除了客户端（iOS开发人员）外，服务端（后端写JS的开发人员）也得对WebViewJavascriptBridge有所了解。好在需要理解的内容不多，十分钟就可以搞定。JavaScript对WebViewJavascriptBridge初始化过程（这部分代码几乎是固定的）如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建了一个connectWebViewJavascriptBridge方法，该方法名是固定的</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">connectWebViewJavascriptBridge</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.WebViewJavascriptBridge) &#123;</div><div class="line">        callback(WebViewJavascriptBridge)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">'WebViewJavascriptBridgeReady'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            callback(WebViewJavascriptBridge)</div><div class="line">        &#125;, <span class="literal">false</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// 调用connectWebViewJavascriptBridge方法</span></div><div class="line">connectWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</div><div class="line">    bridge.init(<span class="function"><span class="keyword">function</span>(<span class="params">message, responseCallback</span>) </span>&#123;</div><div class="line">        <span class="comment">// do something</span></div><div class="line">        responseCallback(responseData)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>先创建了一个connectWebViewJavascriptBridge方法，该方法注册了一个WebViewJavascriptBridgeReady事件，同时声明了一个全局的WebViewJavascriptBridge变量，这样我们可以在外部通过WebViewJavascriptBridge调用相关方法。</p>
<p>在<code>bridge.init</code>里面同样定义了一个匿名function，这个function用来接收Objective-C里面通过send方法发送的消息的，参数与OC里的send方法参数对应。同样，一般有两个参数，第一个参数是OC send传入的参数（可以是任意类类型），第二个是OC send传入的回调handler。</p>
<p>可以简单总结一下。初始化的根本目的是啥？<br>根据我的理解，初始化的根本目的是：消息接收者定义<code>message handler</code>。</p>
<p>P.S：请记住<code>message handler</code>这个名词，后文会经常用到。</p>
<p><strong>发送消息</strong></p>
<p>上述「初始化」操作的目的是为了确保OC和JS能够相互处理来自对方的消息。</p>
<p>除了「初始化」操作之外，WebViewJavascriptBridge对发送消息也有所约束，这意味着OC和JS发送消息必须得遵守一定的格式。</p>
<ul>
<li>OC向JS发送消息</li>
</ul>
<p>OC向JS发送消息，定义了两个用于「发送消息」的接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// APIs</span></div><div class="line">- (<span class="keyword">void</span>)send:(<span class="keyword">id</span>)data;</div><div class="line">- (<span class="keyword">void</span>)send:(<span class="keyword">id</span>)data responseCallback: (WVJBResponseCallback)responseCallback;</div></pre></td></tr></table></figure>
<p>两个接口的区别只是参数个数不同，参数data指的是「传给JS的参数」，responseCallback参数是一个<code>block</code>，给JS发送消息后，JS的<code>message handler</code>可能会返回一些值，responseCallback就是用来处理<strong><em>返回值</em></strong>的。</p>
<p>P.S：data可以为空；这里的「返回值」并不是非常准确的说法，只是一种参考「函数」的说法，准确来讲应该叫<code>response data</code>。</p>
<ul>
<li>JS向OC发送消息</li>
</ul>
<p>JS向OC发送消息，WebViewJavascriptBridge也定义了两种格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bridge.send(data)</div><div class="line">bridge.send(data, <span class="function"><span class="keyword">function</span> <span class="title">responseCallback</span>(<span class="params">responseData</span>) </span>&#123; ... &#125;)</div></pre></td></tr></table></figure>
<p>显然，无论是「OC向JS发送消息」，还是「JS向OC发送消息」，都有两种格式，含有<code>responseCallback</code>和不含<code>responseCallback</code>。</p>
<p>P.S：data可以为空；</p>
<p><strong>理解responseCallback</strong></p>
<p>上文已经多次提到了<code>responseCallback</code>，可能是由于笔者对跨平台了解得比较少，也可能是对函数式编程了解不多，刚开始对<code>responseCallback</code>不甚理解。这一小段将对<code>responseCallback</code>进行详细阐述。</p>
<p>关于「消息处理」和「消息发送」，我是参考「函数定义」和「函数调用」这两个概念来理解的。「函数定义」定义了函数的具体工作（即说明这段代码块都干了些啥），「函数调用」指示执行具体代码块；根据我的理解，从概念上讲，「消息处理」对应「函数定义」，「消息发送」对应「函数调用」。</p>
<p>这段话非常啰嗦，但引入这么一种对应关系是为了更好说明<code>responseCallback</code>。</p>
<p>对于函数（广义上的「函数」，而不仅仅指JavaScript function）来说，函数可能有返回值，也可能没有返回值。当有返回值时，调用者往往会定义变量接收返回值，方便之后使用返回值…而上文中反复出现的<code>responseCallback</code>有些类似于对函数返回值的处理，消息发送方向消息接收方发出一个消息，除了希望对方处理某些事情之外，可能还期待对方返回一些数据（<code>response data</code>），这些数据往往会在后续的处理中起作用。</p>
<p>因此，若「消息接收方」的<code>message handler</code>中可能有需要传给「消息发送方」的<code>response data</code>时，「消息发送方」还需要定义一个handler用来处理这些值，即所谓的<code>responseCallBack</code>。</p>
<p>P.S：为什么函数处理返回值使用<code>ret = aFunction(variable)</code>这样的格式，而这里使用<code>responseCallBack</code>处理呢？我想是因为这里处理的是两种不同语言，过程中难免存在类型转换，况且，还有可能是由于并发。</p>
<p>对于函数而言，若某个函数有返回值，但调用者不想要保存该返回值，此时往往不会定义变量接收该返回。这在大多属于语言中是被允许的。</p>
<p>对于WebViewJavascriptBridge也一样，「消息发送方」发送消息时，可以不传入responseCallback参数，表示对「消息接收方」的<code>response data</code>不care。</p>
<p>在定义<code>message handler</code>时，在handler的<code>responseCallback(responseData)</code>好比函数中<code>return ret</code>。</p>
<p>P.S：在定义<code>message handler</code>时，并不要求一定有<code>responseCallback(responseData)</code>这么一句代码；只是个人觉得，有必要写上，哪怕没有任何<code>response data</code>需要返回，也得加上<code>responseCallback(null)</code>。类似于函数，若某个函数没有返回值，也没有显式调用<code>return</code>语句，在编译阶段，编译器也会帮助在末尾加上<code>return void</code>。</p>
<p>理清了<code>responseCallback</code>这个概念，就基本上算是学会使用WebViewJavascriptBridge了。</p>
<p><strong>OC和JS互相调用</strong></p>
<p>「OC和JS互相调用」指的是OC和JS互相对应对方的handler（block或function）。</p>
<p>笔者刚开始觉得啰嗦：既然「消息机制」能够解决OC和JS交互问题，为啥还需要OC和JS互相调用对方的handler呢？</p>
<p>我还没有找到比较权威的的说法，但这里也谈谈自己的一点理解。</p>
<p>先说「函数」，「函数」的本质不过是代码的一种组织结构，它使得代码块具有了更好的可读性，同时极大加强代码复用。</p>
<p>基于「消息机制」，我们可以尽可能实现任何基于文本交互。可以做的事情非常丰富，譬如「消息发送者」传入参数<code>1</code>，<code>message handler</code>执行A段代码，传入参数<code>2</code>，执行B段代码。但问题是：基于「消息机制」，OC和JS之间的几乎所有交互任务都得写在<code>message handler</code>中。当交互任务变得复杂时，代码组织将是一种灾难（会充斥很长并且嵌套很深的<code>if</code>语句）。以消息的第一个参数data为例，有时候，data可能是一个URL字符串，有时候可能是一个JSON字符串，有时候可能只是一个数值，光是解析这些参数，都需要一个非常复杂的<code>if</code>语句…写到这里，「在OC和JS中定义能被对方调用的handler」的意义就不需要多讲了。</p>
<p>关于「OC和JS互相调用」，WebViewJavascriptBridge也定义了一些约束。约束包括两部分：定义handler的姿势，调用handler的姿势。</p>
<p><strong>OC定义和调用JS handler</strong></p>
<p>所谓定义handler，其实是向bridge注册一个handler，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// API</span></div><div class="line"><span class="comment">// - (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler</span></div><div class="line">    </div><div class="line"><span class="comment">// eg:</span></div><div class="line">[<span class="keyword">self</span>.bridge registerHandler:<span class="string">@"OCHandlerName"</span></div><div class="line">                     handler:^(<span class="keyword">id</span> data, WVJBResponseCallback responseCallback) &#123;</div><div class="line">                         <span class="comment">// do something</span></div><div class="line">                         responseCallback(responseData);</div><div class="line">                 &#125;</div><div class="line"> ];</div></pre></td></tr></table></figure>
<p>向bridge注册handler包括两部分内容：name和handler body。</p>
<p>调用JS的handler也简单，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// APIs</span></div><div class="line"><span class="comment">// - (void)callHandler:(NSString *)handlerName;</span></div><div class="line"><span class="comment">// - (void)callHandler:(NSString*)handlerName data:(id)data;</span></div><div class="line"><span class="comment">// - (void)callHandler:(NSString*)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback;</span></div><div class="line">    </div><div class="line"><span class="comment">// eg：</span></div><div class="line">[<span class="keyword">self</span>.bridge callHandler:<span class="string">@"JSHandlerName"</span> data:data];</div></pre></td></tr></table></figure>
<p><strong>JS定义和调用OC handler</strong></p>
<p>在JS定义（注册）handler的姿势如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bridge.registerHandler(<span class="string">"handlerName"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">responseData</span>) </span>&#123; ... &#125;)</div></pre></td></tr></table></figure>
<p>调用OC的handler也简单，和OC调用JS handler类似。</p>
<p>。。。。。。</p>
<p>本文写得好啰嗦啊！</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge - github</a></li>
<li><a href="http://dxldy.iteye.com/blog/2078350?utm_source=tuicool" target="_blank" rel="external">《WebViewJavascriptBridge使用说明（iOS）》</a></li>
<li><a href="http://honglu.me/2014/09/27/WebViewJavascriptBridge使用/" target="_blank" rel="external">《WebViewJavascriptBridge使用》</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-uiwebview-load-local-html" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/16/uiwebview-load-local-html/" class="article-date">
  	<time datetime="2015-06-16T08:38:39.000Z" itemprop="datePublished">2015-06-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/16/uiwebview-load-local-html/">UIWebView加载本地HTML文件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>写本文的原因是今天被要求「调研在iOS中加载本地HTML的相关技术」，好记性不如烂笔头，将一些东西给记录下来吧。</p>
<p>应用场景是这样的：手头的iOS App有一部分UI需要使用HTML完成，好处是这部分UI可以更灵活，即可以在任何不需要升级App的情况下更新这部分UI（包括样式、操作等等）。当下非常火的技术 – Facebook的React Native – 正是用来解决这种问题的，毕竟在传统的开发模式下，更新UI必须要升级App，而升级App是一个非常耗时的过程。使用Web App部分代替Native App已经成为当下移动客户端开发的一种思潮了。为了简便起见，也为了不给项目的接盘者制造更高的门槛，暂时决定不使用React Native（原因是多方面的）等著名框架去这种事情，从0开始探究。话说胡来，也许走了这么一遭之后，以后学习React Native会有更多的体会呢！</p>
<p>总之，目前的构想是这样的：</p>
<ol>
<li>App部分UI是由HTML+JS+CSS完成的，HTML+JS+CSS代码会随着App一起发布；</li>
<li>当后端决定更新App的部分UI（HTML）时，客户端从服务器下载最新的HTML+JS+CSS包，解压后代替本地的、旧的HTML+JS+CSS资源，将最新的呈现给用户，至此完成UI的更新；</li>
</ol>
<p>因此有这么些问题需要考虑：</p>
<ol>
<li>加载本地HTML+JS+CSS资源（在iOS中，通常使用UIWebView）；</li>
<li>解压从服务端下载的压缩文件（HTML+JS+   CSS包）；</li>
<li>JS代码和OC代码的互相调用；</li>
</ol>
<p>本文主要探究第一个问题！</p>
<h2 id="UIWebView介绍"><a href="#UIWebView介绍" class="headerlink" title="UIWebView介绍"></a>UIWebView介绍</h2><p>UIWebView是iOS中一个非常常用的控件，是内置的浏览器控件，可能也是最强大复杂的控件。可以用它来浏览网页、打开文档（譬如PDF文档）等等。</p>
<p>UIWebView既可以用来显示本地文档，也可以用来显示网络文档。无论是显示本地文件还是网络文件，此过程都可以统称为「加载」。与「加载」相关的方法不多，只有三个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Loading Local Content or Loading Content From the Network</span></div><div class="line">- (<span class="keyword">void</span>)loadRequest:(<span class="built_in">NSURLRequest</span> *)request;</div><div class="line">    </div><div class="line"><span class="comment">// 嵌入HTML结构的字符串</span></div><div class="line">- (<span class="keyword">void</span>)loadHTMLString:(<span class="built_in">NSString</span> *)string</div><div class="line">               baseURL:(<span class="built_in">NSURL</span> *)baseURL;</div><div class="line">    </div><div class="line"><span class="comment">// Loading Local Content</span></div><div class="line">- (<span class="keyword">void</span>)loadData:(<span class="built_in">NSData</span> *)data</div><div class="line">        MIMEType:(<span class="built_in">NSString</span> *)MIMEType</div><div class="line">textEncodingName:(<span class="built_in">NSString</span> *)textEncodingName</div><div class="line">         baseURL:(<span class="built_in">NSURL</span> *)baseURL;</div></pre></td></tr></table></figure>
<p>与UIWebView相关的知识点并不多（从某种角度来看，也可以认为是Apple封装得比较好吧），除了上述的三个方法之外，还有必要了解的是UIWebViewDelegate定义的一些delegate方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开始加载前调用</span></div><div class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line"> navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType;</div><div class="line"><span class="comment">// 开始加载时调用</span></div><div class="line">- (<span class="keyword">void</span>)webViewDidStartLoad:(<span class="built_in">UIWebView</span> *)webView;</div><div class="line"><span class="comment">// 加载成功时调用</span></div><div class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView;</div><div class="line"><span class="comment">// 加载失败时调用</span></div><div class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">UIWebView</span> *)webView didFailLoadWithError:(<span class="built_in">NSError</span> *)error;</div></pre></td></tr></table></figure>
<p>除此之外，UIWebView似乎有啥其他需要了解的内容，若有需要，以后再补充吧！</p>
<h2 id="加载本地HTML文件"><a href="#加载本地HTML文件" class="headerlink" title="加载本地HTML文件"></a>加载本地HTML文件</h2><p>加载本地HTML文件不是多么难的事情，但再简单的事情也有一个1-2-3-4，不是嘛？何况笔者比较笨，参考<a href="http://blog.csdn.net/kaitiren/article/details/17115085" target="_blank" rel="external">UIWebView加载本地HTML5文件</a>，也分几个步骤：</p>
<ol>
<li>准备HTML文件及其资源文件（主要是CSS文件和JS文件以及image文件）；</li>
<li>加载本地HTML文件；</li>
</ol>
<p>第一种：<br>loadRequest:<br>第二种：<br>loadHTMLString:baseURL:</p>
<p><strong>第一步，准备HTML文件及其资源文件。</strong></p>
<p>HTML及其资源文件比较容易获取，随便找个比较漂亮的web页面，将它保存起来即可！</p>
<p>显然HTML文件及其资源文件是需要添加到工程的，问题是如何添加呢？如何组织管理这些文件呢？沙盒？Bundle？</p>
<p><strong>Xcode工程添加文件有两种方式</strong></p>
<p>向项目中添加已有的文件（或资源文件，或第三方库）不是什么稀罕的事情，只是平时都没怎么注意。实际上，将「文件」或者「目录」添加到项目时，Xcode给了我们两个选项：Create groups以及Create folder references，如下图：</p>
<div class="imagediv" style="width: 730px; height: 126px;"></div>

<p>简单来说，若选择Create groups的方式添加文件夹，则文件夹的颜色是黄色的；若选择Create folder references的，则发现添加的文件夹在工程目录中的的颜色是蓝色的：</p>
<div class="imagediv" style="width: 400px; height: 120px;"></div>

<p>当然不只是颜色上的区别！主要是Xcode对加入的文件的路径处理不一样。</p>
<p>如果文件/文件夹以Create groups的方式添加到工程中，则不管加入项目的文件的目录结构如何，在APP中都可以通过mainBundlePath/filename这样结构来访问文件；反之，若文件/文件夹以Create folder references的方式添加到工程中，则会保留相对路径，访问文件的结构就变成了mainBundlePath/path/filename。</p>
<p>理解Create groups以及Create folder references并不难，自己动手试试就能感受二者的不同了。</p>
<p><strong>Bundle介绍</strong></p>
<p>上文谈到了向工程添加文件的两种方式，由此延伸，不得不提bundle，一直以来对bundle的理解非常模糊，知道它的本质是一个目录，也知道在OS X中就有此概念，但一直没get到<code>bundle</code>的存在意义，总感觉它没必要存在，事实上也没主动使用它。</p>
<p>借撰写本文这个机会，驱动一下自己，查查资料，争取对bundle理解更深入一点点吧！</p>
<p>参考《<a href="http://avatar-matrix.lofter.com/post/e4689_236e82" target="_blank" rel="external">Bundle in iOS</a>》和《<a href="http://www.cnblogs.com/BigPolarBear/archive/2012/03/28/2421802.html" target="_blank" rel="external">iOS开发里的Bundle是个啥玩意</a>》。</p>
<p>简单地讲，bundle就是一个内部结构按照标准规则组织的特殊目录，常用来存放一些资源文件，譬如图片，plist文件等，它不会成为编译的一部分，所以它不存放能够被编译的文件，譬如<code>.m</code>、<code>.h</code>文件等。</p>
<p>Bundle的主要用途是软件的国际化，想象一个应用场景：软件有美国、中国版本，软件的logo等图片不同，这时候，我们把相应的图片资源放到一个文件夹下，然后修改文件夹的名字，以<code>.bundle</code>作为后缀，然后添加到xcode中。</p>
<p>有过iOS开发经历的人都应该知道，每个project都有个mainBundle，那如何去获取自己定义的bundle内容呢？我们把自定义的bundle当成项目的一种资源，由mainBundle去获取<code>~</code>，然后我们用相同的方式获取自定义的bundle下的资源。即：</p>
<p>1、通过mainBundle去加载自定义的bundle；<br>2、通过获取到的自定义bundle去获取资源；</p>
<p>根据上述场景来写的demo项目结构如下：</p>
<div class="imagediv" style="width: 340px; height: 280px;"></div>

<p>此时，我容易联想到了在Windows世界经常使用的「汉化包」。根据我的理解，我们通过某种手段得到的「汉化包」和本文所谈及的bundle是类似的概念，它们的本质是一个目录，只是这个目录有些特别，特别之处在于它只存放一些资源文件，以及目录名后缀为<code>.bundle</code>，这让它看起来像个文件，但实际上又不是文件，开发者又特别想让普通用户以为它是一个文件…</p>
<p>总之，bundle就是这么个东东。</p>
<p>到了这里，应该弄清楚了该把HTML文件及其资源放在哪里了。</p>
<p>沙盒？显然不可能，沙盒可是App到设备之后才有的概念；所以我们只能让HTML资源成为工程的一部分呢，编译打包时作为安装包的一部分。</p>
<p>放在普通目录下还是组织成bundle，个人以为没必要组织成bundle，因为后者主要用来处理国际化问题，国际化问题面对的一般是图片资源、字符串资源等等，所以不需要组成成bundle，而是直接添加到工程的mainBundle中。</p>
<p>上文已经提到了Xcode工程添加文件有两种方式：Create groups和Create folder references，个人以为应该选择后者！</p>
<p>值得注意是，当被加入到项目中的文件包含js文件时，有可能因为操作不慎等原因，js文件成为了编译文件，若是这样，应该将它从<code>Compile Sources</code>给踢掉，让它成为<code>Copy Bundle Resources</code>的一部分，具体做法是在TARGETS-&gt;Build Phases中的<code>Compile Sources</code>中找到该js文件，并将其移到<code>Copy Bundle Resources</code>中，如下图所示：</p>
<div class="imagediv" style="width: 699px; height: 364px;"></div>

<p><strong>第二步，加载本地HTML。</strong></p>
<p>本文示例中，HTML文件及其资源文件被组织在一个叫<code>html</code>的目录中，目录结构如下图，index.html是要被加载的目标文件，index.html中访问css、js以及图片资源的方式都是使用相对路径，实现代码也给展示在下图中。</p>
<div class="imagediv" style="width: 926px; height: 400px;"></div>

<p>上图右侧代码区域加载策略是，先获取本地HTML文本，转为字符串，然后使用<code>loadHTMLString:baseURL:</code>方法加载；当然也可以使用<code>loadRequest:</code>方法，哪个更好？我暂时也不知道！</p>
<p><strong>关于baseURL</strong></p>
<p>上文<code>loadHTMLString:baseURL:</code>方法的第二个参数是baseURL，baseURL是HTML字符串中引用到资源的查找路径，当HTML中没有引用外部资源时，可以指定为<code>nil</code>；若引用了外部资源，一般情况下使用mainBundle的路径即可。在实际操作中，常常会出现「文本显示正常，图片无法显示」等情况，若HTML文本中引用外部资源都是使用相对路径，则出现这种问题的原因一般都是baseURL参数错误（有时甚至是<code>nil</code>）。</p>
<p>最后，本文的Demo详见<a href="https://github.com/sadjason/iOSDemos/tree/master/UIWebView%E9%9D%9E%E5%88%9D%E4%BD%93%E9%AA%8C" target="_blank" rel="external">这里</a>。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UIWebView/">UIWebView</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>