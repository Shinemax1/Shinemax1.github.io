<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/13/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.25px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 13.75px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 16.25px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.25px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 17.5px;">Objective-C</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/ReactiveCocoa/" style="font-size: 12.5px;">ReactiveCocoa</a> <a href="/tags/Redux/" style="font-size: 10px;">Redux</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/SSR/" style="font-size: 10px;">SSR</a> <a href="/tags/Sublime-Text/" style="font-size: 11.25px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 13.75px;">Tools</a> <a href="/tags/Transition/" style="font-size: 12.5px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 18.75px;">es6</a> <a href="/tags/express/" style="font-size: 10px;">express</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js/" style="font-size: 11.25px;">js</a> <a href="/tags/js基础/" style="font-size: 20px;">js基础</a> <a href="/tags/mongondb/" style="font-size: 10px;">mongondb</a> <a href="/tags/node-js/" style="font-size: 11.25px;">node.js</a> <a href="/tags/pm2/" style="font-size: 10px;">pm2</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/socket-io/" style="font-size: 10px;">socket.io</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/事件环/" style="font-size: 10px;">事件环</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/宏任务/" style="font-size: 10px;">宏任务</a> <a href="/tags/微任务/" style="font-size: 10px;">微任务</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/流/" style="font-size: 10px;">流</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/面试/" style="font-size: 11.25px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，全栈开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-understanding-objective-c-runtime-part-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/27/understanding-objective-c-runtime-part-2/" class="article-date">
  	<time datetime="2015-04-27T03:16:36.000Z" itemprop="datePublished">2015-04-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/27/understanding-objective-c-runtime-part-2/">理解Objective-C Runtime（二）消息传递机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在对象上调用方法是包括Objective-C的众多语言都具备的功能。但在Objective-C中，这个术语叫<strong>传递消息</strong>（pass a message）。消息有可以接受参数，也可能有返回值。</p>
<h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><p>由于Objective-C是C的超集，所以最好先理解C语言的函数调用方式。C语言使用<strong>静态绑定</strong>（static binding），也就是说，在编译期间就能决定运行时所应调用的函数。以下代码为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGoodbye</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTheThing</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</div><div class="line">        printHello();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        printGoodbye();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若不考虑内联（inline），那么编译器在编译代码时就已经知道程序中有printHello与printGoodbye这两个函数了，于是会直接生成调用这些函数的指令（站在汇编的角度，call命令）。而函数地址实际上是与硬编码在指令之中的。</p>
<p>如果将上述代码写成下面这样，会如何呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGoodbye</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye!\n"</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTheThing</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> (*fnc)();</div><div class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</div><div class="line">        fnc = printHello;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fuc = printGoodbye;</div><div class="line">    &#125;</div><div class="line">    fnc();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是动态绑定（dynamic binding）！因为所要调用的函数知道运行期才能确定。编译器在这种情况下生成的指令与刚才的那个例子不同，在第一个例子（静态绑定）中，<code>if</code>与<code>else</code>语句里都有函数调用指令（汇编中的call命令）；而在第二个例子（动态绑定）中，只有一个函数调用指令，不过待调用的函数地址无法硬编码之中，而是要在运行期读出来。</p>
<h2 id="消息传递机制"><a href="#消息传递机制" class="headerlink" title="消息传递机制"></a>消息传递机制</h2><p>在OC中，如果向某对象传递消息，那就会使用<strong>动态绑定机制</strong>来决定需要调用的方法。在底层，所有方法都是普通的C语言函数，然而对象收到消息之后，究竟该调用哪个方法则完全在runtime决定，甚至可以在程序运行时改变，这些特性使得<strong>Objective-C成为一门真正的动态语言</strong>。</p>
<p>给对象发生消息可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> returnValue = [someObject messageName:parameter];</div></pre></td></tr></table></figure>
<p><code>someObject</code>是接收者（receiver），<code>messageName</code>叫做选择子（selector）。二者合起来称为消息（message）。</p>
<p>P.S: 「选择子」和「方法」这两个名词经常交替使用，都是一个意思。</p>
<p>编译器看到此消息后，将其转换为一条标准的C语言函数调用，所调用的函数乃是「消息传递机制」中的核心函数，即鼎鼎有名的<code>objc_msgSend</code>，其原型可以在<code>&lt;objc/message.h&gt;</code>中找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">id <span class="title">objc_msgSend</span><span class="params">(id self, SEL op, ...)</span></span></div></pre></td></tr></table></figure>
<p><code>id returnValue = [someObject messageName:parameter];</code>会被编译器翻译成如下形式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> returnValue = objc_msgSend(someObject, <span class="keyword">@selector</span>(messageName:), parameter);</div></pre></td></tr></table></figure>
<p>在runtime，<code>objc_msgSend</code>会依据receiver（即上述对象someObject）和选择子类型来调用适当的方法。为了完成此操作，该方法需要在接收者所属的类中搜寻其「方法列表」（关于方法列表，详见<a href="/understanding-objective-c-runtime-part-1/#objc_class和isa">methodLists</a>），如果能找到与选择子匹配的方法，就调至其实现的代码。若找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果最终还找不到相匹配的方法，那就执行<strong>消息转发</strong>（message forwarding）操作，这会在下一篇<a href="/understanding-objective-c-runtime-part-3/">博客</a>中阐述。</p>
<p>如此看来，Objective-C在runtime调用一个方法似乎需要很多步骤。所幸的是，<code>objc_msgSend</code>会将匹配结果缓存在快速映射表（fast map）里面，每个类都有这样一块缓存，若是稍后还想该类发送与选择子相同的方法，那么查找起来就很快了。</p>
<p>P.S: 上一篇博客《<a href="/understanding-objective-c-runtime-part-1/">理解Objective-C Runtime（一）预备知识</a>》中在介绍<code>objc_class</code>结构体时谈到了其中一个变量<code>cache</code>，但简单忽略飘过；其实，根据我的理解，这里的快速映射表所对应的就是<code>objc_class</code>中的变量<code>cache</code>。</p>
<p>诚然，即便有这种快速映射表机制，执行速度还是不如静态绑定。实际上，对于当前这种硬件平台，这点速度差根本不值一提。</p>
<p>在<code>&lt;objc/message.h&gt;</code>中，除了<code>objc_msgSend</code>函数原型之外，还可以看到其他的<code>objc_msgSendXXOO</code>函数，这些方法的详细作用，《Effective Objective-C 2.0》item 11中有详细说明，本文就不赘述了。</p>
<p>只要理解了Objective-C的对象模型，理解「消息传递机制」还是非常容易的。</p>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li>《Effective Objective-C 2.0》</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Runtime/">Runtime</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-understanding-objective-c-runtime-part-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/26/understanding-objective-c-runtime-part-1/" class="article-date">
  	<time datetime="2015-04-26T12:07:37.000Z" itemprop="datePublished">2015-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/26/understanding-objective-c-runtime-part-1/">理解Objective-C Runtime（一）预备知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>很早就知道了Objective-C Runtime这个概念，「Objective-C奇技淫巧」「iOS黑魔法」各种看起来很屌的主题中总会有它的身影；但一直没有深入去学习，一来觉得目前在实际项目中还没有必要了解，二来懒。但，若想成为一个合格的iOS开发者，这个东西是躲不过的，好吧，抡起胳膊开始吧，争取一点点把它整明白吧！</p>
<p>和了解其他技术一样，在了解一个东西之前，我总是问自己，这个有啥实际意义？为什么要了解她？多自问一些问题，找到实际意义，在理解上总会容易一些，学习也自然更有目的性一些。</p>
<p>好吧，看了十几篇博客和iOS文档，还是很容易针对Objective-C Runtime提出一些问题的，有了这些问题，理解Objective-C Runtime就自然不会过于枯燥了，譬如：</p>
<ul>
<li>在iOS中调用方法为什么叫「发送消息」，为什么这个概念这么重要？</li>
<li>KVO的实现原理是什么，是否涉及Objective-C Runtime？</li>
<li>Category的原理是什么？为什么其他语言中没有这个东东？</li>
<li>Category中以「关联对象」的方式添加动态属性的原理什么？</li>
</ul>
<p>看了一些大牛的博客之后，对Objective-C Runtime的重要性在心里基本有谱了，但路要一步一步走，饭要一口一口吃，先将一些基础性的概念进行整理，「消息转发」「Method Swizzling」之类的高端东西放在之后的博客分析吧！</p>
<h2 id="关于Objective-C-Runtime"><a href="#关于Objective-C-Runtime" class="headerlink" title="关于Objective-C Runtime"></a>关于Objective-C Runtime</h2><p><strong>Runtime的学习资源</strong></p>
<p>Runtime的学习资源非常丰富，下面是个人的一些整理：</p>
<ul>
<li>《Objective-C Runtime Programming Guide》（官方文档）；</li>
<li><code>/usr/include/objc/</code>下的头文件，譬如<code>objc.h</code>，<code>runtime.h</code>，<code>NSObject.h</code>，<code>message.h</code>等；<code>/usr/include/objc/</code>下的头文件不多，都可以看一下；</li>
<li>《Effective Objective-C 2.0》；</li>
<li>《<a href="http://www.tuicool.com/articles/FRRVNv" target="_blank" rel="external">理解 Objective-C Runtime</a>》；</li>
<li>《<a href="http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/" target="_blank" rel="external">Objective-C对象模型及应用</a>》；</li>
<li>《<a href="http://blog.devtang.com/blog/2014/05/30/understand-tagged-pointer/" target="_blank" rel="external">深入理解Tagged Point</a>》；</li>
<li>《<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">Objective-C Runtime</a>》；</li>
<li>Objective-C Runtime系列博客：<ol>
<li>《<a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="external">Objective C Runtime</a>》；</li>
<li>《<a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">Method Swizzling 和 AOP 实践</a>》；</li>
<li>《<a href="http://tech.glowing.com/cn/implement-kvo/" target="_blank" rel="external">如何自己动手实现 KVO</a>》；</li>
</ol>
</li>
<li>刨根问底Objective－C Runtime系列博客：<ol>
<li>《<a href="http://t.cn/R7HYfhz" target="_blank" rel="external">刨根问底Objective－C Runtime（1）－ Self &amp; Super</a>》；</li>
<li>《<a href="http://t.cn/R7QUSUE" target="_blank" rel="external">刨根问底Objective－C Runtime（2）－ Object &amp; Class &amp; Meta Class</a>》；</li>
<li>《<a href="http://t.cn/R7meOzE" target="_blank" rel="external">刨根问底Objective－C Runtime（3）－ 消息 和 Category</a>》；</li>
<li>《<a href="http://t.cn/R7mdOq1" target="_blank" rel="external">刨根问底Objective－C Runtime（4）－ 成员变量与属性</a>》；</li>
</ol>
</li>
<li>《<a href="http://www.cnblogs.com/biosli/p/NSObject_inherit_2.html" target="_blank" rel="external">继承自NSObject的不常用又很有用的函数（2）</a>》；</li>
</ul>
<blockquote>
<p>P.S: 值得一提的是，Objective-C Runtime是开源的，任何时候都能从<a href="http://opensource.apple.com" target="_blank" rel="external">opensource</a>中获取源代码。</p>
</blockquote>
<p><strong>动态语言v.s静态语言</strong></p>
<p>在网上阅读Objective-C Runtime相关的信息时都提到了「Objective-C是一门动态语言…」「作为一门动态语言…」之类的字眼，这让我有些诧异。因为根据我之前的理解：虽然动态和静态语言都是相对的，但Objective-C怎么也不算动态语言吧！动态语言是Python、Javascript这种弱类型语言吧？！</p>
<p>关于Objective-C是否是动态语言，笔者才疏学浅，不敢妄论，知乎中关于这个有讨论：<a href="http://www.zhihu.com/question/19970471" target="_blank" rel="external">Objective-C是动态语言吗？为什么？</a></p>
<p>但无论如何，它比C++、C这类传统静态语言具备更多的动态特性，说它是动态语言或许不为过吧。暂时不纠结这个问题了，希望以后有更多的自信回答这个问题。跟随主流意见，暂时认为Objective-C是一门动态语言吧。</p>
<p>P.S: 后来又仔细阅读了一下《Effective Objective-C 2.0》，其中对「Objective-C是动态语言」有更好的佐证，后面阐述「Objective-C的消息传递机制」时再补充说明吧！</p>
<p>P.S: 关于OC是动态语言这个话题，总会少不了「动态特性」「动态类型」「动态绑定」这几个关键词的讨论分析，之前在《<a href="/basics-in-objective-c/#多态、动态类型和动态绑定">Objective-C基础知识</a>》中进行了简单的概述。</p>
<p><strong>Runtime是什么</strong></p>
<p>Runtime是什么？为什么有Runtime这个东东？</p>
<p>《Objective-C Runtime Programming Guide》的introduction的第一段就回答了这个问题：</p>
<blockquote>
<p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.</p>
</blockquote>
<p>不过貌似不够清晰，<a href="http://www.tuicool.com/articles/FRRVNv" target="_blank" rel="external">理解Objective-C Runtime</a>中有更浅显的解释：</p>
<blockquote>
<p>Objective-C是面相运行时的语言（runtime oriented language），就是说它会尽可能的把编译和链接时要执行的逻辑延迟到运行时。这就给了你很大的灵活性，你可以按需要把消息重定向给合适的对象，你甚至可以交换方法的实现，等等；这就需要使用runtime，runtime可以做对象自省查看他们正在做的和不能做的（don’t respond to）并且适当地分发消息。</p>
<p>Objective-C的Runtime是一个运行时库（Runtime Library），它是一个主要使用C和汇编写的库，为C添加了面相对象的能力并创造了Objective-C。这就是说它在类信息（Class Information）中被加载，完成所有的方法分发，方法转发，等等。Objective-C runtime创建了所有需要的结构体，让Objective-C的面相对象编程变为可能。</p>
</blockquote>
<h2 id="关于Runtime的一些术语"><a href="#关于Runtime的一些术语" class="headerlink" title="关于Runtime的一些术语"></a>关于Runtime的一些术语</h2><p>各种Runtime资料中有很多术语，有些是以前认识但理解不深刻的，譬如<code>id</code>、<code>Class</code>，有些是很少接触的，譬如<code>isa</code>。</p>
<p>为了更好地理解Runtime，先了解Runtime的一些术语是非常必要的。</p>
<p>首先简单提一下<code>objc_class</code>，它是一个结构体，其中包含一些类信息；然后是<code>objc_object</code>，它也是一个结构体，但它只包括一个条目 – <code>isa</code>，后者是一个<code>objc_class</code>指针；</p>
<p>P.S: 为了查看方便，把<code>objc_class</code>、<code>objc_object</code>等的定义源码都拷贝出来了，详见。</p>
<p>其实，说到底，<code>NSObject</code>就是建立在<code>objc_class</code>这个结构体之上的，所以了解<code>objc_class</code>对于了解<code>NSObject</code>以及Cocoa的对象模型是非常重要的。</p>
<p>P.S: <code>objc_class</code>和<code>isa</code>相对而言信息量比较大，后文再详细阐述。</p>
<p>OK，接着来看建立在<code>objc_class</code>和<code>objc_objec</code>t基础之上的一些关键字。</p>
<p><strong>Class</strong></p>
<p><code>Class</code>（不是class哦），它在<code>&lt;objc/objc.h&gt;</code>中定义，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div></pre></td></tr></table></figure>
<p>可以看到<code>Class</code>其实是一种指针类型，即用于指向<code>objc_class</code>结构体。<code>NSObject</code>中定义的方法<code>-(Class)class</code>用于返回其对应的<code>objc_class</code>结构体指针；</p>
<p>除了<code>-(Class)class</code>方法之外，<code>NSObject</code>类中还有一些常见方法包含<code>Class</code>类型参数或者返回<code>Class</code>类型返回值，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (Class)<span class="keyword">class</span>;</div><div class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)aClass;</div><div class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)aClass;</div><div class="line">+ (<span class="built_in">BOOL</span>)isSubclassOfClass:(Class)aClass;</div><div class="line">+ (<span class="built_in">BOOL</span>)isSubclassOfClass:(Class)aClass;</div><div class="line">+ (Class)superclass;</div><div class="line">+ (Class)<span class="keyword">class</span>;</div></pre></td></tr></table></figure>
<p><strong>id</strong></p>
<p>对于有过iOS开发经验的人而言，<code>id</code>使用太广泛了，不过似乎对它还没有过比较深入的理解；事实上，一直以为<code>id</code>和<code>NSObject *</code>等价呢！现在看来，这种理解太naive了，它也在<code>&lt;objc/objc.h&gt;</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// objc_object也是一个只包含一个条目isa（指向objc_object结构体的指针）的结构体。</span></div><div class="line">    </div><div class="line"><span class="comment">/// A pointer to an instance of a class.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *id;</div></pre></td></tr></table></figure>
<p><strong>SEL</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents a method selector.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</div></pre></td></tr></table></figure>
<p>没找到<code>objc_selector</code>的定义，但根据网友的描述：其实它就是个映射到方法的C字符串，可以用Objc编译器命令<code>@selector()</code>或者Runtime系统的<code>sel_registerName</code>函数来获得一个SEL类型的方法选择器（通常简称：选择子）。</p>
<p>考虑到Xcode对<code>@selector</code>的支持比对<code>sel_registerName</code>的支持更好，所以<code>@selector</code>貌似用得更多一些，但有时候<code>sel_registerName</code>或许更简洁一些。</p>
<p>譬如有一段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.selectedViewController respondsToSelector:<span class="keyword">@selector</span>(isReadyForEditing)]) &#123;</div><div class="line">    boolNumber = [<span class="keyword">self</span>.selectedViewController performSelector:<span class="keyword">@selector</span>(isReadyForEditing)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但当前上下文中没有<code>isReadyForEditing</code>这个方法，所以编译器会有警告；当然，可以有各种方式来关闭警告，如下是其中一种：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wundeclared-selector"</span></span></div><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.selectedViewController respondsToSelector:<span class="keyword">@selector</span>(isReadyForEditing)]) &#123;</div><div class="line">    boolNumber = [<span class="keyword">self</span>.selectedViewController performSelector:<span class="keyword">@selector</span>(isReadyForEditing)];</div><div class="line">    &#125;</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div></pre></td></tr></table></figure>
<p>但此时，若改用<code>sel_registerName</code>，则这个警告就没了！</p>
<p>P.S: 不晓得Apple更青睐于哪一个，个人感觉是<code>@selector</code>，因为<code>sel_registerName</code>的使用几乎没碰到过。</p>
<p><strong>IMP</strong></p>
<p>IMP的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>可以了解到，IMP是一个函数指针。IMP是Implementation的缩写，一个函数是由一个selector(SEL)，和一个implement(IML)组成的；Selector相当于门牌号，而Implement才是真正的住户（函数实现）。理解Selector和Implementation的关系蛮重要的！</p>
<p><strong>Method</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents a method in a class definition.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</div></pre></td></tr></table></figure>
<p><strong>Ivar</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents an instance variable.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</div></pre></td></tr></table></figure>
<p><strong>Category</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents a category.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</div></pre></td></tr></table></figure>
<p><strong>objc_property_t</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents an Objective-C declared property.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *<span class="keyword">objc_property_t</span>;</div></pre></td></tr></table></figure>
<p>可以通过<code>class_copyPropertyLis</code>t和<code>protocol_copyPropertyList</code>方法来获取类（Class）和协议（Protocol）中的属性，获取属性之后，还可以使用<code>property_getName</code>获取属性的名字（C字串）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">objc_property_t *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</div><div class="line">objc_property_t *protocol_copyPropertyList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getName(objc_property_t property);</div></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> score;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div><div class="line">    </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div><div class="line">    </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div><div class="line">    </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</div><div class="line">    objc_property_t *aProperty = class_copyPropertyList([Student <span class="keyword">class</span>], &amp;outCount);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"一共有%d个属性，它们的名字分别是："</span>, outCount);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; ++i) &#123;</div><div class="line">        objc_property_t aP = aProperty[i];</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * property_name = property_getName(aP);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, property_name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">/*输出：</span></div><div class="line">Student类一共有3个属性，它们的名字分别是：</div><div class="line">name</div><div class="line">age</div><div class="line">score</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>这个示例的执行结果也从侧面反映出了，<code>NSObject</code>中没有定义属性（只有一个叫<code>isa</code>成员变量）。</p>
<p>P.S: 属性v.s成员变量？这里留个尾巴，以后把这个问题也分析一下吧！</p>
<h2 id="objc-class和isa"><a href="#objc-class和isa" class="headerlink" title="objc_class和isa"></a>objc_class和isa</h2><p>把<code>objc_class</code>和<code>isa</code>单独拧出来的原因是它们的信息量比较大，稍微复杂一点！</p>
<p>Objective-C是一种面向对象的语言。按照面向对象语言的设计原则，所有事物都应该是对象（严格来说Objective-C并没有完全做到这一点，因为它有象<code>int</code>, <code>double</code>这样的简单变量类型）。所以一定要有这个认识：<strong>Objective-C中，类也是对象</strong>。</p>
<p>在Cocoa中，所有类都继承自<code>NSObject</code>，参考<code>NSObject</code>在<code>&lt;objc/NSObject.h&gt;</code>中的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>objc_class</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">    </div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以知道在运行时，所有类对象都有一个名为<code>isa</code>的指针，这个指针指向一个<code>objc_class</code>结构体，<code>objc_class</code>结构体中包含一些与类相关的信息。问题是这个<code>isa</code>指向的<code>objc_class</code>结构体的信息所对应的是自己的信息还是对应的类的信息呢？当然是其所对应的类的信息，存储了变量列表、方法列表、遵守的协议列表等等。</p>
<p>简单来说，<code>isa</code>指针被称为「is a」指针，顾名思义，它告诉了对象所属的类信息，描述「aX is a X」。</p>
<p>某个对象的<code>isa</code>指针指向的<code>objc_class</code>结构体存放的是其所对应的类的元数据（metadata），通过它我们可以知道该对象：所对应类的名字（<code>name</code>）、可以做哪些事情（<code>objc_method_list</code>是个二维方法列表）、包括哪些成员变量（<code>objc_ivar_list</code>）、遵守哪些协议（<code>protocols</code>）。</p>
<p>回到<code>objc_class</code>，可以看到<code>objc_class</code>结构体首变量也是一个<code>isa</code>指针，这也印证了「类也是对象」这个说法。对象的<code>isa</code>指针指向的是该对象的本类，而类的<code>isa</code>指针指向的另外一个类被称为<strong>元类</strong>（metaclass），用来表述类本身所表具备的元数据，类方法就定义于此；也正因为类本身也是一个对象，所以类本身可以接收消息。譬如：考虑到<code>NSObject</code>类本身也是一个对象（是metaclass的一个对象，常称之为<strong>类类型对象</strong>），所以<code>[NSObject alloc]</code>其实可以看成是对<code>NSObject</code>这个类类型对象发送一个消息（调用器<code>alloc</code>实例方法）。</p>
<p>除了<code>isa</code>指针之外，<code>objc_class</code>结构体中还有一个变量<code>super_class</code>，它指向了是这个类的超类（super class），可以看到这个<code>super_class</code>不是一个一位数组，而是一个单独的指针，即一个类有且仅有一个super class，即所谓的「单继承」。</p>
<p>关于<code>isa</code>和<code>super_class</code>的更直观描述，还请看图：</p>
<div class="imagediv" style="width: 274px; height = 287px"></div>

<p>到了这里，Objective-C的对象模型基本上解释清楚了；可能还有一个问题：最终的元类是啥？在Cocoa中，所有类都继承自<code>NSObject</code>，而<code>NSObject</code>的元类（不晓得叫什么名字，假设叫<code>NSObjectMetaClass</code>）（上图中右上角的方框）也继承自<code>NSObject</code>。有些绕，具体来说，<code>NSObject</code>和<code>NSObjectMetaClass</code>的<code>isa</code>指针和<code>super_class</code>指针指向情况是这样的：</p>
<ul>
<li><code>NSObject</code>的<code>isa</code>指针<code>NSObjectMetaClass</code>（终极meta class），<code>NSObjectMetaClass</code>指针指向自己；</li>
<li><code>NSObject</code>的<code>super_class</code>指针指向<code>nil</code>，<code>NSObjectMetaClass</code>的<code>super_class</code>指向<code>NSObject</code>；</li>
</ul>
<p>这样就完了？！No！Objective-C的对象模型还有信息可挖，回过头来看<code>objc_class</code>的<code>ivars</code>变量和<code>methodLists</code>变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars;</div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在运行时，类（包括class和metaclass）的<code>objc_class</code>结构体是固定的，不可能往这个结构体中添加数据，只能修改！譬如可以修改<code>isa</code>指针，让它指向一个中间类；在我的理解里，应该也可以修改<code>ivars</code>和<code>methodLists</code>，让它们指向一个新的区域；若可以这样，那么就可以在运行时随意添加/修改/删除成员变量和方法了。</p>
<p>但是，貌似Objective-C Runtime没有提供修改<code>ivars</code>和<code>methodLists</code>指针值的接口。</p>
<p>也因此，<code>ivars</code>在运行时指向的是一个固定区域，当然可以修改这个区域的值了，但这其实只是修改成员变量值而已；「在这个内存区域后面续上一段空余区域用于存放新的成员变量」？呵呵，想多了吧！因此，我们没办法在运行时为对象添加成员变量，这解释了为什么category中不能定义property（dynamic property不算）；</p>
<p>P.S: 那为什么protocol中可以添加变量，在我的理解里，protocol是在编译器处理的。所以<code>objc_class</code>中有一个变量叫<code>protocols</code>；</p>
<p>和<code>ivars</code>不同，<code>methodLists</code>是一个二维数组。虽然我们没办法扩展<code>methodLists</code>指向的内存区域，但是我们可以改变这个内存区域（这个内存区域存储的都是指针）的值。因此，我们可以在运行时动态添加（以及做其他的处理，譬如交换等）方法！</p>
<p>P.S: <code>objc_class</code>结构体中还有一个变量<code>cache</code>，顾名思义，它是用于缓存的，缓存啥呢？缓存方法，下一篇博客阐述「消息传递机制」时会谈到这个。</p>
<p>到了这里，谁还敢说Objective-C不是动态语言？</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Runtime/">Runtime</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-nshashtable-and-nsmaptable" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/26/nshashtable-and-nsmaptable/" class="article-date">
  	<time datetime="2015-04-26T00:53:43.000Z" itemprop="datePublished">2015-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/26/nshashtable-and-nsmaptable/">NSHashtable和NSMaptable</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>说明</strong></p>
<p>本文转自《<a href="http://www.cocoachina.com/industry/20140605/8683.html" target="_blank" rel="external">NSHashtable and NSMaptable</a>》，其原作者是<a href="http://nshipster.com/nshashtable-and-nsmaptable/" target="_blank" rel="external">Mattt Thompson</a>，该大神是AFNetworking的作者。作者简单介绍了一下iOS开发中相对于NSDictionary和NSSet来说，不常被人使用NSHashTable和NSMapTable的相关知识。</p>
<blockquote>
<p>P.S: 笔者关注《<a href="http://www.cocoachina.com/industry/20140605/8683.html" target="_blank" rel="external">NSHashtable and NSMaptable</a>》这篇博客的原因是因为以前遇到「如何实现NSNotificationCenter」这样的问题，我意识到实现NSNotificationCenter的关键在于找到一个能够支持弱指针的容器，而NSHashTable和NSMaptable恰好是这样的容器。</p>
</blockquote>
<p>NSSet，NSDictionary，NSArray是Foundation框架关于集合操作的常用类，和<a href="http://en.wikipedia.org/wiki/Java_collections_framework" target="_blank" rel="external">其他标准的集合操作库</a>不同，他们的实现方法对开发者进行<a href="http://ridiculousfish.com/blog/posts/array.html" target="_blank" rel="external">隐藏</a>，只允许开发者写一些简单的代码，让他们相信这些代码有理由正常的工作。</p>
<p>然而这样的话最好的代码抽象风格就会被打破，苹果的本意也被曲解了。在这种情况下，开发者寻求更好的抽象方式来使用集合，或者说寻找一种更通用的方式。</p>
<p>对于NSSet和NSDictionary，打破代码抽象风格的是他们在内存中存取object的方式。在NSSet中，objects是被强引用的（strongly referenced），同样NSDictionary中的keys和values也会被NSDictionary复制。如果一个开发者想要存储一个weak类型的值或者使用一个没有实现NSCopying协议的object作为NSDictionary的key，他可能会很聪明的想到<a href="http://nshipster.com/nsvalue/" target="_blank" rel="external">NSValue+valueWithNonretainedObject</a>。 iOS6和OSX 10.5以后，可以分别使用和NSSet，NSDictionary地位相同的NSHashTable，NSMapTable。</p>
<p>这两个类在Foundation的collection中不常用到，为了避免你慌乱无措，下面将介绍这两个类的用法。</p>
<h2 id="NSHashTable"><a href="#NSHashTable" class="headerlink" title="NSHashTable"></a>NSHashTable</h2><p>NSHashTable是更广泛意义的NSSet，区别于NSSet/NSMutableSet，NSHashTable有如下特性：</p>
<ul>
<li>NSHashTable是可变的；</li>
<li>NSHashTable可以持有weak类型的成员变量；</li>
<li>NSHashTable可以在添加成员变量的时候复制成员；</li>
<li>NSHashTable可以随意的存储指针并且利用指针的唯一性来进行hash同一性检查（检查成员变量是否有重复）和对比操作（equal）；</li>
</ul>
<p>用法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSHashTable</span> *hashTable = [<span class="built_in">NSHashTable</span> hashTableWithOptions:<span class="built_in">NSPointerFunctionsCopyIn</span>];</div><div class="line">[hashTable addObject:<span class="string">@"foo"</span>];</div><div class="line">[hashTable addObject:<span class="string">@"bar"</span>]; </div><div class="line">[hashTable addObject:@<span class="number">42</span>];</div><div class="line">[hashTable removeObject:<span class="string">@"bar"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Members: %@"</span>, [hashTable allObjects]);</div></pre></td></tr></table></figure>
<p>NSHashTable是根据一个option参数来进行初始化的，因为从OSX平台上移植到iOS平台上，原来OSX平台上使用的枚举类型被放弃了，从而用option来代替，命名也发生了一些变化：</p>
<ul>
<li>NSHashTableStrongMemory</li>
</ul>
<p>等同于NSPointerFunctionsStrongMemory。对成员变量进行强引用，这是一个默认值，如果采用这个默认值，NSHashTable和NSSet就没什么区别了。</p>
<ul>
<li>NSHashTableWeakMemory</li>
</ul>
<p>等同于NSPointerFunctionsWeakMemory。对成员变量进行弱引用，使用NSPointerFunctionsWeakMemory，object引用在最后释放的时候会被指向NULL。</p>
<ul>
<li>NSHashTableZeroingWeakMemory</li>
</ul>
<p>已被抛弃，使用NSHashTableWeakMemory代替。</p>
<ul>
<li>NSHashTableCopyIn</li>
</ul>
<p>在对象被加入集合之前进行复制（<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSPointerFunctions_Class/index.html#//apple_ref/occ/instp/NSPointerFunctions/acquireFunction" target="_blank" rel="external">NSPointerFunction-acquireFunction</a>），等同于NSPointerFunctionsCopyIn。</p>
<ul>
<li>NSHashTableObjectPointerPersonality</li>
</ul>
<p>用指针来等同代替实际的值，当打印这个指针的时候相当于调用description方法。和NSPointerFunctionsObjectPointerPersonality等同。</p>
<h2 id="NSMapTable"><a href="#NSMapTable" class="headerlink" title="NSMapTable"></a>NSMapTable</h2><p>NSMapTable是对更广泛意义的NSDictionary。和NSDictionary/NSMutableDictionary相比具有如下特性：</p>
<ul>
<li>NSDictionary/NSMutableDictionary会复制keys并且通过强引用values来实现存储；</li>
<li>NSMapTable是可变的；</li>
<li>NSMapTable可以通过弱引用来持有keys和values，所以当key或者value被deallocated的时候，所存储的实体也会被移除；</li>
<li>NSMapTable可以在添加value的时候对value进行复制；</li>
</ul>
<p>和NSHashTable类似，NSMapTable可以随意的存储指针，并且利用指针的唯一性来进行对比和重复检查。</p>
<p>用法：假设用NSMapTable来存储不用被复制的keys和被若引用的value，这里的value就是某个delegate或者一种弱类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> delegate = ...;</div><div class="line"><span class="built_in">NSMapTable</span> *mapTable = [<span class="built_in">NSMapTable</span> mapTableWithKeyOptions:<span class="built_in">NSMapTableStrongMemory</span></div><div class="line">                                             valueOptions:<span class="built_in">NSMapTableWeakMemory</span>];</div><div class="line">[mapTable setObject:delegate forKey:<span class="string">@"foo"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Keys: %@"</span>, [[mapTable keyEnumerator] allObjects]);</div></pre></td></tr></table></figure>
<p>看完上面几个小例子后，你可能会想 “为什么不使用object subscripting呢?”。一些激进的NSHipster估计已经开始动手写NSMapTable的subscripting category了。</p>
<p><strong>那么为什么NSMapTable不能继承subscripting？</strong></p>
<p>来看看下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)objectForKeyedSubscript:(<span class="keyword">id</span> &lt;<span class="built_in">NSCopying</span>&gt;)key;</div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)obj forKeyedSubscript:(<span class="keyword">id</span> &lt;<span class="built_in">NSCopying</span>&gt;)key;</div></pre></td></tr></table></figure>
<p><strong>注意：参数key是类型的</strong>。这对NSDictionary NSMutableDictionary来讲是非常有用的，但是我们不能臆断对NSMapTable也同样适用。我们陷入一个僵局：通过id，我们不能利用NSMapTable实现subscripting。如果object subscripting的代理方法放弃了约束，那么使用NSMutableDictionary -setObject:forKeyedSubscript:的时候编译将得不到想要的结果。</p>
<p>所以说实话，对比NSMapTable所处的位置，句法的方便和快捷并不是大数人所关注的。</p>
<p>通常，记住编程不是为了让人更聪明，而是最大化抽象一个问题的能力。NSSet和NSDictionary是非常伟大的类，他们能解决99%的问题，也无疑是用来工作的正确工具。如果，然而你的问题牵扯到上述的内存问题时候，NSHashTable和NSMapTable是值得一看的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-thread-basics-in-ios" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/17/thread-basics-in-ios/" class="article-date">
  	<time datetime="2015-04-17T12:37:32.000Z" itemprop="datePublished">2015-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/17/thread-basics-in-ios/">iOS Thread基础知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>无论是什么开发环境，多线程总是一个绕不开的概念，本文是对iOS开发过程中多线程基础知识的汇总。本文最主要的参考资料是《<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a>》，为了方便，下文所指的<strong>文档</strong>除非有特别说明，否则都是指《Threading Programming Guide》；本文还参考《UNIX环境高级编程》，该书在CS领域地位非常之高，大家习惯称之为APUE，显得逼格更高，本文也不避俗，下文中使用APUE代指《UNIX环境高级编程》。</p>
<h2 id="多线程编程的几种方式"><a href="#多线程编程的几种方式" class="headerlink" title="多线程编程的几种方式"></a>多线程编程的几种方式</h2><p><strong>Cocoa有哪几种方法多线程编程方式？</strong></p>
<p>iOS开发领域多线程编程方式有很多中，这里只谈论基于Cocoa的多线程编程，不包括比较底层的C语言级别的多线程编程（譬如基于POSIX API）。</p>
<p>主要有三种方式：</p>
<ul>
<li>基于<code>NSThread</code></li>
<li>基于GCD</li>
<li>基于<code>NSOperation</code></li>
</ul>
<h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p>相较于后两种多线程编程方式，基于<code>NSThread</code>的多线程编程麻烦多了，需要考虑很多问题，包括：</p>
<ul>
<li>手动创建线程</li>
<li>配置线程属性</li>
<li>线程内存池管理</li>
<li>终止线程</li>
</ul>
<p>本文只是为了做个简介，如下内容只涉及两方面：创建线程、运行线程。</p>
<p><strong>创建线程</strong></p>
<p><code>NSThread</code>是一个类名，顾名思义，它是iOS对thread的一种封装。基于<code>NSThread</code>创建线程有两种方式：</p>
<ul>
<li>使用<code>detachNewThreadSelector:toTarget:withObject:</code>类方法来生成一个新的线程</li>
<li>创建一个新的<code>NSThread</code>对象，并调用它的<code>start</code>方法（在iOS和Mac OS X 10.5+版本才支持）</li>
</ul>
<p><code>detachNewThreadSelector:toTarget:withObject:</code>类方声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)detachNewThreadSelector:(SEL _Nonnull)aSelector</div><div class="line">                       toTarget:(<span class="keyword">id</span> _Nonnull)aTarget</div><div class="line">                     withObject:(<span class="keyword">id</span> _Nullable)anArgument;</div><div class="line"><span class="comment">/* 参数说明：</span></div><div class="line"> * aSelector</div><div class="line"> *     The selector for the message to send to the target. </div><div class="line"> *     This selector must take only one argument and must not have a return value.</div><div class="line"> * aTarget  </div><div class="line"> *     The object that will receive the message aSelector on the new thread.</div><div class="line"> * anArgument   </div><div class="line"> *     The single argument passed to the target. May be nil.</div><div class="line"> */</div></pre></td></tr></table></figure>
<p>如果调用该接口，会立马创建并启动一个新线程；如果想创建一个线程但并不立马启动它，则使用如下方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSThread</span> *myThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span></div><div class="line">                                             selector:<span class="keyword">@selector</span>(doNothing)</div><div class="line">                                               object:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>此方法和<code>detachNewThreadSelector:toTarget:withObject:</code>方法初始化一个新的<code>NSThread</code>实例需要相同的开销。然而它并没有启动一个线程，若需要启动一个线程，可以显式调用对象的<code>start</code>方法，即<code>[myThread start];</code>。</p>
<p>值得一提的是，如果你拥有一个<code>NSThread</code>对象，它的线程当前正在运行，你可以给该线程发送消息的唯一方法是在你应用程序里面的任何对象使用<code>performSelector:onThread:withObject:waitUntilDone:</code>方法。</p>
<p><strong>Using NSObject to Spawn a Thread</strong></p>
<p>除了以上两种方式之外，还可以使用<code>NSObject</code>派生出一个thread。iOS和OS X v10.5+版本都可以使用接口<code>performSelectorInBackground:withObject:</code>来派生出一个新thread，这个API和上文的<code>detachNewThreadSelector:toTarget:withObject:</code>有些类似，不同的是它没有target参数，因为target就是调用者本身，这里需要传入的第一个参数对应的是调用者的某个方法。</p>
<p>P.S: 不晓得这个接口有什么应用场景？</p>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>本博客有多篇关于GCD的博客，详见<a href="/tags/GCD/">GCD</a>。</p>
<h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p>《<a href="/nsoperation-vs-gcd/">NSOperation v.s GCD</a>》一文中对<code>NSOperation</code>的使用有详细说明。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>线程同步可是多线程领域的热门话题。线程是不存在独立内存空间的，同属一个进程的线程们共享所属进程的内存空间。当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图。如果每个线程使用的变量都是其他线程不会读取或修改的，那么就不存在一致性（同步）问题；同样地，如果变量是只读的，那么线程同时读取该变量也不会有一致性（同步）问题。但是，当某个线程可以修改变量，而其他线程也可以读取或者修改这个变量时，就需要对这些线程进行同步，以确保它们在访问变量的存储内容时不会访问到无效的数值。</p>
<p>《<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-124887" target="_blank" rel="external">Threading Programming Guide</a>》中介绍了5种同步工具：</p>
<ul>
<li>原子操作</li>
<li>内存屏障和volatile变量</li>
<li>锁</li>
<li>条件变量</li>
<li>Perform Selector Routines</li>
</ul>
<p>根据我的理解，第二种同步工具「内存屏障和volatile变量」的本质是从控制编译的思路解决线程同步问题，这个太高深，本文就不涉及了，况且文档明确警告慎用：</p>
<blockquote>
<p>Because both memory barriers and volatile variables decrease the number of optimizations the compiler can perform, they should be used sparingly and only where needed to ensure correctness. For information about using memory barriers, see the OSMemoryBarrier man page.</p>
</blockquote>
<p>至于最后一种同步工具在我看来把它划分到线程通信或许更合适。</p>
<p>因此本文只介绍其余3种同步工具。</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作是同步的一个简单的形式，它处理简单的数据类型。对于简单的操作，比如递增一个计数器，原子操作比使用锁（下文会提到）具有更高的性能优势。</p>
<p>对原子操作的理解是非常基础的知识，本文就不多赘述了，我好奇的是Mac OS X/iOS的原子操作的实现机制。刚开始怀疑它是对下文要提到的互斥锁的一种封装，但看官方文档感觉不像，毕竟官方文档明确表明，对于简单的操作，原子操作比互斥锁具有更高的性能。如果是对互斥锁的封装，性能怎么可能会超过互斥锁呢？博文《<a href="http://www.infoq.com/cn/articles/atomic-operation/" target="_blank" rel="external">原子操作的实现原理</a>》对这个问题进行了比较详细的分析，虽然不确定详细实现，但能确定Apple的原子性实现是基于非常底层的处理。</p>
<p>在iOS开发中，我们如何使用<strong>原子操作</strong>这个同步工具呢？最常见的莫过于是对属性进行原子保护，只需要使用<code>atomic</code>修饰需要保护的属性即可；至于在其他场合使用原子操作工具，可以参考<code>/usr/include/libkern/OSAtomic.h</code>，该文件提供了大量的原子操作接口。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>锁是最常用的同步工具</strong>。你可以是使用锁来保护临界区（critical section），这些代码段在同一个时间只能允许被一个线程访问。比如，一个临界区可能会操作一个特定的数据结构，或使用了每次只能一个客户端访问的资源。根据应用场景不同，锁有许多划分：</p>
<ul>
<li>互斥锁（mutex）</li>
<li>递归锁（recursive lock）</li>
<li>读写锁（read-write lock）</li>
<li>分布锁（distributed lock）</li>
<li>自旋锁（spin lock）</li>
<li>双重检查锁（double-checked lock）</li>
</ul>
<p>不同开发语言中定义的锁的种类和应用场景可能不尽相同，如上这些锁是在文档中涉及过的；此外，和其他资源一样，下文中的锁资源只涉及Objective-C类型资源，更底层的譬如POSIX接口资源就不涉及了。</p>
<p><strong>互斥锁（Mutex）</strong></p>
<p>互斥锁在APUE中被称为<strong>互斥量</strong>，<strong>互斥锁</strong>的叫法更为广泛。根据我的理解，和其他锁一样，互斥锁的本质是基于信号量的封装，文档中明确写道：A mutex is a type of semaphore that grants access to only one thread at a time.</p>
<p>简单来说，<strong>互斥锁是一种特殊的变量，用来保护同一时间只有一个线程访问数据</strong>。顾名思义，可以把它看做一把锁，在访问共享资源前对之进行加锁（lock），在访问完后释放之（unlock）。对mutex加锁后，其他任何试图再次对mutex加锁的线程将会被阻塞直到当前线程释放mutex（unlock）。如果释放mutex时有多个线程阻塞，则所有在该mutex上的阻塞线程都会变成可运行状态，第一个变为可运行状态的线程可以对mutex加锁，进而访问共享资源，而其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新被释放。</p>
<p>P.S: 容易想到，加锁和释放锁的操作都是原子的！</p>
<p>值得注意的是，在开发时需要确保所有的线程必须遵守相同的数据访问规则：在使用共享资源时先获取锁，使用完了便释放锁。只有这样，互斥机制才能正常工作。操作系统并不会做数据访问的串行化，如果允许其中的某个线程在没有得到锁的情况下也可以访问共享资源，那么即使其他的线程在使用共享资源前都获取了锁，也还是会出现数据不一致的情况。</p>
<p>互斥锁的使用非常简单，基本套路就是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[lock lock];            <span class="comment">// 上锁</span></div><div class="line">handle common source    <span class="comment">// 处理公共资源</span></div><div class="line">[lock unlock];          <span class="comment">// 释放锁</span></div></pre></td></tr></table></figure>
<p>如下是一个比较详细的示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span> </span>&#123;</div><div class="line">    <span class="built_in">NSLock</span> *testLock;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化「锁」</span></div><div class="line">    testLock = [[<span class="built_in">NSLock</span> alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">// 1号线程</span></div><div class="line">    <span class="built_in">NSThread</span> *thread1 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span></div><div class="line">                                                selector:<span class="keyword">@selector</span>(commonSource)</div><div class="line">                                                  object:<span class="literal">nil</span>];</div><div class="line">    thread1.name = <span class="string">@"1号线程"</span>;</div><div class="line">    [thread1 start];</div><div class="line"></div><div class="line">    <span class="comment">// 2号线程</span></div><div class="line">    <span class="built_in">NSThread</span> *thread2 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span></div><div class="line">                                                selector:<span class="keyword">@selector</span>(commonSource)</div><div class="line">                                                  object:<span class="literal">nil</span>];</div><div class="line">    thread2.name = <span class="string">@"2号线程"</span>;</div><div class="line">    [thread2 start];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)commonSource &#123;</div><div class="line">    [testLock lock];    <span class="comment">// 上锁</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ 已经锁住公共资源"</span>, [<span class="built_in">NSThread</span> currentThread].name);</div><div class="line">    sleep(<span class="number">5</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ 将要释放公共资源"</span>, [<span class="built_in">NSThread</span> currentThread].name);</div><div class="line">    [testLock unlock];  <span class="comment">// 释放锁</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>NSLock</code>提供的接口除了<code>lock</code>和<code>unlock</code>之外，还有<code>-(BOOL)tryLock</code>和<code>-(BOOL)lockBeforeDate:</code>这两个API。</p>
<p><code>tryLock</code>尝试给<code>NSLock</code>对象上锁，若上锁成功，则返回<code>YES</code>，否则，返回<code>False</code>，但它不会阻塞线程，<code>tryLock</code>的一般用法是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([testLock tryLock]) &#123;</div><div class="line">    handle common source    <span class="comment">// 处理公共资源</span></div><div class="line">    [testLock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>lockBeforeDate:</code>，它给获取锁设定一个时间，在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回<code>NO</code>；</p>
<p><strong>使用@synchronized指令</strong></p>
<p><code>@synchronized</code>指令而不是<code>@synthesize</code>哦！<code>@synchronized</code>是实现互斥锁的一种简洁版本。使用方式如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)myMethod:(<span class="keyword">id</span>)anObj &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(anObj) &#123;</div><div class="line">        <span class="comment">// Everything between the braces is protected by the @synchronized directive.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传给<code>@synchronized</code>指令的参数<code>self</code>是几个意思呢？文档说明如下：</p>
<blockquote>
<p>The object passed to the @synchronized directive is a unique identifier used to distinguish the protected block. If you execute the preceding method in two different threads, passing a different object for the <em>anObj</em> parameter on each thread, each would take its lock and continue processing without being blocked by the other. If you pass the same object in both cases, however, one of the threads would acquire the lock first and the other would block until the first thread completed the critical section.</p>
</blockquote>
<p><strong>递归锁（recursive lock）</strong></p>
<p>使用<strong>互斥锁</strong>这个同步工具，哪怕各个线程在使用公共资源时都严格遵守「上锁-使用-释放」规则，仍然会有问题：当某个线程在持有锁的情况下再次获取锁时会造成死锁，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)commonSource &#123;</div><div class="line">    [testLock lock];    <span class="comment">// 上锁</span></div><div class="line">    [testLock lock];    <span class="comment">// 上锁</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ 已经锁住公共资源"</span>, [<span class="built_in">NSThread</span> currentThread].name);</div><div class="line">    sleep(<span class="number">5</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ 将要释放公共资源"</span>, [<span class="built_in">NSThread</span> currentThread].name);</div><div class="line">    [testLock unlock];  <span class="comment">// 释放锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>递归锁</strong>和<strong>互斥锁</strong>差不多，只是不同的是它允许线程可以多次获取锁而不会造成死锁。</p>
<p>在Cocoa中，<strong>递归锁</strong>对应的类型是<code>NSRecursiveLock</code>，其接口和<code>NSLock</code>完全一致，就不再使用示例说明其用法了。</p>
<p><strong>读写锁（read-write lock）</strong></p>
<p>Cocoa没有提供<strong>读写锁</strong>相关的类型，引自文档：</p>
<blockquote>
<p>The system supports read-write locks using POSIX threads only. For more information on how to use these locks, see the pthread man page.</p>
</blockquote>
<p>本文只对<strong>读写锁</strong>进行简要介绍。</p>
<p><strong>读写锁</strong>与<strong>互斥锁</strong>类似，不过<strong>读写锁</strong>允许更高的并行性。<strong>互斥锁</strong>要么是锁住状态要么是不加锁状态，而且一次只能有一个线程对其加锁。<strong>读写锁</strong>可以有三种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有<strong>写模式</strong>的读写锁，但是多个线程可以同时占有<strong>读模式</strong>的读写锁。</p>
<p>当<strong>读写锁</strong>是<strong>写加锁</strong>状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。</p>
<p>当<strong>读写锁</strong>是<strong>读加锁</strong>状态时，所有试图以<strong>读模式</strong>对它进行加锁的线程都可以得到访问权，但是如果线程希望以<strong>写模式</strong>对此锁进行加锁，它必须阻塞直到所有线程释放读锁。虽然<strong>读写锁</strong>的实现各不相同，但当<strong>读写锁</strong>处于<strong>读模式</strong>锁住状态时，如果有另外的线程试图以<strong>写模式</strong>加锁，读写锁通常会阻塞随后的<strong>读模式</strong>锁请求，这样可以避免<strong>读模式</strong>长期占用，而等待的<strong>写模式</strong>请求一直得不到满足。</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。</p>
<p>当<strong>读写锁</strong>在<strong>写模式</strong>下时，它所保护的数据结构就可以被安全地修改，因为当前只有一个线程可以在<strong>写模式</strong>下拥有这个锁。</p>
<p>当<strong>读写锁</strong>在<strong>读模式</strong>下时，只要线程获取了读模式下的读写锁，该锁所保护的数据结构可以被多个获得读模式锁的线程所保护。</p>
<p>读写锁也叫做「共享-独占锁」，当<strong>读写锁</strong>以<strong>读模式</strong>锁住时，它是以共享模式锁住的，当它以<strong>写模式</strong>锁住时，它是以独占模式锁住的。</p>
<p><strong>分布锁（distributed lock）</strong></p>
<p><strong>分布锁</strong>是进程级别的同步工具：</p>
<blockquote>
<p>A distributed lock provides mutually exclusive access at the process level. Unlike a true mutex, a distributed lock does not block a process or prevent it from running. It simply reports when the lock is busy and lets the process decide how to proceed.</p>
</blockquote>
<p>本文略过！</p>
<p><strong>自旋锁（spin lock）</strong></p>
<p>引自百度百科：</p>
<blockquote>
<p><strong>自旋锁是专为防止多处理器并发而引入的一种锁</strong>。何谓<strong>自旋锁</strong>？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，「自旋」一词就是因此而得名。</p>
</blockquote>
<p>Mac OS X/iOS系统没有提供自旋锁的实现：</p>
<blockquote>
<p>The system does not provide any implementations of spin locks because of their polling nature, but you can easily implement them in specific situations. For information on implementing spin locks in the kernel, see <em>Kernel Programming Guide</em>.</p>
</blockquote>
<p>本文略过！</p>
<p><strong>双重检查锁（double-checked lock）</strong></p>
<p>关于双重检查锁，能够找到的资料不多，引自文档：</p>
<blockquote>
<p>A double-checked lock is an attempt to reduce the overhead of taking a lock by testing the locking criteria prior to taking the lock. Because double-checked locks are potentially unsafe, the system does not provide explicit support for them and their use is discouraged.</p>
</blockquote>
<h2 id="关于锁的一些总结"><a href="#关于锁的一些总结" class="headerlink" title="关于锁的一些总结"></a>关于锁的一些总结</h2><p><strong>避免死锁</strong></p>
<p>锁是最常用的同步工具，同时，使用锁作为同步工具也存在一些问题，最经典的问题莫过于死锁。</p>
<p>上文在介绍递归锁时已经介绍了一种死锁情况：如果线程试图对一个<strong>互斥锁</strong>加锁两次，那么它自身就会陷入<strong>死锁</strong>状态。除此之外，还有一些更不明显的方式也可能会产生死锁。例如，程序中使用多个<strong>互斥锁</strong>时，如果允许一个线程一直占有第一个<strong>互斥锁</strong>，并且在试图锁住第二个互斥锁时处于阻塞状态，但是拥有第二个<strong>互斥锁</strong>的线程也在试图锁住第一个<strong>互斥锁</strong>，此时也会发生死锁，因为此时两个线程都在相互请求对方拥有的资源，所以这两个线程都无法向前运行，于是就产生<strong>死锁</strong>。</p>
<p><strong>原子操作和互斥锁的代价</strong></p>
<p>在很多场合下，既可以选择使用<strong>原子操作</strong>作为同步工具，也可以选择使用<strong>互斥锁</strong>；面对这种场景，应该选择哪个呢？站在性能的角度，当然应该选择性能更棒的，针对二者的性能对比，文档提供了一张表：</p>
<div class="imagediv" style="width: 780px; height: 320px"></div>

<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>关于条件变量，文档的描述如下：</p>
<blockquote>
<p><strong>A condition is another type of semaphore</strong> that allows threads to signal each other when a certain condition is true. Conditions are typically used to indicate the availability of a resource or to ensure that tasks are performed in a specific order. When a thread tests a condition, it blocks unless that condition is already true. It remains blocked until some other thread explicitly changes and signals the condition.</p>
</blockquote>
<p><strong>条件变量</strong>为多个线程提供了一个会合的场所，和<strong>锁</strong>不同，<strong>条件变量</strong>允许线程以无竞争的方式等待特定的条件发生。</p>
<p>P.S: 所谓「无竞争」，根据我的理解，指的是线程之间不会以无序混乱的方式抢占公共资源，对于互斥锁，如果不考虑两个线程的时间先后顺序，它们抢占公共资源的概率均是50%，谁先获得是未知的。</p>
<p>基于<strong>条件变量</strong>的同步操作，主要包括两个动作：一个线程等待「条件变量的条件为真」；另一个线程使「条件成立」。前者<strong>读</strong>（或曰测试）条件变量，后者修改条件变量，当然需要保证其操作原子性，所以一般使用互斥锁保护条件变量本身。</p>
<p>文档介绍了一种需要条件变量作为同步工具的应用场景：</p>
<blockquote>
<p>One way you might use a condition is to manage a pool of pending events. The event queue would use a condition variable to signal waiting threads when there were events in the queue. If one event arrives, the queue would signal the condition appropriately. If a thread were already waiting, it would be woken up whereupon it would pull the event from the queue and process it. If two events came in to the queue at roughly the same time, the queue would signal the condition twice to wake up two threads.</p>
</blockquote>
<p>OK，来介绍<code>NSCondition</code>（Cocoa中实现condition的类型）的使用方法。<code>NSCondition</code>的接口非常少，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSCondition</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt;</span></div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)wait;         <span class="comment">// 等待「条件满足」，被唤醒</span></div><div class="line">- (<span class="built_in">BOOL</span>)waitUntilDate:(<span class="built_in">NSDate</span> *)limit;</div><div class="line">- (<span class="keyword">void</span>)signal;       <span class="comment">// 通知条件已满足，唤醒某个等待的线程</span></div><div class="line">- (<span class="keyword">void</span>)broadcast;    <span class="comment">// 通知条件已满足，唤醒所有等待的线程</span></div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>NSCondition</code>将用于保护condition原子性的互斥锁和condition打包封装到了一起，它遵循<code>NSLocking</code>协议，所以实现了<code>lock</code>和<code>unlock</code>这两个方法，用户不用额外创建锁。<code>NSCondition</code>的一般使用形式如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// myCondition: NSCondition object</span></div><div class="line"><span class="comment">// someCheckIsTrue: test condition</span></div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)method1 &#123;</div><div class="line">    [myCondition lock];             <span class="comment">// 设置锁，防止condition被别个线程修改</span></div><div class="line">    <span class="keyword">while</span> (!someCheckIsTrue) &#123;      <span class="comment">// 测试condition</span></div><div class="line">        [myCondition wait];         <span class="comment">// 睡眠，等待被唤醒</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Do something.</span></div><div class="line">    </div><div class="line">    [myCondition unlock];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">    [myCondition lock];             <span class="comment">// 设置锁，防止别个线程读取condition</span></div><div class="line">    </div><div class="line">    <span class="comment">// Do something.</span></div><div class="line">    </div><div class="line">    someCheckIsTrue = <span class="literal">YES</span>;          <span class="comment">// 更新condition</span></div><div class="line">    [myCondition signal];           <span class="comment">// 通知condition已满足，唤醒某个正在等待的线程</span></div><div class="line">    [myCondition unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对代码进行说明：</p>
<ol>
<li>所谓test condition，并不是指test <code>NSCondition</code>对象，被test的condition可以是任何形式，譬如<code>[myArray count] == 0</code>等；</li>
<li>method1中<code>while</code>循环不能使用<code>if</code>代替，在<code>while</code>循环中检查条件，被唤醒后会再次test condition，若不满足会继续睡眠；</li>
<li>method2中的最后两行代码在我看来顺序无所谓，因为condition已经在上一行代码中更新完了，晚点儿解锁也没问题；</li>
</ol>
<h2 id="其他线程同步方式"><a href="#其他线程同步方式" class="headerlink" title="其他线程同步方式"></a>其他线程同步方式</h2><p>对于iOS开发而言，如上所介绍的线程同步工具并非最好的选择，根据《Effective Objective-C 2.0》的说法，以上同步工具都不如使用GCD工具。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://book.douban.com/subject/1788421/" target="_blank" rel="external">UNIX环境高级编程</a></li>
<li><a href="http://www.infoq.com/cn/articles/atomic-operation/" target="_blank" rel="external">原子操作的实现原理</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD/">GCD</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-basics-in-objective-c" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/12/basics-in-objective-c/" class="article-date">
  	<time datetime="2015-04-12T14:27:32.000Z" itemprop="datePublished">2015-04-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/12/basics-in-objective-c/">Objective-C基础知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文属于汇总文，对Objective-C语言层面的一些基础问题进行汇总，有的问题可直接在本文找到答案，有的知识提供其他博文的链接。</p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>「内联函数」是一个很老的概念，在其他语言譬如C++语言中也出现了。所谓「内联函数」指的是：有函数的结构，但不具备函数的性质，类似于宏替换功能的代码块。</p>
<p>在实际应用中，常常把规模较小、逻辑较简单的操作定义成内联函数，定义内联函数只要在函数前面加上<code>inline</code>关键字修饰即可；站在编译器的角度，处理内联函数就是在每个它的调用点上「内联地」展开。假设有定义如下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="built_in">NSString</span> * getNavigationTitleWithCount(<span class="keyword">int</span> cnt) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"已选中%d项"</span>, (<span class="keyword">int</span>)cnt];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>则编译器对如下代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UILabel</span> *label = [<span class="built_in">UILabel</span> new];</div><div class="line">label.text = getNavigationTitleWithCount(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>的处理，如同对如下代码代码的处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UILabel</span> *label = [<span class="built_in">UILabel</span> new];</div><div class="line">label.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"已选中%d项"</span>, (<span class="keyword">int</span>)<span class="number">0</span>];</div></pre></td></tr></table></figure>
<p>一句话说明：<strong>程序在调用内联函数时的开销和调用宏的开销是一样的，但内联函数显然比宏要强大一些，至少它保证了类型安全</strong>；相较于普通函数，调用内联函数没有「保护现场、push栈、pop栈等等」之类的开销。</p>
<p>内联函数的好处显而易见，但并不是所有函数都可以形成真正的内联函数。如上所述，定义一个内联函数只要在定义时加上<code>inline</code>关键字即可，但能否形成真正的内联函数，还要看编译器对内联函数体内部定义的具体处理。</p>
<p>一般来说，内联函数定义的代码量逻辑简单、代码量小，并且属于那种频繁使用的代码块；<strong>内联函数不能使用循环语句，不能使用递归调用</strong>；</p>
<h2 id="const的使用"><a href="#const的使用" class="headerlink" title="const的使用"></a>const的使用</h2><p>在Objective-C代码中，经常需要定义一些常量指针，譬如AFNetworking中有如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityDidChangeNotification;</div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityNotificationStatusItem;</div></pre></td></tr></table></figure>
<p>和其他语言一样，定义常量的关键字是<code>const</code>，但问题是常常不知道<code>const</code>该往哪里放，<code>NSString * const XXOO</code>还是<code>NSString const * XXOO</code>？</p>
<p>其实，在Objective-C中还好一点，C/C++中<code>const</code>的各种使用姿势更难懂，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * label1       = <span class="string">""</span>;</div><div class="line"><span class="keyword">char</span> <span class="keyword">const</span> * label2       = <span class="string">""</span>;</div><div class="line"><span class="keyword">char</span> * <span class="keyword">const</span> label3       = <span class="string">""</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> label4 = <span class="string">""</span>;</div></pre></td></tr></table></figure>
<p>经常傻傻分不清楚。不过还好，脑子恰好还残留着一些本科老师讲过的内容，记得本科C语言老师教过一种简单的记忆方法：const总是修饰其左边的东东，如果其左边没有东东，则修饰右边的东东。</p>
<p>如何理解呢？对于<code>char const * label2</code>而言，const的左边是char，所以const修饰的是char本身，即内容本身，所以表示“label1指向的内容是常量，不可变”；对于<code>const char * label1</code>而言，const左边没有东东，所以它修饰右边的东东，即char，所以表示“label2指向的内容是常量，不可变”；对于<code>char * const label3</code>，const左边的东东是*，所以修饰的是指针，即表示“label3指针本身是常量，不可变”，所以解释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * label1       = <span class="string">""</span>;      <span class="comment">// 内容是常量，不可变</span></div><div class="line"><span class="keyword">char</span> <span class="keyword">const</span> * label2       = <span class="string">""</span>;      <span class="comment">// 内容是常量，不可变</span></div><div class="line"><span class="keyword">char</span> * <span class="keyword">const</span> label3       = <span class="string">""</span>;      <span class="comment">// 指针是常量，不可变</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> label4 = <span class="string">""</span>;      <span class="comment">// 指针和内容都是常量，不可变</span></div></pre></td></tr></table></figure>
<p>这个判断方法同样适用于Objective-C，所以如下代码是没问题的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// const的左边是NSString，修饰的是NSString对象，表示“NSString对象本身不可修改”（但指针可以）</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> <span class="keyword">const</span> * testString = <span class="string">@"I am an iOS developer"</span>;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    testString = <span class="string">@"我是一个iOS开发者"</span>; <span class="comment">// 合法</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, testString);   <span class="comment">// print "我是一个iOS开发者"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但如下代码不合法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// const的左边是*，修饰的是指针本身，表示testString地址值不可修改</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> testString = <span class="string">@"I am an iOS developer"</span>;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    testString = <span class="string">@"我是一个iOS开发者"</span>; <span class="comment">// 非法</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, testString);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="mm文件"><a href="#mm文件" class="headerlink" title=".mm文件"></a>.mm文件</h2><ul>
<li>.m文件是Objective-C文件</li>
<li>.mm文件相当于C++或者C文件</li>
</ul>
<h2 id="Extension和Category"><a href="#Extension和Category" class="headerlink" title="Extension和Category"></a>Extension和Category</h2><p>参考：<a href="http://blog.csdn.net/leikezhu1981/article/details/19091049" target="_blank" rel="external">http://blog.csdn.net/leikezhu1981/article/details/19091049</a></p>
<h2 id="Compiler-Directives"><a href="#Compiler-Directives" class="headerlink" title="Compiler Directives"></a>Compiler Directives</h2><p><a href="http://nshipster.com/at-compiler-directives/" target="_blank" rel="external">http://nshipster.com/at-compiler-directives/</a></p>
<p><a href="http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/</a></p>
<h2 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h2><p>详细内容参考《<a href="http://nshipster.cn/pragma/" target="_blank" rel="external">NSHipster – #pragma</a>》和《<a href="/pragma/">预处理指令#pragma</a>》</p>
<h2 id="0-nil-Nil-NULL-NSNull"><a href="#0-nil-Nil-NULL-NSNull" class="headerlink" title="0/nil/Nil/NULL/NSNull"></a>0/nil/Nil/NULL/NSNull</h2><p>这一部分内容摘自<a href="http://nshipster.cn/nil/" target="_blank" rel="external">nil/Nil/NULL/NSNull</a>，原文详见<a href="http://nshipster.com/nil/" target="_blank" rel="external">这里</a>。</p>
<p>理解「不存在」的概念不仅仅是一个哲学的问题，也是一个实际的问题。我们是有形宇宙的居民，而原因在于逻辑宇宙的存在不确定性。作为一个逻辑系统的物理体现，电脑面临一个棘手的问题，就是如何用存在表达「不存在」。</p>
<p>在Objective－C中，有几个不同种类的「不存在」。C语言用<code>0</code>来作为不存在的原始值，而<code>NULL</code>作为指针（这在指针环境中相当于<code>0</code>）。</p>
<p>Objective-C在C的基础上增加了<code>nil</code>。<code>nil</code>是一个指向不存在的对象指针，虽然它在语义上与<code>NULL</code>不同，但它们在技术上是相等的。</p>
<p>在框架层面，Foundation定义了<code>NSNull</code>，<code>NSNull</code>中有一个类方法<code>+null</code>，它返回一个单独的<code>NSNull</code>对象。NSNull与nil以及NULL不同，因为它是一个实际的对象，而不是一个零值。</p>
<p>另外，在<a href="https://gist.github.com/4469665" target="_blank" rel="external">Foundation/NSObjCRuntime.h</a>中，<code>Nil</code>被定义为指向零的类指针，可以把它看做是<code>nil</code>的表亲。虽然它鲜为人知，但至少值得注意一下。</p>
<p>总的来说，这里的四个表达没有的值是每个Objective-C程序员都应该知道的：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th style="text-align:center">值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NULL</td>
<td style="text-align:center">(void *)0</td>
<td style="text-align:center">C指针的字面零值</td>
</tr>
<tr>
<td style="text-align:center">nil</td>
<td style="text-align:center">(id)0</td>
<td style="text-align:center">Objective-C对象的字面零值</td>
</tr>
<tr>
<td style="text-align:center">Nil</td>
<td style="text-align:center">(Class)0</td>
<td style="text-align:center">Objective-C类的字面零值</td>
</tr>
<tr>
<td style="text-align:center">NSNull</td>
<td style="text-align:center">[NSNull null]</td>
<td style="text-align:center">用来表示零值的单独的对象</td>
</tr>
</tbody>
</table>
<h2 id="关于nil的一些事儿"><a href="#关于nil的一些事儿" class="headerlink" title="关于nil的一些事儿"></a>关于nil的一些事儿</h2><p>刚被分配的NSObject的内容被设置为0。也就是说那个对象所有的指向其他对象的指针都从<code>nil</code>开始，所以在<code>init</code>方法中设置<code>self.(association) = nil</code>之类的表达是没有必要的。</p>
<p>当然，也许nil最显著的行为是，它虽然为零，仍然可以有消息发送给它。在其他的语言中，比如C++，这样做会使你的程序崩溃，<strong>但在Objective-C中，在<code>nil</code>上调用方法返回一个零值</strong>。这大大的简化了表达，因为它避免了在使用<code>nil</code>之前对它的检查。</p>
<h2 id="isEqual-和"><a href="#isEqual-和" class="headerlink" title="isEqual:和=="></a>isEqual:和==</h2><p>参考<a href="http://nshipster.com/equality/。" target="_blank" rel="external">http://nshipster.com/equality/。</a></p>
<h2 id="基本数据类型长度"><a href="#基本数据类型长度" class="headerlink" title="基本数据类型长度"></a>基本数据类型长度</h2><table>
<thead>
<tr>
<th style="text-align:center">名字</th>
<th style="text-align:center">typedef（32bit/64bit）</th>
<th style="text-align:center">长度（32bit/64bit）（单位：bit）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">-</td>
<td style="text-align:center">32/32</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">-</td>
<td style="text-align:center">32/64</td>
</tr>
<tr>
<td style="text-align:center">long long</td>
<td style="text-align:center">-</td>
<td style="text-align:center">64/64</td>
</tr>
<tr>
<td style="text-align:center">NSInteger</td>
<td style="text-align:center">int/long</td>
<td style="text-align:center">32/64</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">-</td>
<td style="text-align:center">32/32</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">-</td>
<td style="text-align:center">64/64</td>
</tr>
<tr>
<td style="text-align:center">long double</td>
<td style="text-align:center">-</td>
<td style="text-align:center">128/128</td>
</tr>
<tr>
<td style="text-align:center">CGFloat</td>
<td style="text-align:center">float/double</td>
<td style="text-align:center">32/64</td>
</tr>
</tbody>
</table>
<p>对于<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>，在不同的平台下（32位和64位）下唯一有区别的是<code>long</code>，其余三个在不同硬件平台所占据数据长度是一致的；至于<code>NSInteger</code>和<code>NSFloat</code>，数据长度和平台完全对应，由此可见，基于Cocoa编程尽可能使用<code>NSInteger</code>和<code>NSFloat</code>，而不直接使用<code>int</code>、<code>float</code>等。</p>
<p>P.S：与<code>NSInteger</code>和<code>int</code>对应的是<code>NSUInteger</code>和<code>unsigned int</code>，但是不存在所谓的<code>unsigned float</code>和<code>CGUFloat</code>哦！</p>
<p><code>int</code>和<code>long</code>的最大值和最小值比较容易计算，<code>float</code>和<code>double</code>的最大值和最小值计算则麻烦多了，IEEE-754协议对此专门做了定义，详见<a href="http://baike.baidu.com/view/1698149.htm" target="_blank" rel="external">百度百科：IEEE-754</a>和<a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" rel="external">wiki: IEEE floating point</a></p>
<h2 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h2><p><strong>#import v.s #include</strong></p>
<p><code>#import</code>和<code>#include</code>的作用类似：都是先要求<strong>预处理器</strong>读取某个文件（一般是头文件），然后将读入的内容添加至输出到对应的位置；或者简单来说，二者都用作<strong>导入文件</strong>。前者确保<strong>预处理器</strong>对指定的文件只导入一次，后者则允许多次导入同一个文件。</p>
<p><strong>尖括号 v.s 双引号</strong></p>
<p>如果使用尖括号（<code>&lt;&gt;</code>），则编译器会先在预先设定好的标准目录下查找相应的文件（譬如系统头文件）；如果使用双引号（<code>&quot;&quot;</code>），则编译器会先在项目目录下查找相应的头文件。</p>
<p><strong>#import v.s @import</strong></p>
<p>如下内容摘自《<a href="http://www.cnblogs.com/sammyCoding/p/3654743.html" target="_blank" rel="external">在ios 7下，使用@import代替#import</a>》：</p>
<blockquote>
<p>在xcode 5 下，为了更易于开发，增加了modules和 auto-linking 这两个新特性。用 @import 来增加框架 到项目中比用 #import会更有效. 我们来看看为什么：</p>
<blockquote>
<p>Modules for system frameworks speed build time and provide an alternate means to import APIs from the SDK instead of using the C preprocessor. Modules provide many of the build-time improvements of precompiled headers with less maintenance or need for optimization. They are designed for easy adoption with little or no source changes. Beyond build-time improvements, modules provide a cleaner API model that enables many great features in the tools, such as Auto Linking.</p>
</blockquote>
<p>Modules and auto-linking 默认情况下是enabled的。 如果是旧的项目，你可以通过设置”Language - Modules.” 来设置Enable Modules 和Link Frameworks Automatically 为Yes。<br>另外一个使用moudules的好处是你再也不用去链接你的framework到你的项目了。<br>例如，在以前，如果你要使用MapKit这个框架，你要这样做<br>1) 使用语句 #import <mapkit mapkit.h=""> 导入框架<br>2) 去到项目的build phases 设置项，找到MapKit.framework.并加入到Link Binary With Libraries里面。<br>如果使用modules的话，只需要加入语句 “@import MapKit;” 你就可以开始使用了,根本不需要链接到你的项目。</mapkit></p>
</blockquote>
<p>更多内容参考《<a href="http://stackoverflow.com/questions/18947516/import-vs-import-ios-7" target="_blank" rel="external">stackoverflow: @import vs #import - iOS 7</a>》。</p>
<h2 id="弱引用的自动置零特性"><a href="#弱引用的自动置零特性" class="headerlink" title="弱引用的自动置零特性"></a>弱引用的自动置零特性</h2><p>当某个由弱引用指向的对象被释放时，相应的指针变量会被<strong>归零</strong>（zerod），即赋为<code>nil</code>。</p>
<h2 id="多态、动态类型和动态绑定"><a href="#多态、动态类型和动态绑定" class="headerlink" title="多态、动态类型和动态绑定"></a>多态、动态类型和动态绑定</h2><p><strong>什么是多态</strong></p>
<p>一句话解释：不同对象对同一个消息的不同响应。</p>
<p><strong>什么是动态绑定</strong></p>
<p>「动态绑定」是指在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>
<p><strong>动态类型id</strong></p>
<p><code>id</code>数据类型是一种通用的对象类型。也就是说，它可以用来存储任何对象。在代码中可以向id类型发送任何消息，Objective-C系统（编译器）不会在编译期对之进行类型检验，只有运行到相关代码时才会判断所引用对象的实际类型，然后根据实际的类型调用其相应的方法。</p>
<p>举个例子说明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">id</span> number = @<span class="number">5</span>;</div><div class="line">    <span class="keyword">if</span> ([number isEqualToString:<span class="string">@"whatTheFuck"</span>]) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"见鬼了"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，首先创建一个NSNumber类型实例，并把它赋给<code>id</code>类型变量number；在if语句中，向number发送<code>isEqualToString:</code>消息，根据我们对NSNumber的了解，它是没有定义<code>isEqualToString:</code>方法的，因此不会对这个消息进行响应。然而，这段代码完全可以以「0 error、0 warning」通过编译，只是在运行时会抛出NSInvalidArgumentException异常：<br>reason: ‘-[__NSCFNumber isEqualToString:]: unrecognized selector sent to instance 0x7bf67200’</p>
<p>这个示例形象阐述「动态绑定」的含义，并且验证了「id类型可以用来存储任何对象」的说法。</p>
<p><strong>Objective-C如何实现多态的</strong></p>
<p>根据上述对「多态」、「动态绑定」以及「动态类型id」的解释，可以直接回答：Objective-C实现多态的方式是动态绑定。</p>
<p>P.S：也有人认为「继承体系中方法重载也是实现多态的一种方式」，笔者对此比较疑惑，因为我总觉得「动态绑定」已将此包括进去了。</p>
<h2 id="synthesize-v-s-dynamic"><a href="#synthesize-v-s-dynamic" class="headerlink" title="@synthesize v.s @dynamic"></a>@synthesize v.s @dynamic</h2><p>引用<a href="http://stackoverflow.com/questions/1160498/synthesize-vs-dynamic-what-are-the-differences" target="_blank" rel="external">stackoverflow: @synthesize vs @dynamic, what are the differences?</a>：</p>
<blockquote>
<p>@synthesize will generate getter and setter methods for your property. @dynamic just tells the compiler that the getter and setter methods are implemented not by the class itself but somewhere else (like the superclass or will be provided at runtime).</p>
</blockquote>
<p>简单来说，<code>@synthesize</code>的作用是：指示编译器，让其在编译期间自动生成getter/setter方法；当有自定义的setter或getter实现时，自定义setter或getter会屏蔽自动生成的setter或getter。不晓得从什么时候开始，Xcode默认帮助合成属性，无需显式使用<code>@synthesize</code>指令。</p>
<p>P.S：根据我的理解，准确来说，<code>@synthesize</code>的作用还包括「自动合成property对应的实例变量」，当然，如果已然有对应的实例变量存在，则会略过。比如说property名为foo，存在一个名为_foo的实例变量，那么就不会再自动合成新变量了。总之，<code>@synthesize</code>是一个帮助省功夫的指令。</p>
<p>P.S：不晓得为什么，当对某个属性同时自定义setter和getter时，XCode要求必须显式书写<code>@synthesize</code>，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UserInfo</span> : <span class="title">NSObject</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div><div class="line">    </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UserInfo</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@synthesize</span> name = _name;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    _name = [name <span class="keyword">copy</span>];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="keyword">return</span> _name;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>而<code>@dynamic</code>告诉编译器，不在编译期自动生成getter/setter方法，setter和getter会在runtime提供。<code>@dynamic</code>的主要应用场景是Core Data，除此之外，在category使用关联属性时也会用到。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/12/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/14/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>