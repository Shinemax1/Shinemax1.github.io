<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/14/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.25px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 13.75px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 16.25px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.25px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 17.5px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 12.5px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.25px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 13.75px;">Tools</a> <a href="/tags/Transition/" style="font-size: 12.5px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 18.75px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js/" style="font-size: 11.25px;">js</a> <a href="/tags/js基础/" style="font-size: 20px;">js基础</a> <a href="/tags/node-js/" style="font-size: 11.25px;">node.js</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/事件环/" style="font-size: 10px;">事件环</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/宏任务/" style="font-size: 10px;">宏任务</a> <a href="/tags/微任务/" style="font-size: 10px;">微任务</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/流/" style="font-size: 10px;">流</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/面试/" style="font-size: 11.25px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，全栈开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-using-afnetworking-part-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/05/using-afnetworking-part-2/" class="article-date">
  	<time datetime="2015-04-04T18:04:32.000Z" itemprop="datePublished">2015-04-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/using-afnetworking-part-2/">AFNetworking使用笔记 第二弹</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>接着<a href="/using-afnetworking-part-1/">AFNetworking使用笔记 第一弹</a>继续写。本文分析两个问题：</p>
<ul>
<li>AFNetworking网络任务的创建是在哪个线程执行的？</li>
<li>网络任务的completion handler在哪一个线程被调用？</li>
</ul>
<h2 id="发送请求消息"><a href="#发送请求消息" class="headerlink" title="发送请求消息"></a>发送请求消息</h2><p>这一部分内容的着重点在于回答「AFNetworking网络任务的创建是在哪个线程执行的？」这个问题。其实这个问题也可以这样问「AFNetworking网络任务的创建是在main thread中完成的吗？」。</p>
<p>开始分析，以<code>AFHTTPSessionManager</code>的POST方法为例，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                    parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                       success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> responseObject))success</div><div class="line">                       failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error))failure</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"POST"</span></div><div class="line">                                                        URLString:URLString</div><div class="line">                                                       parameters:parameters</div><div class="line">                                                          success:success</div><div class="line">                                                          failure:failure];</div><div class="line">    </div><div class="line">    [dataTask resume];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其所作的事情很简单，创建一个<code>NSURLSessionDataTask</code>实例，并将它激活（resume），然后返回它。</p>
<p>进入<code>NSURLSessionDataTask</code>实例创建过程，最终进入如下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                            completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response,</div><div class="line">                                                        <span class="keyword">id</span> responseObject,</div><div class="line">                                                        <span class="built_in">NSError</span> *error))completionHandler</div><div class="line">&#123;</div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), ^&#123;</div><div class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask completionHandler:completionHandler];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然<code>url_session_manager_creation_queue()</code>是关键：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_creation_queue() &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_creation_queue;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        af_url_session_manager_creation_queue =</div><div class="line">        dispatch_queue_create(<span class="string">"com.alamofire.networking.session.manager.creation"</span>,</div><div class="line">                              DISPATCH_QUEUE_SERIAL);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> af_url_session_manager_creation_queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在应该可以得出答案了：</p>
<ul>
<li>根据上述的<code>dataTaskWithRequest:completionHandler:</code>里的代码段<code>dispatch_sync(...)</code>可以知道，创建网络任务的过程是同步完成的；</li>
<li>根据<code>url_session_manager_creation_queue()</code>的实现代码可以知道，创建网络任务的过程是并不是在main thread中完成的；</li>
</ul>
<p>这里分析的是基于POST请求消息的data task，其他task也是差不多，总之，我们可以得出结论，网络任务的创建并不是在main thread中进行的。</p>
<h2 id="处理响应消息"><a href="#处理响应消息" class="headerlink" title="处理响应消息"></a>处理响应消息</h2><p>这一部分内容的着重点在于回答「网络任务的completion handler在哪一个线程被调用？」。</p>
<p>依旧以POST请求消息的响应为例，<code>dataTaskWithHTTPMethod:URLString:parameters:success:failure:</code>方法代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                      parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                                         success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="keyword">id</span>))success</div><div class="line">                                         failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="built_in">NSError</span> *))failure</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *request =</div><div class="line">        [<span class="keyword">self</span>.requestSerializer requestWithMethod:method</div><div class="line">                                    URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString</div><div class="line">                                                      relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString]</div><div class="line">                                   parameters:parameters</div><div class="line">                                        error:&amp;serializationError];</div><div class="line">    <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">        <span class="keyword">if</span> (failure) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(<span class="literal">nil</span>, serializationError);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</div><div class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response,</div><div class="line">                                           <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            <span class="keyword">if</span> (failure) &#123;</div><div class="line">                failure(dataTask, error);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (success) &#123;</div><div class="line">                success(dataTask, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有上述代码可以看到，当构造请求消息失败时，会异步在main thread中调用completionHandler block。</p>
<p>当接收到响应消息时，相应的处理在<code>AFURLSessionManager</code>类的<br><code>URLSession:task:didCompleteWithError:</code>方法中完成，该方法代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</div><div class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</div><div class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</div><div class="line">                <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:[<span class="built_in">NSData</span> dataWithData:<span class="keyword">self</span>.mutableData] error:&amp;serializationError];</div><div class="line">    </div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</div><div class="line">                responseObject = <span class="keyword">self</span>.downloadFileURL;</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            <span class="keyword">if</span> (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</div><div class="line">                    <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</div><div class="line">                &#125;</div><div class="line">    </div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中出现了<code>url_session_manager_processing_queue()</code>方法，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_processing_queue() &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_processing_queue;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        af_url_session_manager_processing_queue = dispatch_queue_create(<span class="string">"com.alamofire.networking.session.manager.processing"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> af_url_session_manager_processing_queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这段代码可以看到，当response出现错误时，AFNetworking会在main thread异步调用completionHandler block；若response没有错误时，就会在异步并行队列中对response进行处理，处理完之后，再在main thread中调用completionHandler block。</p>
<p>总之，请求消息的构建工作是以同步形式在非main thread中进行的；对response的处理是以异步形式在非main thread中处理的；无论是哪个步骤的处理失败和成功，都会在main thread中执行completionHandler block。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AFNetworking/">AFNetworking</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-using-afnetworking-part-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/05/using-afnetworking-part-1/" class="article-date">
  	<time datetime="2015-04-04T18:04:16.000Z" itemprop="datePublished">2015-04-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/using-afnetworking-part-1/">AFNetworking使用笔记 第一弹</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h2><p>归根到底，使用AFNetworking的最终目的无非是处理网络任务，网络任务包括三类：</p>
<ul>
<li>download task</li>
<li>upload task</li>
<li>data task</li>
</ul>
<p>P.S: 上传、下载都比较容易理解，data task是什么玩意儿？上传、下载一般处理的对象主要是文件，而data task处理的对象是文本数据。譬如登录、修改用户昵称，这类操作就是data task。</p>
<p>忽略开发语言以及框架之类的东东，回想一下，启动一个HTTP任务大概需要哪些过程？答案很简单：构建请求消息 – 发送请求消息。</p>
<p><strong>发送请求消息</strong>相对而言比较死板，这一部分往往由框架在底层实现（当然，这一部分也是最复杂的，因为涉及线程神马的）；但是<strong>构建请求消息</strong>相较而言就比较灵活了。</p>
<p>「请求消息」的结构是固定的，包括三个部分：请求行、消息头、消息体。（更多内容参考<a href="/http/">HTTP学习笔记</a>）。</p>
<p>所以无论是什么HTTP任务，万变不离其宗，无非是针对请求行、消息头、消息体进行不同设置和构建。只是在<code>NSURLSession</code>框架里，Apple站在功能的角度做了更进一步的封装，它将request message根据功能封装成download task、upload task、data task。</p>
<p>这3种task分别对应三个类：<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>，它们都是<code>NSURLSessionTask</code>的子类，继承关系如下：</p>
<div class="imagediv" style="width:612px; height:294px"></div>

<p>关于这3种task，《<a href="https://objccn.io/issue-5-4/" target="_blank" rel="external">从NSURLConnection到NSURLSession</a>》有比较清晰的描述：</p>
<blockquote>
<p>当一个<code>NSURLSessionDataTask</code>完成时，它会带有相关联的数据，而一个<code>NSURLSessionDownloadTask</code>任务结束时，它会带回已下载文件的一个临时的文件路径。因为一般来说，服务端对于一个上传任务的响应也会有相关数据返回，所以<code>NSURLSessionUploadTask</code>继承自<code>NSURLSessionDataTask</code>。</p>
</blockquote>
<p>所以，在<code>NSURLSession</code>框架下，启动一个HTTP任务的过程变成了：</p>
<ol>
<li>创建一个<code>NSURLSession</code>实例，并配置之；</li>
<li>创建一个<code>NSURLSessionTask</code>实例，并将之关联到<code>NSURLSession</code>实例中；</li>
<li>激活<code>NSURLSessionTask</code>实例；</li>
</ol>
<p>P.S: 对于单客户单-单服务器，<code>NSURLSession</code>创建一次即可；激活<code>NSURLSessionTask</code>调用其<code>resume</code>方法即可。</p>
<p>所以，在<code>AFHTTPSessionManager</code>中，创建各种HTTP任务流程（参考<a href="https://github.com/AFNetworking/AFNetworking/" target="_blank" rel="external">github:AFNetworking</a>）如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="comment">// 这里没有指定request的方法名，我猜是使用默认方法POST</span></div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask =</div><div class="line">[manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</div><div class="line">    <span class="built_in">NSURL</span> *aDirectoryURL =</div><div class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span></div><div class="line">                                           inDomain:<span class="built_in">NSUserDomainMask</span></div><div class="line">                                  appropriateForURL:<span class="literal">nil</span></div><div class="line">                                             create:<span class="literal">NO</span></div><div class="line">                                              error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [aDirectoryURL URLByAppendingPathComponent:response.suggestedFilename];</div><div class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure>
<p>这段代码中的<code>NSURLRequest</code>对象的创建全部采用默认值，猜测其默认method是POST，在实际应用中，会对<code>NSURLRequest</code>做更多的配置；再就是download task的创建显然不止一种，根据我的理解，基于<code>NSURLSessionDataTask</code>，GET请求消息、POST请求消息都可以完成download task，只是自己要写更多的代码，譬如将download结果从response中取出来。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// data task</span></div><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line">    </div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/upload"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="comment">// 这里没有指定request的方法名，我猜是使用默认方法POST</span></div><div class="line">    </div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *dataTask =</div><div class="line">[manager dataTaskWithRequest:request</div><div class="line">           completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">               <span class="keyword">if</span> (error) &#123;</div><div class="line">                   <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">               &#125;</div><div class="line">&#125;];</div><div class="line">[dataTask resume];</div></pre></td></tr></table></figure>
<p>实际应用中，处理data task时，不会直接像这样写代码，更多的时候会直接使用<code>AFHTTPSessionManager</code>中定义的POST、GET等方法，虽然这些方法的实现和这段代码类似…</p>
<p>Data task和download task相对来说比较简单一些，但upload task就复杂多了。根据复杂程度来看，upload task可以分为<strong>单文件上传</strong>和<strong>多文件上传</strong>。对于前者，相较而言比较简单，直接把要上传的文件作为POST请求消息的消息体即可。对于多文件上传，就复杂得多了。</p>
<p>P.S: 多文件上传并不是很复杂，只要熟读了HTTP相关文档，了解了<code>multipart/form-data</code>相关概念之后，实现多文件上传代码也是挺容易的，关于<code>multipart/form-data</code>，<a href="/http/">HTTP学习笔记</a>有介绍。</p>
<p>先说单文件上传，单文件上传根据文件来源构建<code>NSURLSessionUploadTask</code>对象的方式有这么几种：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 单文件（file路径）上传，进度信息，completion handler</span></div><div class="line">uploadTaskWithRequest:fromFile:progress:completionHandler:</div><div class="line"><span class="comment">// 2. 单文件（file data）上传，进度信息，completion handler</span></div><div class="line">uploadTaskWithRequest:fromData:progress:completionHandler:</div></pre></td></tr></table></figure>
<p>具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单文件（file路径）上传</span></div><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/upload"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *filePath = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.png"</span>];</div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask =</div><div class="line">[manager uploadTaskWithRequest:request</div><div class="line">                      fromFile:filePath</div><div class="line">                      progress:<span class="literal">nil</span></div><div class="line">             completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                 <span class="keyword">if</span> (error) &#123;</div><div class="line">                     <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">                 &#125; <span class="keyword">else</span> &#123;</div><div class="line">                     <span class="built_in">NSLog</span>(<span class="string">@"Success: %@ %@"</span>, response, responseObject);</div><div class="line">                 &#125;</div><div class="line">             &#125;];</div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<p>多文件上传时，需要自行写更多代码构建消息体，具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableURLRequest</span> *request =</div><div class="line">[[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:<span class="string">@"POST"</span></div><div class="line">                                                           URLString:<span class="string">@"http://example.com/upload"</span></div><div class="line">                                                          parameters:<span class="literal">nil</span></div><div class="line">                                           constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;</div><div class="line">                                               [formData appendPartWithFileURL:[<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.jpg"</span>]</div><div class="line">                                                                          name:<span class="string">@"file"</span></div><div class="line">                                                                      fileName:<span class="string">@"filename.jpg"</span></div><div class="line">                                                                      mimeType:<span class="string">@"image/jpeg"</span> error:<span class="literal">nil</span>];</div><div class="line">                                           &#125;</div><div class="line">                                                               error:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">AFURLSessionManager *manager =</div><div class="line">[[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</div><div class="line"><span class="built_in">NSProgress</span> *progress = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask =</div><div class="line">[manager uploadTaskWithStreamedRequest:request</div><div class="line">                              progress:&amp;progress</div><div class="line">                     completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                         <span class="keyword">if</span> (error) &#123;</div><div class="line">                             <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">                         &#125; <span class="keyword">else</span> &#123;</div><div class="line">                             <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">                         &#125;</div><div class="line">                     &#125;];</div><div class="line">    </div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<p>当然，多文件上传代码也可用来实现单文件上传。</p>
<p>本文站在应用的角度对AFNetworking使用进行了简单的描述。但对<code>NSURLSession</code>的阐述不够，希望以后补充吧。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ol>
<li><a href="https://objccn.io/issue-5-4/" target="_blank" rel="external">从NSURLConnection到NSURLSession</a>，这篇文章的作者是Mattt Thompson，也就是AFNetworking的作者</li>
<li><a href="https://github.com/AFNetworking/AFNetworking/" target="_blank" rel="external">AFNetworking使用文档</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AFNetworking/">AFNetworking</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-http" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/04/http/" class="article-date">
  	<time datetime="2015-04-04T07:57:35.000Z" itemprop="datePublished">2015-04-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/04/http/">HTTP学习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>对于程序员而言，HTTP协议是一个非常熟悉的名词。每个人或多或少都对此有所了解。知道它是Web设计、客户端开发等的基础协议。通过它可以让服务器和客户端进行XML、JSON甚至是二进制数据的传输。笔者近期在对之前的程序（iOS项目）的梳理过程中，发现对HTTP协议的了解程度还远远谈不上熟悉，更多的时候是能够凭借网络资源找到某种问题的解决方案，譬如图片的上传与下载，多个文件的上传与下载等等之类的。但是很难从原理层面对这些或有用或无用的信息进行甄别，更谈不上完全独立针对某个网络问题进行合理的程序设计。于是，决定对HTTP相关知识进行一次梳理。</p>
<p>本文的内容只是站在自身的角度，将那些不是特别明白但是可能会经常涉及的知识点进行整理。关于HTTP的更多内容还得看<a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="external">RFC2616文档</a>。</p>
<p>说明：本文会经常出现「客户端」「服务器」「发送端」「接收端」这些概念；就本文而言，「服务端」指的是管理HTTP资源的端点，「客户端」指的是请求HTTP资源的端点；而「发送端」和「接收端」是相对的，譬如客户端发送一个GET请求到服务器，则针对这条消息，客户端是发送端，服务器是接收端；然后服务器返回一个消息给客户端，针对这条响应消息，服务器是发送端，客户端是接收端。</p>
<h2 id="HTTP协议须知"><a href="#HTTP协议须知" class="headerlink" title="HTTP协议须知"></a>HTTP协议须知</h2><p>HTTP，即所谓的超文本传输协议，全称叫<strong>HyperText Transfer Protocol</strong>，是一个客户端和服务端请求和应答的标准（TCP）：</p>
<ul>
<li>HTTP是应用层的协议</li>
<li>HTTP协议是建立在TCP协议之上的协议，后者是传输层的协议</li>
</ul>
<h2 id="HTTP消息概述"><a href="#HTTP消息概述" class="headerlink" title="HTTP消息概述"></a>HTTP消息概述</h2><p>HTTP消息，顾名思义，指的是遵循HTTP协议，客户端和服务端的交流语言（笔者的一家之言，注意，在HTTP协议中，客户端和服务端是相对的，称<strong>请求端</strong>和<strong>应答端</strong>或许更好）。</p>
<p>从方向或应答角度来看，HTTP消息有两种：<strong>请求消息（Request）</strong>、<strong>响应消息（Response）</strong>；</p>
<p>HTTP协议定义了HTTP消息的格式，请求消息和响应消息都由1个开始行（start-line）、0个或多个消息头（headers）、可有可无的消息主体（message-body）组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">generic-message =</div><div class="line">    start-line                 ; 开始行</div><div class="line">    *(message-header CRLF)     ; 消息头</div><div class="line">    CRLF</div><div class="line">    [message-body]             ; 消息主体</div><div class="line">    </div><div class="line">;  其中CRLF表示“结束符”</div><div class="line">;  *表示“0个或多个“”</div><div class="line">;  []表示“可有可无”</div></pre></td></tr></table></figure>
<p>下面将围绕<strong>开始行</strong>、<strong>消息头</strong>、<strong>消息主体</strong>这几个概念进行详细阐述。</p>
<h3 id="开始行"><a href="#开始行" class="headerlink" title="开始行"></a>开始行</h3><p>首先是<strong>开始行</strong>，开始行是什么样的格式？这可不一定，因为对于不同的消息类型（请求消息和响应消息），开始行的格式是不同的：</p>
<ul>
<li>对于请求消息，<strong>start-line</strong>是Request-Line（请求行），请求行的格式后文会介绍；</li>
<li>对于响应消息，<strong>start-line</strong>是Status-Line（状态行），状态行的格式后文会介绍；</li>
</ul>
<h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>然后是<strong>消息头</strong>，根据作用域来分，消息头分为：常用头（general-header）、请求头（request-header）、响应头（response-header）、实体头（entity-header）。无论如何，它们的格式总是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">message-header = field-name &quot;:&quot; [field-value]</div></pre></td></tr></table></figure>
<p>其中<code>field-name</code>对大小写不敏感。</p>
<h3 id="消息主体"><a href="#消息主体" class="headerlink" title="消息主体"></a>消息主体</h3><p>接着是<strong>消息主体</strong>，RFC2616中讲：</p>
<blockquote>
<p>The message-body (if any) of an HTTP message is used to carry the entity-body associated with the request or response.</p>
</blockquote>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">message-body = entity-body | &lt;entity-body encoded as per Transfer-Encoding&gt;</div></pre></td></tr></table></figure>
<p>这是什么意思呢？</p>
<p>HTTP协议中有两个概念非常容易混淆，消息主体（message-body）和实体主体（entity-body）：</p>
<ul>
<li>entity-body可以被理解为客户端想让服务端看到的内容</li>
<li>message-body指的是服务端接收到的（来自于客户端）实际内容</li>
</ul>
<p>二者的区别在于传输过程中可能会对entity-body进行编码；</p>
<p>并非任何<strong>请求消息</strong>或者<strong>响应消息</strong>都可以有<strong>消息主体</strong>这一部分内容。<strong>消息主体</strong>可否存在于某个消息中由<strong>请求类型</strong>和<strong>响应类型</strong>决定的。</p>
<p>P.S: 或许其他资料没有「请求类型」「响应类型」这种说法，不同的<strong>请求类型</strong>在本文的意思是指不同方法的请求，譬如我们熟悉的GET请求、POST请求等；同样，不同的<strong>响应类型</strong>指不同状态码的请求，譬如404响应、403响应、200响应等；</p>
<p><strong>Note:</strong> 对于请求消息，某些情况是不允许包含消息主体的，譬如HEAD请求；对于服务端而言，在处理不允许包含消息主体的请求消息时，应该忽略不理会这些消息的消息主体，哪怕这些消息包含了消息主体。但对于某些允许包含消息主体的请求消息，也可以不包含消息主体，譬如对于POST请求消息，本身是被允许包含消息主体的，但真正发送请求消息时，也可以不包含任何的消息主体。</p>
<p>那么问题来了，服务器如何识别某个可能包含消息主体的请求消息是否真的包含消息主体呢？</p>
<p>根据RFC2616的描述，服务器可以通过两个message-header来判别某个请求消息中是否包含请求主体，这两个message-header分别是Content-Length和Transfer-Encoding，前者记录entity-body的长度，后者记录对entity-body的编码标准。</p>
<p>更细化来看，客户端或者服务器的处理逻辑消息主体的逻辑如下：</p>
<ol>
<li>对于不能包含消息主体的消息（譬如HEAD请求消息、1xx响应消息），完全忽略消息主体，当它不存在；</li>
<li>如果消息中出现「Transfer-Encoding」头，并且其值不是「identity」时：then the transfer-length is defined by use of the “chunked” transfer-coding (section 3.6), unless the message is terminated by closing the connection.<br>P.S: 不太理解这一句，但感觉的意思是，如果所接收到的消息中包含「Transfer-Encoding」头且其值不是「identity」，则计算所接收到消息主体并处理之；</li>
<li>如果消息中出现「Content-Length」头，则认为所接收到的消息主体的长度为Content-Length的值，并且该值也是entity-body的值（即认为entity-body没有进行特别的传输编码）；<br>P.S: 如果entity-body进行了特别的传输编码，千万不要定义「Content-Length」这个header，因为这会让服务器造成误解；<br>P.S: 如果消息中同时包含「Transfer-Encoding」头和「Content-Length」头，则后者会被忽略不处理；</li>
<li>If the message uses the media type “multipart/byteranges”, and the transfer-length is not otherwise specified, then this self-delimiting media type defines the transfer-length. This media type MUST NOT be used unless the sender knows that the recipient can parse it; the presence in a request of a Range header with multiple byte-range specifiers from a 1.1 client implies that the client can parse multipart/byteranges responses<br>P.S: 看不懂！</li>
</ol>
<h2 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h2><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>正如前文所述，对于请求消息，<strong>开始行</strong>被称为<strong>请求行</strong>，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Request-Line = Method SP Request-URL SP HTTP-Version CRLF</div><div class="line">;  </div><div class="line">;  SP表示“分隔符”</div><div class="line">;  CRLF表示“结束符”</div></pre></td></tr></table></figure>
<p>其中，Method包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Method = &quot;OPTIONS&quot;</div><div class="line">         | &quot;GET&quot;</div><div class="line">         | &quot;HEAD&quot;</div><div class="line">         | &quot;POST&quot;</div><div class="line">         | &quot;PUT&quot;</div><div class="line">         | &quot;DELETE&quot;</div><div class="line">         | &quot;TRACE&quot;</div><div class="line">         | &quot;CONNECT&quot;</div><div class="line">         | extension-method</div></pre></td></tr></table></figure></p>
<p>关于Method这部分内容，相对比较熟悉，直接摘抄RFC2616：</p>
<blockquote>
<p>The list of methods allowed by a resource can be specified in an Allow header field (section 14.7). The return code of the response always notifies the client whether a method is currently allowed on a resource, since the set of allowed methods can change dynamically.<br>&nbsp;<br>An origin server SHOULD return the status code 405 (Method Not Allowed) if the method is known by the origin server but not allowed for the requested resource, and 501 (Not Implemented) if the method is unrecognized or not implemented by the origin server.<br>&nbsp;<br>The methods GET and HEAD MUST be supported by all general-purpose servers. All other methods are OPTIONAL;</p>
</blockquote>
<h2 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h2><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>正如前文所述，对于响应消息，<strong>开始行</strong>被称为<strong>状态行</strong>，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</div><div class="line">;  </div><div class="line">;  SP表示“分隔符”</div><div class="line">;  CRLF表示“结束符”</div><div class="line">;  Status-Code表示“状态码”，譬如经典的404</div><div class="line">;  Reason-Phrase表示“状态码的简单文字描述”</div></pre></td></tr></table></figure>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码都是三位数，第一位数（最高位）定义响应类别，第一位有5种值：</p>
<ul>
<li>1xx: Informational - Request received, continuing process</li>
<li>2xx: Success - The action was successfully received, understood, and accepted</li>
<li>3xx: Redirection - Further action must be taken in order to complete the request</li>
<li>4xx: Client Error - The request contains bad syntax or cannot be fulfilled</li>
<li>5xx: Server Error - The server failed to fulfill an apparently valid request</li>
</ul>
<h2 id="实体（entity）"><a href="#实体（entity）" class="headerlink" title="实体（entity）"></a>实体（entity）</h2><p>如果不被请求方法和响应状态码限制，<strong>请求消息</strong>和<strong>响应消息</strong>都可以传输entity。实体包括<strong>实体头</strong>（entity-header）和<strong>实体主体</strong>（entity-body），有些响应只包括实体头（譬如针对HEAD请求的响应）。</p>
<h3 id="实体类型"><a href="#实体类型" class="headerlink" title="实体类型"></a>实体类型</h3><p>实体可能是一个文件，也可能是一段文本，所以必然有一个重要的<strong>属性</strong>用来描述<strong>实体类型</strong>，这个<strong>属性</strong>是<strong>实体头</strong>Content-Type，实体类型比较繁多，譬如.png文件对应的实体类型是<code>image/png</code>，更多Content-Type参考<a href="http://tool.oschina.net/commons" target="_blank" rel="external">这里</a>。</p>
<h2 id="POST、GET、HEAD等方法"><a href="#POST、GET、HEAD等方法" class="headerlink" title="POST、GET、HEAD等方法"></a>POST、GET、HEAD等方法</h2><p>RFC2616对请求消息的方法进行了分类：<strong>安全方法</strong>（Safe Methods）和<strong>幂等方法</strong>（Idempotent Mehtods）。</p>
<p>要理解<strong>安全方法</strong>，先介绍一个概念：副作用，<strong>副作用</strong>指当你发送完一个请求以后，网站上的资源状态没有发生修改，即认为这个请求是无副作用的。比如注册用户这个请求是有副作用的，获取用户详情可以认为是无副作用的。</p>
<p>对于<strong>幂等方法</strong>，<strong>幂等</strong>是说一个请求原封不动的发送N次和M次（N不等于M，N和M都大于1）服务器上资源的状态最终是一致的。比如发贴是非幂等的，重放10次发贴请求会创建10个帖子。但修改帖子内容是幂等的，一个修改请求重放无论多少次，帖子最终状态都是一致的。</p>
<p><strong>请求消息</strong>的方法众多，有些的方法只是读取服务器的资源，有的方法可能会修改服务器的资源。GET和HEAD属于前者，它们只是获取资源，这些方法被称为<strong>安全方法</strong>；POST、PUT、DELETE属于后者，它们可能使服务器的资源发生变化，这些方法被称为<strong>幂等方法</strong>。</p>
<p>P.S: 根据我的理解，所谓的<strong>安全方法</strong>和<strong>幂等方法</strong>只是一种臆想，不是绝对的。举个例子，服务器有某篇文章，现在浏览器通过GET方法获取这篇文章，当然，客户端并没有修改这篇文章，但是，服务器可能做了这样的处理：将这篇文章的浏览次数+1；客观来讲，这个GET方法还是修改了服务器的资源；所以，知道<strong>安全方法</strong>和<strong>幂等方法</strong>这两个概念就好，不必当真。</p>
<h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><p>GET方法的意思是获取被请求URI（Request-URI）指定的信息（以实体的格式）。如果请求URI 涉及到一个数据生成过程，那么这个过程生成的数据应该被作为实体在响应中返回而不是过程的源文本，除非源文本恰好是过程的输出。</p>
<p>如果请求消息包含If-Modified-Since、If-Unmodified-Since、If-Match、If-None-Match或者If-Range头，GET的语义将变成<strong>条件（conditionall）GET</strong>。一个条件GET方法会请求满足条件头域的实体。条件GET方法的目的是为了减少不必要的网络使用，这通过允许利用缓存里仍然保鲜的实体而不用多次请求或传输客户端已经拥有的实体来实现的。</p>
<p>如果请求方法包含一个Range头域，那么GET方法就变成“部分Get”（partial GET）方法。 一个部分GET会请求实体的一部分。部分GET方法的目的是为了减少不必要的网络使用，可以允许客户端从服务器获取实体的部分数据，而不需要获取客户端本地已经拥有的部分实体数据。</p>
<p>P.S: 关键词 – <strong>条件GET</strong>和<strong>部分GET</strong>。</p>
<h3 id="HEAD方法"><a href="#HEAD方法" class="headerlink" title="HEAD方法"></a>HEAD方法</h3><p>除了服务器不能在响应里返回消息主体，HEAD方法和GET方法基本一致。HEAD请求的「响应消息」里的「消息头」应该和GET请求的「响应消息」里的「消息头」一致。此方法被用来获取请求实体的元信息而不需要传输实体主体（entity-body）。此方法经常被用来测试超文本链接的有效性、可访问性以及最近的改变等，对于涉及下载的服务，HEAD方法还用来获取「欲下载文件的大小」。</p>
<h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><p>在实际应用中，GET和POST是用得最多的。相对于GET方法，POST方法在Request-URI所标识的资源后附加新的数据，而GET方法直接将数据放在URI中；此外，POST还可以携带「消息主体」，而GET不成。</p>
<p>简而言之：</p>
<ul>
<li>GET：安全方法，幂等方法，不可包含消息主体</li>
<li>POST：非安全方法」，非幂等方法，可包含消息主体</li>
</ul>
<p>P.S: 更正（2015-08-15），貌似「GET方法不可包含消息主体」的说法不靠谱！</p>
<h3 id="PUT方法"><a href="#PUT方法" class="headerlink" title="PUT方法"></a>PUT方法</h3><p>PUT方法请求服务器去把请求里的实体存储在请求URI（Request-URI）标识下。如果请求 URI（Request-URI）指定的的资源已经在源服务器上存在，那么此请求里的实体应该被当作是源服务器关于此URI所指定资源实体的最新修改版本。如果请求URI（Request-URI）指定的资源不存在，并且此URI被用户代理定义为一个新资源，那么源服务器就应该根据请求里的实体创建一个此URI所标识下的资源。如果一个新的资源被创建了，源服务器必须能向用户代理（user agent）发送201（已创建）响应。如果已存在的资源被改变了，那么源服务器应该发送200（Ok）或者204（无内容）响应。如果资源不能根据请求URI创建或者改变，一个合适的错误响应应该给出以反应问题的性质。实体的接收者不能忽略任何它不理解和不能实现的Content-*（如：Content-Range）头，并且必须返回501（没有被实现）响应。</p>
<p>P.S: 其他方法略过，很少用到。</p>
<div class="imagediv" style="width: 394px; height: 148px"></div>

<h2 id="HTTP和MIME"><a href="#HTTP和MIME" class="headerlink" title="HTTP和MIME"></a>HTTP和MIME</h2><p>最开始HTTP协议是不允许在「消息实体」中挂载二进制文件的，后来逐渐扩展，开始支持MIME协议，这才允许在消息实体中挂载二进制文件，譬如音频、图片等。所以「实体头」Content-Type的很多值MIME-Type中所定义的值。</p>
<h3 id="multipleForm-form-data消息"><a href="#multipleForm-form-data消息" class="headerlink" title="multipleForm/form-data消息"></a>multipleForm/form-data消息</h3><p>经过不断的演化，HTTP协议借鉴并包容了MIME协议，使得HTTP协议能够服务器和客户端之间传输各种文件（文本文件譬如txt文件、二进制文件譬如png文件），具体的处理方式是将这些文件放在<strong>消息主体</strong>中，关于这个上文已有所述。</p>
<p>但是有一个问题：<strong>消息主体中能够承载多个实体（entity）吗</strong>？换句话说，<strong>如果一次HTTP交互涉及多个文件的传输，该如何处理</strong>？</p>
<p>如果只是基于上文所涉及的内容，是没办法做到在一次HTTP消息传输中传输多个文件的。而实现多个文件的传输就得涉及所谓的<code>multipleForm/form-data</code>消息了。</p>
<p>根据HTTP/1.1 RFC2616的协议规定，我们的请求方式只有OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE等，<code>multipart/form-data</code>是个什么东东呢？</p>
<p>对于<code>multipart/form-data</code>，似乎没有找到权威的定义，RFC2616对于它的描述只是出现在<strong>Media Type部分</strong>。根据我的理解，姑且认为<code>multipart/form-data</code>是一种类型的消息主体。</p>
<p>传输<code>multipart/form-data</code>消息主体的基础方法是POST；简单来说，当需要在一次<strong>请求消息</strong>中传输多个文件时，就将着多个文件揉成一个<code>multipart/form-data</code>消息主体，然后以POST形式传到服务器。</p>
<p><code>multipart/form-data</code>消息有啥不同之处呢？</p>
<p>首先是Content-Type不同，其他的HTTP消息的Content-Type可能是<code>image/png</code>、<code>text/plain</code>之类的，但是<code>multipart/form-data</code>消息的Content-Type必须是<code>multipart/form-data</code>。</p>
<p>其次是<code>multipart/form-data</code>的消息主体内嵌了一个或多个其他的消息主体。</p>
<p>举个例子，假设有这么一段HTML代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">FORM</span> <span class="attr">ACTION</span>=<span class="string">"http://server.dom/cgi/handle"</span> <span class="attr">ENCTYPE</span>=<span class="string">"multipart/form-data"</span> <span class="attr">METHOD</span>=<span class="string">POST</span>&gt;</span></div><div class="line">    What is your name? <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">TEXT</span> <span class="attr">NAME</span>=<span class="string">submitter</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">    What files are you sending? <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">FILE</span> <span class="attr">NAME</span>=<span class="string">pics</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></div></pre></td></tr></table></figure>
<p>对应的网页如下：</p>
<div class="imagediv" style="width: 330px; height: 100px"></div>

<p>当用户在姓名输入框中输入「张不坏」，并且选择了一个txt文档file1.txt时，客户端发送的HTTP消息体数据可能如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Content-type: multipart/form-data, boundary=AaB03x</div><div class="line">    </div><div class="line">--AaB03x</div><div class="line">content-disposition: form-data; name=&quot;field1&quot;</div><div class="line">    </div><div class="line">张不坏</div><div class="line">--AaB03x</div><div class="line">content-disposition: form-data; name=&quot;pics&quot;; filename=&quot;file1.txt&quot;</div><div class="line">Content-Type: text/plain</div><div class="line">  ... contents of file1.txt ...</div><div class="line">--AaB03x--</div></pre></td></tr></table></figure>
<p>可以看到，这个示例中涉及两个entity的传输：</p>
<ul>
<li>Content-Type为默认值的文本框输入值</li>
<li>Content-Type为<code>text/plain</code>的纯文本文件</li>
</ul>
<p>P.S: 这里若可以用HTTP协议分析工具分析一下最好了。</p>
<p>关于<code>multipart/form-data</code>消息体，还往往涉及boundary之类的更多概念，本文就不针对这个详述了。</p>
<p>还会经常有一种<code>Content-Type</code>值为<code>multipart/mixed</code>，笔者一度在<code>multipart/form-data</code>和<code>multipart/mixed</code>之间傻傻分不清楚。对于上述示例中“What files are you sending?”之后的文件选择按钮，当选择多个文件时（譬如keynote文件，事实上这个“文件是一个文件包”，它由多个文件组成），则该entity对应的Content-Type是<code>multipart/mixed</code>，表示该form entry对应多个文件，RFC1867的描述如下：</p>
<blockquote>
<p>If multiple files are to be returned as the result of a single form<br>entry, they can be returned as multipart/mixed embedded within the multipart/form-data.</p>
</blockquote>
<p>但无论如何，<code>multipart/mixed</code>消息体都是嵌套在<code>multipart/form-data</code>内部的子消息体。</p>
<p>P.S: <code>multipleForm/form-data</code>消息这一部分内容的叙述不够详细，有时间还是使用HTTP报文分析工具进行更加详细的分析吧。</p>
<h2 id="一些常见问题"><a href="#一些常见问题" class="headerlink" title="一些常见问题"></a>一些常见问题</h2><p>上文是对HTTP协议的基本描述，这一部分列举一些常见Q/A，结合Q/A，会对HTTP协议有更深刻的理解。</p>
<p>Q: POST方法一般将参数放在消息体中，那么其Content-Type是什么？<br>A: 初步判断，一般是<code>application/json</code>。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ol>
<li>HTTP协议RFC2616文档（能够找到中文翻译版，我参考的是“孙超进”翻译版本，感谢他的贡献，但感觉翻译得不是很好）；</li>
<li>RFC2046，MIME协议part2，定义了Media Types；</li>
<li>RFC1867，Form-based File Upload in HTML；</li>
<li>《<a href="http://blog.csdn.net/five3/article/details/7181521" target="_blank" rel="external">HTTP协议之multipart/form-data请求分析</a>》；</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Others/">Others</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-common-code-snipperts-in-ios" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/11/common-code-snipperts-in-ios/" class="article-date">
  	<time datetime="2015-02-11T07:51:12.000Z" itemprop="datePublished">2015-02-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/11/common-code-snipperts-in-ios/">iOS常用代码片段</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在开发过程中，总会有一些简短但使用频率非常高并且不太容易记住的代码，这里总结一下，方便使用。</p>
<h2 id="判断系统版本"><a href="#判断系统版本" class="headerlink" title="判断系统版本"></a>判断系统版本</h2><p>iOS8 之前版本常用方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 变量v是NSString类型</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v) \</span></div><div class="line">([[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] \</div><div class="line">compare:v options:<span class="built_in">NSNumericSearch</span>] != <span class="built_in">NSOrderedAscending</span>)</div></pre></td></tr></table></figure>
<p>记得从某篇博客中了解到iOS8提供了更直接的封装，但忘了方法名了，哎，好记性不如烂笔头啊，以后再补上吧！</p>
<h2 id="根据字体和宽度计算高度"><a href="#根据字体和宽度计算高度" class="headerlink" title="根据字体和宽度计算高度"></a>根据字体和宽度计算高度</h2><p>常用语计算UILabel实例的高度。已知文本内容、字体以及UILabel宽度，计算UILabel的高度。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">CGFloat</span>)computeHeightForText:(<span class="built_in">NSString</span> *)text</div><div class="line">                    havingWidth:(<span class="built_in">CGFloat</span>)widthValue</div><div class="line">                        andFont:(<span class="built_in">UIFont</span> *)font</div><div class="line">&#123;</div><div class="line"><span class="meta">#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v)\</span></div><div class="line">([[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] \</div><div class="line">compare:v options:<span class="built_in">NSNumericSearch</span>] != <span class="built_in">NSOrderedAscending</span>)</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> result = font.pointSize + <span class="number">4</span>;</div><div class="line">    <span class="keyword">if</span> (text) &#123;</div><div class="line">        <span class="built_in">CGSize</span> size;</div><div class="line">        <span class="keyword">if</span> (SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(<span class="string">@"7.0"</span>)) &#123;</div><div class="line">            <span class="comment">//iOS 7</span></div><div class="line">            <span class="built_in">CGRect</span> frame = [text boundingRectWithSize:<span class="built_in">CGSizeMake</span>(widthValue, <span class="built_in">CGFLOAT_MAX</span>)</div><div class="line">                                              options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span></div><div class="line">                                           attributes:@&#123;<span class="built_in">NSFontAttributeName</span>:font&#125;</div><div class="line">                                              context:<span class="literal">nil</span>];</div><div class="line">            size = <span class="built_in">CGSizeMake</span>(frame.size.width, frame.size.height+<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//iOS 6.0</span></div><div class="line">        &#125;</div><div class="line">        result = MAX(size.height, result); <span class="comment">//At least one row</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="收起键盘"><a href="#收起键盘" class="headerlink" title="收起键盘"></a>收起键盘</h2><p>在UIViewController中收起键盘，除了调用相应控件的resignFirstResponder方法外，还有另外三种办法：</p>
<ol>
<li>重载ViewController中的touchBegin方法，然后在里面执行<code>[self.view endEditing:YES];</code>，这样单击UIViewController的任意地方，就可以收起键盘；</li>
<li>直接执行[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil]，用于在获得当前UIViewController比较困难的时候用；</li>
<li>直接执行<code>[[[UIApplication sharedApplication] keyWindow] endEditing:YES];</code>。</li>
</ol>
<h2 id="取消UIButton被按下时的高亮效果"><a href="#取消UIButton被按下时的高亮效果" class="headerlink" title="取消UIButton被按下时的高亮效果"></a>取消UIButton被按下时的高亮效果</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span>.adjustsImageWhenDisabled    = <span class="literal">false</span>;   <span class="comment">// 取消高亮效果</span></div><div class="line"><span class="built_in">UIButton</span>.adjustsImageWhenHighlighted = <span class="literal">false</span>;   <span class="comment">// 取消失能状态的高亮效果</span></div></pre></td></tr></table></figure>
<h2 id="Button图片和title共存"><a href="#Button图片和title共存" class="headerlink" title="Button图片和title共存"></a>Button图片和title共存</h2><p>很多时候我们在UI中需要实现同时具备image和title的button，最常见的场景如下：</p>
<div class="imagediv" style="width: 320px; height: 90px"></div>

<p>这样的效果如何实现呢？很简单，使用UIButton的<code>titleEdgeInsets</code>和<code>imageEdgeInsets</code>属性控制image和title的位置，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> spacingBetweenIconAndTitle = <span class="number">15.</span>f;  <span class="comment">// icon和title的间距</span></div><div class="line">    <span class="built_in">UIButton</span> *button                   = [[<span class="built_in">UIButton</span> alloc] init];</div><div class="line">    <span class="built_in">UIImage</span> *icon                      = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"order_order"</span>];</div><div class="line">    button.titleLabel.font             = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15.</span>f];</div><div class="line">    button.backgroundColor             = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">    [button setImage:icon forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    [button setTitle:<span class="string">@"购物车"</span> forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    [button setTitleEdgeInsets:<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, spacingBetweenIconAndTitle, <span class="number">0</span>, <span class="number">0</span>)];</div><div class="line">    [button setImageEdgeInsets:<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, spacingBetweenIconAndTitle)];</div><div class="line">    [button setTitleColor:[<span class="built_in">UIColor</span> lightGrayColor] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    [button sizeToFit];     <span class="comment">// 匹配最合适的size</span></div><div class="line">    <span class="built_in">CGRect</span> buttonFrame     = button.frame;</div><div class="line">    buttonFrame.size.width += spacingBetweenIconAndTitle;</div><div class="line">    button.frame           = buttonFrame;</div><div class="line">    button.center          = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.view.center.x, <span class="number">50</span>);</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.view addSubview:button];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-nsoperation-vs-gcd" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/07/nsoperation-vs-gcd/" class="article-date">
  	<time datetime="2015-02-07T02:24:41.000Z" itemprop="datePublished">2015-02-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/07/nsoperation-vs-gcd/">NSOperation v.s GCD</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p><del>NSOperation其实是对task的一种Objective-C封装。</del></p>
<p><code>NSOperation</code>是个抽象类，官方文档是这么描述的：</p>
<blockquote>
<p>The NSOperation class itself is an abstract base class that must be subclassed in order to do any useful work.</p>
</blockquote>
<p>值得一提的是，Objective-C中的abstract class和其余语言中的abstract class不太一样，其他语言（主要是静态语言）中的抽象类是不允许进行实例化的，如果对抽象类实例化了，则在编译阶段就可以检查出来；对于Objective-C，对抽象类的说明仅仅停留在文档层面，如果作者想让某个类称为抽象类，则需要在开发文档中进行说明（没有所谓的abstract关键字来修饰），告诉用户不要直接对此类进行实例化，而是去继承它然后自己实现相关方法的定义，但是如果用户实例化该类，则也不会有啥问题（至少在编译阶段是没啥问题）。</p>
<p>如果抽象类的定义只是依靠文档说明，则未免有些太弱了，通常的做法是：You can force a user to at least override certain methods by raising an exception in those methods implementation in your abstract class:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSException</span> raise:<span class="built_in">NSInternalInconsistencyException</span> </div><div class="line">            format:<span class="string">@"You must override %@ in a subclass"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd)];</div></pre></td></tr></table></figure>
<p>当然，也可以使用<code>assert</code>或<code>NSAssert</code>处理。这和Python很多场合对抽象类的处理有些类似，更多讯息参考来自stackoverflow的<a href="http://stackoverflow.com/questions/1034373/creating-an-abstract-class-in-objective-c" target="_blank" rel="external">Creating an abstract class in Objective-C</a>。</p>
<p>Foundation Framework提供了两个比较好用的<code>NSOperation</code>子类，<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>。</p>
<p>就我目前的使用经验来看，还没有遇到直接使用<code>NSOperation</code>的机会，更多的时候使用AFNetworking框架提供的<code>AFHTTPRequestOperation</code>。</p>
<p><strong>执行operation</strong></p>
<p><code>NSOperation</code>对象往往关联一段代码，执行这段代码有两种方式：</p>
<ol>
<li>直接执行其<code>start</code>方法；</li>
<li>将<code>NSOperation</code>对象添加到<code>NSOperationQueue</code>中；</li>
</ol>
<p>P.S: 关于<code>NSOperation</code>的内容还有很多，譬如优先级、completion block之类的，更多信息参考Apple文档<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html" target="_blank" rel="external">Concurrency Programming Guide</a>，写得很详细。</p>
<h2 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h2><p>在阅读<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">Concurrency Programming Guide</a>的过程中，不免和GCD进行对比，非常疑惑的问题是，<code>NSOperation</code>的执行大概是什么样子的？并行？FIFO？在main thread还是other threads？下面就围绕这些问题进行阐述。</p>
<h3 id="创建NSOperationQueue对象"><a href="#创建NSOperationQueue对象" class="headerlink" title="创建NSOperationQueue对象"></a>创建NSOperationQueue对象</h3><p>创建<code>NSOperationQueue</code>有两种方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. NSOperationQueue</span></div><div class="line"><span class="built_in">NSOperationQueue</span> *operationQueue1 = [[<span class="built_in">NSOperationQueue</span> alloc] init];</div><div class="line">    </div><div class="line"><span class="comment">// 2. NSOperationQueue</span></div><div class="line"><span class="built_in">NSOperationQueue</span> *operationQueue2 = [<span class="built_in">NSOperationQueue</span> mainQueue];</div></pre></td></tr></table></figure>
<p>先说<code>mainQueue</code>，it returns the operation queue associated with the main thread，简而言之，<code>mainQueue</code>上的operation（或曰task）都是在main thread上完成的，进一步来说，<code>mainQueue</code>中的operation都有控制UI的能力；对于第一种方式<code>[NSOperationQueue alloc]</code>，则不然，其关联的thread与main thread或许无关。</p>
<p>所以也可以看出来：<strong>operation的执行thread由其所在的NSOperationQueue决定</strong>。</p>
<p>值得一提的是，同一个<code>NSOperationQueue</code>的不同operation的执行线程并非同一个，因为<code>NSOperationQueue</code>可能同时涉及多个线程。</p>
<p>并且这和GCD不同，GCD中，dispatch_queue中的block的执行线程不单由queue决定，还与block的派发方式有关。</p>
<p><code>NSOperationQueue</code>对象不存在所谓的<code>start</code>之类的启动方法，根据我的理解，自它被创建了就开始工作了。</p>
<p>P.S: 目前还没有到有用到<code>[NSOperationQueue mainQueue]</code>的应用，很想知道在哪些场合会用到…</p>
<h3 id="NSOperationQueue的工作方式"><a href="#NSOperationQueue的工作方式" class="headerlink" title="NSOperationQueue的工作方式"></a>NSOperationQueue的工作方式</h3><p>根据<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">Concurrency Programming Guide</a>上介绍，获悉：</p>
<ol>
<li><code>NSOperationQueue</code>是不支持FIFO的，因为<code>NSOperation</code>存在priority的概念，所以<code>NSOperationQueue</code>是不支持FIFO的；</li>
<li><code>NSOperationQueue</code>上的operation是并发执行的，但是用户可以配置同一时刻最多可以并发的operation数量，对应属性是<code>maxConcurrentOperationCount</code>，也就是说，如果<code>maxConcurrentOperationCount</code>的值设置为1，则<code>NSOperationQueue</code>中的operation是串行执行的（串行顺序依然受priority和就绪状态决定，不遵循FIFO）；</li>
</ol>
<h3 id="NSOperation的completion-block"><a href="#NSOperation的completion-block" class="headerlink" title="NSOperation的completion block"></a>NSOperation的completion block</h3><p>考虑到接触的频率非常之高，有必要对<code>NSOperation</code>的completion block做更多的了解。</p>
<blockquote>
<p>In OS X v10.6 and later, an operation can execute a completion block when its main task finishes executing. You can use a completion block to perform any work that you do not consider part of the main task. For example, you might use this block to notify interested clients that the operation itself has completed. A concurrent operation object might use this block to generate its final KVO notifications.<br>To set a completion block, use the setCompletionBlock: method of NSOperation. The block you pass to this method should have no arguments and no return value.</p>
</blockquote>
<p>考虑这么一个应用场景，使用<code>NSOperation</code>服务下载一张图片，在completion block中更新相关<code>UIImageView</code>，图片下载图片后，就会调用completion block。</p>
<p>结合这个应用场景，刚开始，对<code>NSOperation</code>的completion block比较疑惑的地方在于，completion block哪一个线程执行，在main thread，还是和<code>NSOperation</code>所在线程是同一个？前者的可能性不高；如果是后者，考虑到只有main thread上代码才有控制UI的资格，那么<code>NSOperation</code>必须得在main thread上执行，即其所在operation queue的创建方式是<code>oq = [NSOperationQueue mainQueue];</code>，但是download image代码难免会产生阻塞，必然会影响UI的交互，显然是不可取。</p>
<p>将<code>NSOperation</code>和其completion block割裂来看的做法显然是愚蠢的，也就是说，执行<code>NSOperation</code>的completion block的线程和执行<code>NSOperation</code>的线程是一样的，也都是由其所在的<code>NSOperationQueue</code>决定的。</p>
<p>带着这个问题，我查看了AFNetworking的处理代码，它的做法是这样的，执行网络任务的<code>NSOperation</code>所在的<code>NSOperation</code>所关联的thread都不是main thread，为了在下载图片（也可能是其他数据）后更新UI，其调用completion block的方式并不是直接调用，而是使用<code>dispatch_group_async</code>函数将用户指定的completion block添加到main thread。<br>简单来说，在用户的completion block基础上加了一层，确保用户的completion block在main thread上执行，认识到这一点很重要！</p>
<p>P.S: AFNetworking的网络任务的CompletionBlock都是在main thread中完成的，这从<code>AFHTTPRequestOperation</code>的<code>setCompletionBlockWithSuccess:fuilure:</code>方法定义可以看出来。</p>
<h2 id="NSOperation-v-s-GCD"><a href="#NSOperation-v-s-GCD" class="headerlink" title="NSOperation v.s GCD"></a>NSOperation v.s GCD</h2><p>关于<code>NSOperation</code>（以及<code>NSOperationQueue</code>）和GCD的关系，引用《Effective-C 2.0》的描述：</p>
<blockquote>
<p>The similarity to GCD’s dispatch queues is not a coincidence. Operation queues came before GCD, but there is no doublt that GCD is based on the principles made popular by operation queues. In fact, from iOS 4 and Mac OS X 10.6 onward, operation queues use GCD under hood.</p>
</blockquote>
<p>GCD的同步机制无与伦比，但有些时候使用<code>NSOperation</code>或许是更好的选择，相较于GCD，<code>NSOperation</code>有如下这些优势：</p>
<ol>
<li><p>取消操作（任务）<br>在GCD中，是没办法对添加到queue的task进行cancel操作的，但是<code>NSOperation</code>是可以的；值得一提的是，<code>NSOperation</code>取消操作只适用于哪些还没被执行的operation，如果operation正在running，则cancel操作是无效的。</p>
</li>
<li><p>Operation dependencies<br>An operation can have dependencies on as many other operations as it wishes. This enables you to create a hierarchy of operations dictating that certain operations can execute only after another operation has completed successfully. For example, you may have operations to download and process files from a server that requires a manifest file to be downloaded first before others can be processed. The operation to download the manifest file first could be a dependency of the subsequent download operations. If the operation queue were set to allow concurrent execution, the subsequent downloads could execute in parallel but only after the dependent operation had completed.</p>
</li>
<li><p>KVO<br>对<code>NSOperation</code>，还可以对其某些属性进行KVO处理，这对于基于C-API的GCD是没办法做到的，至于<code>NSOperation</code>哪些属性支持KVO，还需要参考<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">Concurrency Programming Guide</a>。</p>
</li>
<li><p>优先级控制<br>GCD的dispatch queue中的任务的执行顺序全部遵循FIFO，但是<code>NSOperationQueue</code>中对operation的调用更复杂一些，因为它每个operation都有优先级，所以用户可以通过优先级控制实现对任务更复杂的管理。</p>
</li>
<li><p>Reuse of operations<br>因为<code>NSOperation</code>是完全支持面向对象的类，所以其对reuse的支持也是相对于GCD的一大优势。</p>
</li>
</ol>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="http://www.raywenderlich.com/19788/how-to-use-nsoperations-and-nsoperationqueues" target="_blank" rel="external">How To Use NSOperations and NSOperationQueues</a>；</li>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">Concurrency Programming Guide</a></li>
<li><a href="https://book.douban.com/subject/21370593/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD/">GCD</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/13/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>