<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/11/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.43px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 14.29px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 17.14px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.43px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 20px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 12.86px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 15.71px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.43px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 14.29px;">Tools</a> <a href="/tags/Transition/" style="font-size: 12.86px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 11.43px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js基础/" style="font-size: 18.57px;">js基础</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，Android开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-basics-in-objective-c" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/12/basics-in-objective-c/" class="article-date">
  	<time datetime="2015-04-12T14:27:32.000Z" itemprop="datePublished">2015-04-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/12/basics-in-objective-c/">Objective-C基础知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文属于汇总文，对Objective-C语言层面的一些基础问题进行汇总，有的问题可直接在本文找到答案，有的知识提供其他博文的链接。</p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>「内联函数」是一个很老的概念，在其他语言譬如C++语言中也出现了。所谓「内联函数」指的是：有函数的结构，但不具备函数的性质，类似于宏替换功能的代码块。</p>
<p>在实际应用中，常常把规模较小、逻辑较简单的操作定义成内联函数，定义内联函数只要在函数前面加上<code>inline</code>关键字修饰即可；站在编译器的角度，处理内联函数就是在每个它的调用点上「内联地」展开。假设有定义如下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="built_in">NSString</span> * getNavigationTitleWithCount(<span class="keyword">int</span> cnt) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"已选中%d项"</span>, (<span class="keyword">int</span>)cnt];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>则编译器对如下代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UILabel</span> *label = [<span class="built_in">UILabel</span> new];</div><div class="line">label.text = getNavigationTitleWithCount(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>的处理，如同对如下代码代码的处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UILabel</span> *label = [<span class="built_in">UILabel</span> new];</div><div class="line">label.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"已选中%d项"</span>, (<span class="keyword">int</span>)<span class="number">0</span>];</div></pre></td></tr></table></figure>
<p>一句话说明：<strong>程序在调用内联函数时的开销和调用宏的开销是一样的，但内联函数显然比宏要强大一些，至少它保证了类型安全</strong>；相较于普通函数，调用内联函数没有「保护现场、push栈、pop栈等等」之类的开销。</p>
<p>内联函数的好处显而易见，但并不是所有函数都可以形成真正的内联函数。如上所述，定义一个内联函数只要在定义时加上<code>inline</code>关键字即可，但能否形成真正的内联函数，还要看编译器对内联函数体内部定义的具体处理。</p>
<p>一般来说，内联函数定义的代码量逻辑简单、代码量小，并且属于那种频繁使用的代码块；<strong>内联函数不能使用循环语句，不能使用递归调用</strong>；</p>
<h2 id="const的使用"><a href="#const的使用" class="headerlink" title="const的使用"></a>const的使用</h2><p>在Objective-C代码中，经常需要定义一些常量指针，譬如AFNetworking中有如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityDidChangeNotification;</div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityNotificationStatusItem;</div></pre></td></tr></table></figure>
<p>和其他语言一样，定义常量的关键字是<code>const</code>，但问题是常常不知道<code>const</code>该往哪里放，<code>NSString * const XXOO</code>还是<code>NSString const * XXOO</code>？</p>
<p>其实，在Objective-C中还好一点，C/C++中<code>const</code>的各种使用姿势更难懂，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * label1       = <span class="string">""</span>;</div><div class="line"><span class="keyword">char</span> <span class="keyword">const</span> * label2       = <span class="string">""</span>;</div><div class="line"><span class="keyword">char</span> * <span class="keyword">const</span> label3       = <span class="string">""</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> label4 = <span class="string">""</span>;</div></pre></td></tr></table></figure>
<p>经常傻傻分不清楚。不过还好，脑子恰好还残留着一些本科老师讲过的内容，记得本科C语言老师教过一种简单的记忆方法：const总是修饰其左边的东东，如果其左边没有东东，则修饰右边的东东。</p>
<p>如何理解呢？对于<code>char const * label2</code>而言，const的左边是char，所以const修饰的是char本身，即内容本身，所以表示“label1指向的内容是常量，不可变”；对于<code>const char * label1</code>而言，const左边没有东东，所以它修饰右边的东东，即char，所以表示“label2指向的内容是常量，不可变”；对于<code>char * const label3</code>，const左边的东东是*，所以修饰的是指针，即表示“label3指针本身是常量，不可变”，所以解释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * label1       = <span class="string">""</span>;      <span class="comment">// 内容是常量，不可变</span></div><div class="line"><span class="keyword">char</span> <span class="keyword">const</span> * label2       = <span class="string">""</span>;      <span class="comment">// 内容是常量，不可变</span></div><div class="line"><span class="keyword">char</span> * <span class="keyword">const</span> label3       = <span class="string">""</span>;      <span class="comment">// 指针是常量，不可变</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> label4 = <span class="string">""</span>;      <span class="comment">// 指针和内容都是常量，不可变</span></div></pre></td></tr></table></figure>
<p>这个判断方法同样适用于Objective-C，所以如下代码是没问题的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// const的左边是NSString，修饰的是NSString对象，表示“NSString对象本身不可修改”（但指针可以）</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> <span class="keyword">const</span> * testString = <span class="string">@"I am an iOS developer"</span>;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    testString = <span class="string">@"我是一个iOS开发者"</span>; <span class="comment">// 合法</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, testString);   <span class="comment">// print "我是一个iOS开发者"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但如下代码不合法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// const的左边是*，修饰的是指针本身，表示testString地址值不可修改</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> testString = <span class="string">@"I am an iOS developer"</span>;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    testString = <span class="string">@"我是一个iOS开发者"</span>; <span class="comment">// 非法</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, testString);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="mm文件"><a href="#mm文件" class="headerlink" title=".mm文件"></a>.mm文件</h2><ul>
<li>.m文件是Objective-C文件</li>
<li>.mm文件相当于C++或者C文件</li>
</ul>
<h2 id="Extension和Category"><a href="#Extension和Category" class="headerlink" title="Extension和Category"></a>Extension和Category</h2><p>参考：<a href="http://blog.csdn.net/leikezhu1981/article/details/19091049" target="_blank" rel="external">http://blog.csdn.net/leikezhu1981/article/details/19091049</a></p>
<h2 id="Compiler-Directives"><a href="#Compiler-Directives" class="headerlink" title="Compiler Directives"></a>Compiler Directives</h2><p><a href="http://nshipster.com/at-compiler-directives/" target="_blank" rel="external">http://nshipster.com/at-compiler-directives/</a></p>
<p><a href="http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/</a></p>
<h2 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h2><p>详细内容参考《<a href="http://nshipster.cn/pragma/" target="_blank" rel="external">NSHipster – #pragma</a>》和《<a href="/pragma/">预处理指令#pragma</a>》</p>
<h2 id="0-nil-Nil-NULL-NSNull"><a href="#0-nil-Nil-NULL-NSNull" class="headerlink" title="0/nil/Nil/NULL/NSNull"></a>0/nil/Nil/NULL/NSNull</h2><p>这一部分内容摘自<a href="http://nshipster.cn/nil/" target="_blank" rel="external">nil/Nil/NULL/NSNull</a>，原文详见<a href="http://nshipster.com/nil/" target="_blank" rel="external">这里</a>。</p>
<p>理解「不存在」的概念不仅仅是一个哲学的问题，也是一个实际的问题。我们是有形宇宙的居民，而原因在于逻辑宇宙的存在不确定性。作为一个逻辑系统的物理体现，电脑面临一个棘手的问题，就是如何用存在表达「不存在」。</p>
<p>在Objective－C中，有几个不同种类的「不存在」。C语言用<code>0</code>来作为不存在的原始值，而<code>NULL</code>作为指针（这在指针环境中相当于<code>0</code>）。</p>
<p>Objective-C在C的基础上增加了<code>nil</code>。<code>nil</code>是一个指向不存在的对象指针，虽然它在语义上与<code>NULL</code>不同，但它们在技术上是相等的。</p>
<p>在框架层面，Foundation定义了<code>NSNull</code>，<code>NSNull</code>中有一个类方法<code>+null</code>，它返回一个单独的<code>NSNull</code>对象。NSNull与nil以及NULL不同，因为它是一个实际的对象，而不是一个零值。</p>
<p>另外，在<a href="https://gist.github.com/4469665" target="_blank" rel="external">Foundation/NSObjCRuntime.h</a>中，<code>Nil</code>被定义为指向零的类指针，可以把它看做是<code>nil</code>的表亲。虽然它鲜为人知，但至少值得注意一下。</p>
<p>总的来说，这里的四个表达没有的值是每个Objective-C程序员都应该知道的：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th style="text-align:center">值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NULL</td>
<td style="text-align:center">(void *)0</td>
<td style="text-align:center">C指针的字面零值</td>
</tr>
<tr>
<td style="text-align:center">nil</td>
<td style="text-align:center">(id)0</td>
<td style="text-align:center">Objective-C对象的字面零值</td>
</tr>
<tr>
<td style="text-align:center">Nil</td>
<td style="text-align:center">(Class)0</td>
<td style="text-align:center">Objective-C类的字面零值</td>
</tr>
<tr>
<td style="text-align:center">NSNull</td>
<td style="text-align:center">[NSNull null]</td>
<td style="text-align:center">用来表示零值的单独的对象</td>
</tr>
</tbody>
</table>
<h2 id="关于nil的一些事儿"><a href="#关于nil的一些事儿" class="headerlink" title="关于nil的一些事儿"></a>关于nil的一些事儿</h2><p>刚被分配的NSObject的内容被设置为0。也就是说那个对象所有的指向其他对象的指针都从<code>nil</code>开始，所以在<code>init</code>方法中设置<code>self.(association) = nil</code>之类的表达是没有必要的。</p>
<p>当然，也许nil最显著的行为是，它虽然为零，仍然可以有消息发送给它。在其他的语言中，比如C++，这样做会使你的程序崩溃，<strong>但在Objective-C中，在<code>nil</code>上调用方法返回一个零值</strong>。这大大的简化了表达，因为它避免了在使用<code>nil</code>之前对它的检查。</p>
<h2 id="isEqual-和"><a href="#isEqual-和" class="headerlink" title="isEqual:和=="></a>isEqual:和==</h2><p>参考<a href="http://nshipster.com/equality/。" target="_blank" rel="external">http://nshipster.com/equality/。</a></p>
<h2 id="基本数据类型长度"><a href="#基本数据类型长度" class="headerlink" title="基本数据类型长度"></a>基本数据类型长度</h2><table>
<thead>
<tr>
<th style="text-align:center">名字</th>
<th style="text-align:center">typedef（32bit/64bit）</th>
<th style="text-align:center">长度（32bit/64bit）（单位：bit）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">-</td>
<td style="text-align:center">32/32</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">-</td>
<td style="text-align:center">32/64</td>
</tr>
<tr>
<td style="text-align:center">long long</td>
<td style="text-align:center">-</td>
<td style="text-align:center">64/64</td>
</tr>
<tr>
<td style="text-align:center">NSInteger</td>
<td style="text-align:center">int/long</td>
<td style="text-align:center">32/64</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">-</td>
<td style="text-align:center">32/32</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">-</td>
<td style="text-align:center">64/64</td>
</tr>
<tr>
<td style="text-align:center">long double</td>
<td style="text-align:center">-</td>
<td style="text-align:center">128/128</td>
</tr>
<tr>
<td style="text-align:center">CGFloat</td>
<td style="text-align:center">float/double</td>
<td style="text-align:center">32/64</td>
</tr>
</tbody>
</table>
<p>对于<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>，在不同的平台下（32位和64位）下唯一有区别的是<code>long</code>，其余三个在不同硬件平台所占据数据长度是一致的；至于<code>NSInteger</code>和<code>NSFloat</code>，数据长度和平台完全对应，由此可见，基于Cocoa编程尽可能使用<code>NSInteger</code>和<code>NSFloat</code>，而不直接使用<code>int</code>、<code>float</code>等。</p>
<p>P.S：与<code>NSInteger</code>和<code>int</code>对应的是<code>NSUInteger</code>和<code>unsigned int</code>，但是不存在所谓的<code>unsigned float</code>和<code>CGUFloat</code>哦！</p>
<p><code>int</code>和<code>long</code>的最大值和最小值比较容易计算，<code>float</code>和<code>double</code>的最大值和最小值计算则麻烦多了，IEEE-754协议对此专门做了定义，详见<a href="http://baike.baidu.com/view/1698149.htm" target="_blank" rel="external">百度百科：IEEE-754</a>和<a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" rel="external">wiki: IEEE floating point</a></p>
<h2 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h2><p><strong>#import v.s #include</strong></p>
<p><code>#import</code>和<code>#include</code>的作用类似：都是先要求<strong>预处理器</strong>读取某个文件（一般是头文件），然后将读入的内容添加至输出到对应的位置；或者简单来说，二者都用作<strong>导入文件</strong>。前者确保<strong>预处理器</strong>对指定的文件只导入一次，后者则允许多次导入同一个文件。</p>
<p><strong>尖括号 v.s 双引号</strong></p>
<p>如果使用尖括号（<code>&lt;&gt;</code>），则编译器会先在预先设定好的标准目录下查找相应的文件（譬如系统头文件）；如果使用双引号（<code>&quot;&quot;</code>），则编译器会先在项目目录下查找相应的头文件。</p>
<p><strong>#import v.s @import</strong></p>
<p>如下内容摘自《<a href="http://www.cnblogs.com/sammyCoding/p/3654743.html" target="_blank" rel="external">在ios 7下，使用@import代替#import</a>》：</p>
<blockquote>
<p>在xcode 5 下，为了更易于开发，增加了modules和 auto-linking 这两个新特性。用 @import 来增加框架 到项目中比用 #import会更有效. 我们来看看为什么：</p>
<blockquote>
<p>Modules for system frameworks speed build time and provide an alternate means to import APIs from the SDK instead of using the C preprocessor. Modules provide many of the build-time improvements of precompiled headers with less maintenance or need for optimization. They are designed for easy adoption with little or no source changes. Beyond build-time improvements, modules provide a cleaner API model that enables many great features in the tools, such as Auto Linking.</p>
</blockquote>
<p>Modules and auto-linking 默认情况下是enabled的。 如果是旧的项目，你可以通过设置”Language - Modules.” 来设置Enable Modules 和Link Frameworks Automatically 为Yes。<br>另外一个使用moudules的好处是你再也不用去链接你的framework到你的项目了。<br>例如，在以前，如果你要使用MapKit这个框架，你要这样做<br>1) 使用语句 #import <mapkit mapkit.h=""> 导入框架<br>2) 去到项目的build phases 设置项，找到MapKit.framework.并加入到Link Binary With Libraries里面。<br>如果使用modules的话，只需要加入语句 “@import MapKit;” 你就可以开始使用了,根本不需要链接到你的项目。</mapkit></p>
</blockquote>
<p>更多内容参考《<a href="http://stackoverflow.com/questions/18947516/import-vs-import-ios-7" target="_blank" rel="external">stackoverflow: @import vs #import - iOS 7</a>》。</p>
<h2 id="弱引用的自动置零特性"><a href="#弱引用的自动置零特性" class="headerlink" title="弱引用的自动置零特性"></a>弱引用的自动置零特性</h2><p>当某个由弱引用指向的对象被释放时，相应的指针变量会被<strong>归零</strong>（zerod），即赋为<code>nil</code>。</p>
<h2 id="多态、动态类型和动态绑定"><a href="#多态、动态类型和动态绑定" class="headerlink" title="多态、动态类型和动态绑定"></a>多态、动态类型和动态绑定</h2><p><strong>什么是多态</strong></p>
<p>一句话解释：不同对象对同一个消息的不同响应。</p>
<p><strong>什么是动态绑定</strong></p>
<p>「动态绑定」是指在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>
<p><strong>动态类型id</strong></p>
<p><code>id</code>数据类型是一种通用的对象类型。也就是说，它可以用来存储任何对象。在代码中可以向id类型发送任何消息，Objective-C系统（编译器）不会在编译期对之进行类型检验，只有运行到相关代码时才会判断所引用对象的实际类型，然后根据实际的类型调用其相应的方法。</p>
<p>举个例子说明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">id</span> number = @<span class="number">5</span>;</div><div class="line">    <span class="keyword">if</span> ([number isEqualToString:<span class="string">@"whatTheFuck"</span>]) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"见鬼了"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，首先创建一个NSNumber类型实例，并把它赋给<code>id</code>类型变量number；在if语句中，向number发送<code>isEqualToString:</code>消息，根据我们对NSNumber的了解，它是没有定义<code>isEqualToString:</code>方法的，因此不会对这个消息进行响应。然而，这段代码完全可以以「0 error、0 warning」通过编译，只是在运行时会抛出NSInvalidArgumentException异常：<br>reason: ‘-[__NSCFNumber isEqualToString:]: unrecognized selector sent to instance 0x7bf67200’</p>
<p>这个示例形象阐述「动态绑定」的含义，并且验证了「id类型可以用来存储任何对象」的说法。</p>
<p><strong>Objective-C如何实现多态的</strong></p>
<p>根据上述对「多态」、「动态绑定」以及「动态类型id」的解释，可以直接回答：Objective-C实现多态的方式是动态绑定。</p>
<p>P.S：也有人认为「继承体系中方法重载也是实现多态的一种方式」，笔者对此比较疑惑，因为我总觉得「动态绑定」已将此包括进去了。</p>
<h2 id="synthesize-v-s-dynamic"><a href="#synthesize-v-s-dynamic" class="headerlink" title="@synthesize v.s @dynamic"></a>@synthesize v.s @dynamic</h2><p>引用<a href="http://stackoverflow.com/questions/1160498/synthesize-vs-dynamic-what-are-the-differences" target="_blank" rel="external">stackoverflow: @synthesize vs @dynamic, what are the differences?</a>：</p>
<blockquote>
<p>@synthesize will generate getter and setter methods for your property. @dynamic just tells the compiler that the getter and setter methods are implemented not by the class itself but somewhere else (like the superclass or will be provided at runtime).</p>
</blockquote>
<p>简单来说，<code>@synthesize</code>的作用是：指示编译器，让其在编译期间自动生成getter/setter方法；当有自定义的setter或getter实现时，自定义setter或getter会屏蔽自动生成的setter或getter。不晓得从什么时候开始，Xcode默认帮助合成属性，无需显式使用<code>@synthesize</code>指令。</p>
<p>P.S：根据我的理解，准确来说，<code>@synthesize</code>的作用还包括「自动合成property对应的实例变量」，当然，如果已然有对应的实例变量存在，则会略过。比如说property名为foo，存在一个名为_foo的实例变量，那么就不会再自动合成新变量了。总之，<code>@synthesize</code>是一个帮助省功夫的指令。</p>
<p>P.S：不晓得为什么，当对某个属性同时自定义setter和getter时，XCode要求必须显式书写<code>@synthesize</code>，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UserInfo</span> : <span class="title">NSObject</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div><div class="line">    </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UserInfo</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@synthesize</span> name = _name;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    _name = [name <span class="keyword">copy</span>];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="keyword">return</span> _name;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>而<code>@dynamic</code>告诉编译器，不在编译期自动生成getter/setter方法，setter和getter会在runtime提供。<code>@dynamic</code>的主要应用场景是Core Data，除此之外，在category使用关联属性时也会用到。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-using-afnetworking-part-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/05/using-afnetworking-part-2/" class="article-date">
  	<time datetime="2015-04-04T18:04:32.000Z" itemprop="datePublished">2015-04-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/using-afnetworking-part-2/">AFNetworking使用笔记 第二弹</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>接着<a href="/using-afnetworking-part-1/">AFNetworking使用笔记 第一弹</a>继续写。本文分析两个问题：</p>
<ul>
<li>AFNetworking网络任务的创建是在哪个线程执行的？</li>
<li>网络任务的completion handler在哪一个线程被调用？</li>
</ul>
<h2 id="发送请求消息"><a href="#发送请求消息" class="headerlink" title="发送请求消息"></a>发送请求消息</h2><p>这一部分内容的着重点在于回答「AFNetworking网络任务的创建是在哪个线程执行的？」这个问题。其实这个问题也可以这样问「AFNetworking网络任务的创建是在main thread中完成的吗？」。</p>
<p>开始分析，以<code>AFHTTPSessionManager</code>的POST方法为例，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                    parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                       success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> responseObject))success</div><div class="line">                       failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error))failure</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"POST"</span></div><div class="line">                                                        URLString:URLString</div><div class="line">                                                       parameters:parameters</div><div class="line">                                                          success:success</div><div class="line">                                                          failure:failure];</div><div class="line">    </div><div class="line">    [dataTask resume];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其所作的事情很简单，创建一个<code>NSURLSessionDataTask</code>实例，并将它激活（resume），然后返回它。</p>
<p>进入<code>NSURLSessionDataTask</code>实例创建过程，最终进入如下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                            completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response,</div><div class="line">                                                        <span class="keyword">id</span> responseObject,</div><div class="line">                                                        <span class="built_in">NSError</span> *error))completionHandler</div><div class="line">&#123;</div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), ^&#123;</div><div class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask completionHandler:completionHandler];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然<code>url_session_manager_creation_queue()</code>是关键：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_creation_queue() &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_creation_queue;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        af_url_session_manager_creation_queue =</div><div class="line">        dispatch_queue_create(<span class="string">"com.alamofire.networking.session.manager.creation"</span>,</div><div class="line">                              DISPATCH_QUEUE_SERIAL);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> af_url_session_manager_creation_queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在应该可以得出答案了：</p>
<ul>
<li>根据上述的<code>dataTaskWithRequest:completionHandler:</code>里的代码段<code>dispatch_sync(...)</code>可以知道，创建网络任务的过程是同步完成的；</li>
<li>根据<code>url_session_manager_creation_queue()</code>的实现代码可以知道，创建网络任务的过程是并不是在main thread中完成的；</li>
</ul>
<p>这里分析的是基于POST请求消息的data task，其他task也是差不多，总之，我们可以得出结论，网络任务的创建并不是在main thread中进行的。</p>
<h2 id="处理响应消息"><a href="#处理响应消息" class="headerlink" title="处理响应消息"></a>处理响应消息</h2><p>这一部分内容的着重点在于回答「网络任务的completion handler在哪一个线程被调用？」。</p>
<p>依旧以POST请求消息的响应为例，<code>dataTaskWithHTTPMethod:URLString:parameters:success:failure:</code>方法代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                      parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                                         success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="keyword">id</span>))success</div><div class="line">                                         failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="built_in">NSError</span> *))failure</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *request =</div><div class="line">        [<span class="keyword">self</span>.requestSerializer requestWithMethod:method</div><div class="line">                                    URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString</div><div class="line">                                                      relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString]</div><div class="line">                                   parameters:parameters</div><div class="line">                                        error:&amp;serializationError];</div><div class="line">    <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">        <span class="keyword">if</span> (failure) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(<span class="literal">nil</span>, serializationError);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</div><div class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response,</div><div class="line">                                           <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            <span class="keyword">if</span> (failure) &#123;</div><div class="line">                failure(dataTask, error);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (success) &#123;</div><div class="line">                success(dataTask, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有上述代码可以看到，当构造请求消息失败时，会异步在main thread中调用completionHandler block。</p>
<p>当接收到响应消息时，相应的处理在<code>AFURLSessionManager</code>类的<br><code>URLSession:task:didCompleteWithError:</code>方法中完成，该方法代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</div><div class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</div><div class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</div><div class="line">                <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:[<span class="built_in">NSData</span> dataWithData:<span class="keyword">self</span>.mutableData] error:&amp;serializationError];</div><div class="line">    </div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</div><div class="line">                responseObject = <span class="keyword">self</span>.downloadFileURL;</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            <span class="keyword">if</span> (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</div><div class="line">                    <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</div><div class="line">                &#125;</div><div class="line">    </div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中出现了<code>url_session_manager_processing_queue()</code>方法，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_processing_queue() &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_processing_queue;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        af_url_session_manager_processing_queue = dispatch_queue_create(<span class="string">"com.alamofire.networking.session.manager.processing"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> af_url_session_manager_processing_queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这段代码可以看到，当response出现错误时，AFNetworking会在main thread异步调用completionHandler block；若response没有错误时，就会在异步并行队列中对response进行处理，处理完之后，再在main thread中调用completionHandler block。</p>
<p>总之，请求消息的构建工作是以同步形式在非main thread中进行的；对response的处理是以异步形式在非main thread中处理的；无论是哪个步骤的处理失败和成功，都会在main thread中执行completionHandler block。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AFNetworking/">AFNetworking</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-using-afnetworking-part-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/05/using-afnetworking-part-1/" class="article-date">
  	<time datetime="2015-04-04T18:04:16.000Z" itemprop="datePublished">2015-04-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/using-afnetworking-part-1/">AFNetworking使用笔记 第一弹</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h2><p>归根到底，使用AFNetworking的最终目的无非是处理网络任务，网络任务包括三类：</p>
<ul>
<li>download task</li>
<li>upload task</li>
<li>data task</li>
</ul>
<p>P.S: 上传、下载都比较容易理解，data task是什么玩意儿？上传、下载一般处理的对象主要是文件，而data task处理的对象是文本数据。譬如登录、修改用户昵称，这类操作就是data task。</p>
<p>忽略开发语言以及框架之类的东东，回想一下，启动一个HTTP任务大概需要哪些过程？答案很简单：构建请求消息 – 发送请求消息。</p>
<p><strong>发送请求消息</strong>相对而言比较死板，这一部分往往由框架在底层实现（当然，这一部分也是最复杂的，因为涉及线程神马的）；但是<strong>构建请求消息</strong>相较而言就比较灵活了。</p>
<p>「请求消息」的结构是固定的，包括三个部分：请求行、消息头、消息体。（更多内容参考<a href="/http/">HTTP学习笔记</a>）。</p>
<p>所以无论是什么HTTP任务，万变不离其宗，无非是针对请求行、消息头、消息体进行不同设置和构建。只是在<code>NSURLSession</code>框架里，Apple站在功能的角度做了更进一步的封装，它将request message根据功能封装成download task、upload task、data task。</p>
<p>这3种task分别对应三个类：<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>，它们都是<code>NSURLSessionTask</code>的子类，继承关系如下：</p>
<div class="imagediv" style="width:612px; height:294px"></div>

<p>关于这3种task，《<a href="https://objccn.io/issue-5-4/" target="_blank" rel="external">从NSURLConnection到NSURLSession</a>》有比较清晰的描述：</p>
<blockquote>
<p>当一个<code>NSURLSessionDataTask</code>完成时，它会带有相关联的数据，而一个<code>NSURLSessionDownloadTask</code>任务结束时，它会带回已下载文件的一个临时的文件路径。因为一般来说，服务端对于一个上传任务的响应也会有相关数据返回，所以<code>NSURLSessionUploadTask</code>继承自<code>NSURLSessionDataTask</code>。</p>
</blockquote>
<p>所以，在<code>NSURLSession</code>框架下，启动一个HTTP任务的过程变成了：</p>
<ol>
<li>创建一个<code>NSURLSession</code>实例，并配置之；</li>
<li>创建一个<code>NSURLSessionTask</code>实例，并将之关联到<code>NSURLSession</code>实例中；</li>
<li>激活<code>NSURLSessionTask</code>实例；</li>
</ol>
<p>P.S: 对于单客户单-单服务器，<code>NSURLSession</code>创建一次即可；激活<code>NSURLSessionTask</code>调用其<code>resume</code>方法即可。</p>
<p>所以，在<code>AFHTTPSessionManager</code>中，创建各种HTTP任务流程（参考<a href="https://github.com/AFNetworking/AFNetworking/" target="_blank" rel="external">github:AFNetworking</a>）如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="comment">// 这里没有指定request的方法名，我猜是使用默认方法POST</span></div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask =</div><div class="line">[manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</div><div class="line">    <span class="built_in">NSURL</span> *aDirectoryURL =</div><div class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span></div><div class="line">                                           inDomain:<span class="built_in">NSUserDomainMask</span></div><div class="line">                                  appropriateForURL:<span class="literal">nil</span></div><div class="line">                                             create:<span class="literal">NO</span></div><div class="line">                                              error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [aDirectoryURL URLByAppendingPathComponent:response.suggestedFilename];</div><div class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure>
<p>这段代码中的<code>NSURLRequest</code>对象的创建全部采用默认值，猜测其默认method是POST，在实际应用中，会对<code>NSURLRequest</code>做更多的配置；再就是download task的创建显然不止一种，根据我的理解，基于<code>NSURLSessionDataTask</code>，GET请求消息、POST请求消息都可以完成download task，只是自己要写更多的代码，譬如将download结果从response中取出来。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// data task</span></div><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line">    </div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/upload"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="comment">// 这里没有指定request的方法名，我猜是使用默认方法POST</span></div><div class="line">    </div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *dataTask =</div><div class="line">[manager dataTaskWithRequest:request</div><div class="line">           completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">               <span class="keyword">if</span> (error) &#123;</div><div class="line">                   <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">               &#125;</div><div class="line">&#125;];</div><div class="line">[dataTask resume];</div></pre></td></tr></table></figure>
<p>实际应用中，处理data task时，不会直接像这样写代码，更多的时候会直接使用<code>AFHTTPSessionManager</code>中定义的POST、GET等方法，虽然这些方法的实现和这段代码类似…</p>
<p>Data task和download task相对来说比较简单一些，但upload task就复杂多了。根据复杂程度来看，upload task可以分为<strong>单文件上传</strong>和<strong>多文件上传</strong>。对于前者，相较而言比较简单，直接把要上传的文件作为POST请求消息的消息体即可。对于多文件上传，就复杂得多了。</p>
<p>P.S: 多文件上传并不是很复杂，只要熟读了HTTP相关文档，了解了<code>multipart/form-data</code>相关概念之后，实现多文件上传代码也是挺容易的，关于<code>multipart/form-data</code>，<a href="/http/">HTTP学习笔记</a>有介绍。</p>
<p>先说单文件上传，单文件上传根据文件来源构建<code>NSURLSessionUploadTask</code>对象的方式有这么几种：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 单文件（file路径）上传，进度信息，completion handler</span></div><div class="line">uploadTaskWithRequest:fromFile:progress:completionHandler:</div><div class="line"><span class="comment">// 2. 单文件（file data）上传，进度信息，completion handler</span></div><div class="line">uploadTaskWithRequest:fromData:progress:completionHandler:</div></pre></td></tr></table></figure>
<p>具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单文件（file路径）上传</span></div><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/upload"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *filePath = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.png"</span>];</div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask =</div><div class="line">[manager uploadTaskWithRequest:request</div><div class="line">                      fromFile:filePath</div><div class="line">                      progress:<span class="literal">nil</span></div><div class="line">             completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                 <span class="keyword">if</span> (error) &#123;</div><div class="line">                     <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">                 &#125; <span class="keyword">else</span> &#123;</div><div class="line">                     <span class="built_in">NSLog</span>(<span class="string">@"Success: %@ %@"</span>, response, responseObject);</div><div class="line">                 &#125;</div><div class="line">             &#125;];</div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<p>多文件上传时，需要自行写更多代码构建消息体，具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableURLRequest</span> *request =</div><div class="line">[[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:<span class="string">@"POST"</span></div><div class="line">                                                           URLString:<span class="string">@"http://example.com/upload"</span></div><div class="line">                                                          parameters:<span class="literal">nil</span></div><div class="line">                                           constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;</div><div class="line">                                               [formData appendPartWithFileURL:[<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.jpg"</span>]</div><div class="line">                                                                          name:<span class="string">@"file"</span></div><div class="line">                                                                      fileName:<span class="string">@"filename.jpg"</span></div><div class="line">                                                                      mimeType:<span class="string">@"image/jpeg"</span> error:<span class="literal">nil</span>];</div><div class="line">                                           &#125;</div><div class="line">                                                               error:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">AFURLSessionManager *manager =</div><div class="line">[[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</div><div class="line"><span class="built_in">NSProgress</span> *progress = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask =</div><div class="line">[manager uploadTaskWithStreamedRequest:request</div><div class="line">                              progress:&amp;progress</div><div class="line">                     completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                         <span class="keyword">if</span> (error) &#123;</div><div class="line">                             <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">                         &#125; <span class="keyword">else</span> &#123;</div><div class="line">                             <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">                         &#125;</div><div class="line">                     &#125;];</div><div class="line">    </div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<p>当然，多文件上传代码也可用来实现单文件上传。</p>
<p>本文站在应用的角度对AFNetworking使用进行了简单的描述。但对<code>NSURLSession</code>的阐述不够，希望以后补充吧。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ol>
<li><a href="https://objccn.io/issue-5-4/" target="_blank" rel="external">从NSURLConnection到NSURLSession</a>，这篇文章的作者是Mattt Thompson，也就是AFNetworking的作者</li>
<li><a href="https://github.com/AFNetworking/AFNetworking/" target="_blank" rel="external">AFNetworking使用文档</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AFNetworking/">AFNetworking</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-http" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/04/http/" class="article-date">
  	<time datetime="2015-04-04T07:57:35.000Z" itemprop="datePublished">2015-04-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/04/http/">HTTP学习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>对于程序员而言，HTTP协议是一个非常熟悉的名词。每个人或多或少都对此有所了解。知道它是Web设计、客户端开发等的基础协议。通过它可以让服务器和客户端进行XML、JSON甚至是二进制数据的传输。笔者近期在对之前的程序（iOS项目）的梳理过程中，发现对HTTP协议的了解程度还远远谈不上熟悉，更多的时候是能够凭借网络资源找到某种问题的解决方案，譬如图片的上传与下载，多个文件的上传与下载等等之类的。但是很难从原理层面对这些或有用或无用的信息进行甄别，更谈不上完全独立针对某个网络问题进行合理的程序设计。于是，决定对HTTP相关知识进行一次梳理。</p>
<p>本文的内容只是站在自身的角度，将那些不是特别明白但是可能会经常涉及的知识点进行整理。关于HTTP的更多内容还得看<a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="external">RFC2616文档</a>。</p>
<p>说明：本文会经常出现「客户端」「服务器」「发送端」「接收端」这些概念；就本文而言，「服务端」指的是管理HTTP资源的端点，「客户端」指的是请求HTTP资源的端点；而「发送端」和「接收端」是相对的，譬如客户端发送一个GET请求到服务器，则针对这条消息，客户端是发送端，服务器是接收端；然后服务器返回一个消息给客户端，针对这条响应消息，服务器是发送端，客户端是接收端。</p>
<h2 id="HTTP协议须知"><a href="#HTTP协议须知" class="headerlink" title="HTTP协议须知"></a>HTTP协议须知</h2><p>HTTP，即所谓的超文本传输协议，全称叫<strong>HyperText Transfer Protocol</strong>，是一个客户端和服务端请求和应答的标准（TCP）：</p>
<ul>
<li>HTTP是应用层的协议</li>
<li>HTTP协议是建立在TCP协议之上的协议，后者是传输层的协议</li>
</ul>
<h2 id="HTTP消息概述"><a href="#HTTP消息概述" class="headerlink" title="HTTP消息概述"></a>HTTP消息概述</h2><p>HTTP消息，顾名思义，指的是遵循HTTP协议，客户端和服务端的交流语言（笔者的一家之言，注意，在HTTP协议中，客户端和服务端是相对的，称<strong>请求端</strong>和<strong>应答端</strong>或许更好）。</p>
<p>从方向或应答角度来看，HTTP消息有两种：<strong>请求消息（Request）</strong>、<strong>响应消息（Response）</strong>；</p>
<p>HTTP协议定义了HTTP消息的格式，请求消息和响应消息都由1个开始行（start-line）、0个或多个消息头（headers）、可有可无的消息主体（message-body）组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">generic-message =</div><div class="line">    start-line                 ; 开始行</div><div class="line">    *(message-header CRLF)     ; 消息头</div><div class="line">    CRLF</div><div class="line">    [message-body]             ; 消息主体</div><div class="line">    </div><div class="line">;  其中CRLF表示“结束符”</div><div class="line">;  *表示“0个或多个“”</div><div class="line">;  []表示“可有可无”</div></pre></td></tr></table></figure>
<p>下面将围绕<strong>开始行</strong>、<strong>消息头</strong>、<strong>消息主体</strong>这几个概念进行详细阐述。</p>
<h3 id="开始行"><a href="#开始行" class="headerlink" title="开始行"></a>开始行</h3><p>首先是<strong>开始行</strong>，开始行是什么样的格式？这可不一定，因为对于不同的消息类型（请求消息和响应消息），开始行的格式是不同的：</p>
<ul>
<li>对于请求消息，<strong>start-line</strong>是Request-Line（请求行），请求行的格式后文会介绍；</li>
<li>对于响应消息，<strong>start-line</strong>是Status-Line（状态行），状态行的格式后文会介绍；</li>
</ul>
<h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>然后是<strong>消息头</strong>，根据作用域来分，消息头分为：常用头（general-header）、请求头（request-header）、响应头（response-header）、实体头（entity-header）。无论如何，它们的格式总是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">message-header = field-name &quot;:&quot; [field-value]</div></pre></td></tr></table></figure>
<p>其中<code>field-name</code>对大小写不敏感。</p>
<h3 id="消息主体"><a href="#消息主体" class="headerlink" title="消息主体"></a>消息主体</h3><p>接着是<strong>消息主体</strong>，RFC2616中讲：</p>
<blockquote>
<p>The message-body (if any) of an HTTP message is used to carry the entity-body associated with the request or response.</p>
</blockquote>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">message-body = entity-body | &lt;entity-body encoded as per Transfer-Encoding&gt;</div></pre></td></tr></table></figure>
<p>这是什么意思呢？</p>
<p>HTTP协议中有两个概念非常容易混淆，消息主体（message-body）和实体主体（entity-body）：</p>
<ul>
<li>entity-body可以被理解为客户端想让服务端看到的内容</li>
<li>message-body指的是服务端接收到的（来自于客户端）实际内容</li>
</ul>
<p>二者的区别在于传输过程中可能会对entity-body进行编码；</p>
<p>并非任何<strong>请求消息</strong>或者<strong>响应消息</strong>都可以有<strong>消息主体</strong>这一部分内容。<strong>消息主体</strong>可否存在于某个消息中由<strong>请求类型</strong>和<strong>响应类型</strong>决定的。</p>
<p>P.S: 或许其他资料没有「请求类型」「响应类型」这种说法，不同的<strong>请求类型</strong>在本文的意思是指不同方法的请求，譬如我们熟悉的GET请求、POST请求等；同样，不同的<strong>响应类型</strong>指不同状态码的请求，譬如404响应、403响应、200响应等；</p>
<p><strong>Note:</strong> 对于请求消息，某些情况是不允许包含消息主体的，譬如HEAD请求；对于服务端而言，在处理不允许包含消息主体的请求消息时，应该忽略不理会这些消息的消息主体，哪怕这些消息包含了消息主体。但对于某些允许包含消息主体的请求消息，也可以不包含消息主体，譬如对于POST请求消息，本身是被允许包含消息主体的，但真正发送请求消息时，也可以不包含任何的消息主体。</p>
<p>那么问题来了，服务器如何识别某个可能包含消息主体的请求消息是否真的包含消息主体呢？</p>
<p>根据RFC2616的描述，服务器可以通过两个message-header来判别某个请求消息中是否包含请求主体，这两个message-header分别是Content-Length和Transfer-Encoding，前者记录entity-body的长度，后者记录对entity-body的编码标准。</p>
<p>更细化来看，客户端或者服务器的处理逻辑消息主体的逻辑如下：</p>
<ol>
<li>对于不能包含消息主体的消息（譬如HEAD请求消息、1xx响应消息），完全忽略消息主体，当它不存在；</li>
<li>如果消息中出现「Transfer-Encoding」头，并且其值不是「identity」时：then the transfer-length is defined by use of the “chunked” transfer-coding (section 3.6), unless the message is terminated by closing the connection.<br>P.S: 不太理解这一句，但感觉的意思是，如果所接收到的消息中包含「Transfer-Encoding」头且其值不是「identity」，则计算所接收到消息主体并处理之；</li>
<li>如果消息中出现「Content-Length」头，则认为所接收到的消息主体的长度为Content-Length的值，并且该值也是entity-body的值（即认为entity-body没有进行特别的传输编码）；<br>P.S: 如果entity-body进行了特别的传输编码，千万不要定义「Content-Length」这个header，因为这会让服务器造成误解；<br>P.S: 如果消息中同时包含「Transfer-Encoding」头和「Content-Length」头，则后者会被忽略不处理；</li>
<li>If the message uses the media type “multipart/byteranges”, and the transfer-length is not otherwise specified, then this self-delimiting media type defines the transfer-length. This media type MUST NOT be used unless the sender knows that the recipient can parse it; the presence in a request of a Range header with multiple byte-range specifiers from a 1.1 client implies that the client can parse multipart/byteranges responses<br>P.S: 看不懂！</li>
</ol>
<h2 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h2><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>正如前文所述，对于请求消息，<strong>开始行</strong>被称为<strong>请求行</strong>，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Request-Line = Method SP Request-URL SP HTTP-Version CRLF</div><div class="line">;  </div><div class="line">;  SP表示“分隔符”</div><div class="line">;  CRLF表示“结束符”</div></pre></td></tr></table></figure>
<p>其中，Method包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Method = &quot;OPTIONS&quot;</div><div class="line">         | &quot;GET&quot;</div><div class="line">         | &quot;HEAD&quot;</div><div class="line">         | &quot;POST&quot;</div><div class="line">         | &quot;PUT&quot;</div><div class="line">         | &quot;DELETE&quot;</div><div class="line">         | &quot;TRACE&quot;</div><div class="line">         | &quot;CONNECT&quot;</div><div class="line">         | extension-method</div></pre></td></tr></table></figure></p>
<p>关于Method这部分内容，相对比较熟悉，直接摘抄RFC2616：</p>
<blockquote>
<p>The list of methods allowed by a resource can be specified in an Allow header field (section 14.7). The return code of the response always notifies the client whether a method is currently allowed on a resource, since the set of allowed methods can change dynamically.<br>&nbsp;<br>An origin server SHOULD return the status code 405 (Method Not Allowed) if the method is known by the origin server but not allowed for the requested resource, and 501 (Not Implemented) if the method is unrecognized or not implemented by the origin server.<br>&nbsp;<br>The methods GET and HEAD MUST be supported by all general-purpose servers. All other methods are OPTIONAL;</p>
</blockquote>
<h2 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h2><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>正如前文所述，对于响应消息，<strong>开始行</strong>被称为<strong>状态行</strong>，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</div><div class="line">;  </div><div class="line">;  SP表示“分隔符”</div><div class="line">;  CRLF表示“结束符”</div><div class="line">;  Status-Code表示“状态码”，譬如经典的404</div><div class="line">;  Reason-Phrase表示“状态码的简单文字描述”</div></pre></td></tr></table></figure>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码都是三位数，第一位数（最高位）定义响应类别，第一位有5种值：</p>
<ul>
<li>1xx: Informational - Request received, continuing process</li>
<li>2xx: Success - The action was successfully received, understood, and accepted</li>
<li>3xx: Redirection - Further action must be taken in order to complete the request</li>
<li>4xx: Client Error - The request contains bad syntax or cannot be fulfilled</li>
<li>5xx: Server Error - The server failed to fulfill an apparently valid request</li>
</ul>
<h2 id="实体（entity）"><a href="#实体（entity）" class="headerlink" title="实体（entity）"></a>实体（entity）</h2><p>如果不被请求方法和响应状态码限制，<strong>请求消息</strong>和<strong>响应消息</strong>都可以传输entity。实体包括<strong>实体头</strong>（entity-header）和<strong>实体主体</strong>（entity-body），有些响应只包括实体头（譬如针对HEAD请求的响应）。</p>
<h3 id="实体类型"><a href="#实体类型" class="headerlink" title="实体类型"></a>实体类型</h3><p>实体可能是一个文件，也可能是一段文本，所以必然有一个重要的<strong>属性</strong>用来描述<strong>实体类型</strong>，这个<strong>属性</strong>是<strong>实体头</strong>Content-Type，实体类型比较繁多，譬如.png文件对应的实体类型是<code>image/png</code>，更多Content-Type参考<a href="http://tool.oschina.net/commons" target="_blank" rel="external">这里</a>。</p>
<h2 id="POST、GET、HEAD等方法"><a href="#POST、GET、HEAD等方法" class="headerlink" title="POST、GET、HEAD等方法"></a>POST、GET、HEAD等方法</h2><p>RFC2616对请求消息的方法进行了分类：<strong>安全方法</strong>（Safe Methods）和<strong>幂等方法</strong>（Idempotent Mehtods）。</p>
<p>要理解<strong>安全方法</strong>，先介绍一个概念：副作用，<strong>副作用</strong>指当你发送完一个请求以后，网站上的资源状态没有发生修改，即认为这个请求是无副作用的。比如注册用户这个请求是有副作用的，获取用户详情可以认为是无副作用的。</p>
<p>对于<strong>幂等方法</strong>，<strong>幂等</strong>是说一个请求原封不动的发送N次和M次（N不等于M，N和M都大于1）服务器上资源的状态最终是一致的。比如发贴是非幂等的，重放10次发贴请求会创建10个帖子。但修改帖子内容是幂等的，一个修改请求重放无论多少次，帖子最终状态都是一致的。</p>
<p><strong>请求消息</strong>的方法众多，有些的方法只是读取服务器的资源，有的方法可能会修改服务器的资源。GET和HEAD属于前者，它们只是获取资源，这些方法被称为<strong>安全方法</strong>；POST、PUT、DELETE属于后者，它们可能使服务器的资源发生变化，这些方法被称为<strong>幂等方法</strong>。</p>
<p>P.S: 根据我的理解，所谓的<strong>安全方法</strong>和<strong>幂等方法</strong>只是一种臆想，不是绝对的。举个例子，服务器有某篇文章，现在浏览器通过GET方法获取这篇文章，当然，客户端并没有修改这篇文章，但是，服务器可能做了这样的处理：将这篇文章的浏览次数+1；客观来讲，这个GET方法还是修改了服务器的资源；所以，知道<strong>安全方法</strong>和<strong>幂等方法</strong>这两个概念就好，不必当真。</p>
<h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><p>GET方法的意思是获取被请求URI（Request-URI）指定的信息（以实体的格式）。如果请求URI 涉及到一个数据生成过程，那么这个过程生成的数据应该被作为实体在响应中返回而不是过程的源文本，除非源文本恰好是过程的输出。</p>
<p>如果请求消息包含If-Modified-Since、If-Unmodified-Since、If-Match、If-None-Match或者If-Range头，GET的语义将变成<strong>条件（conditionall）GET</strong>。一个条件GET方法会请求满足条件头域的实体。条件GET方法的目的是为了减少不必要的网络使用，这通过允许利用缓存里仍然保鲜的实体而不用多次请求或传输客户端已经拥有的实体来实现的。</p>
<p>如果请求方法包含一个Range头域，那么GET方法就变成“部分Get”（partial GET）方法。 一个部分GET会请求实体的一部分。部分GET方法的目的是为了减少不必要的网络使用，可以允许客户端从服务器获取实体的部分数据，而不需要获取客户端本地已经拥有的部分实体数据。</p>
<p>P.S: 关键词 – <strong>条件GET</strong>和<strong>部分GET</strong>。</p>
<h3 id="HEAD方法"><a href="#HEAD方法" class="headerlink" title="HEAD方法"></a>HEAD方法</h3><p>除了服务器不能在响应里返回消息主体，HEAD方法和GET方法基本一致。HEAD请求的「响应消息」里的「消息头」应该和GET请求的「响应消息」里的「消息头」一致。此方法被用来获取请求实体的元信息而不需要传输实体主体（entity-body）。此方法经常被用来测试超文本链接的有效性、可访问性以及最近的改变等，对于涉及下载的服务，HEAD方法还用来获取「欲下载文件的大小」。</p>
<h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><p>在实际应用中，GET和POST是用得最多的。相对于GET方法，POST方法在Request-URI所标识的资源后附加新的数据，而GET方法直接将数据放在URI中；此外，POST还可以携带「消息主体」，而GET不成。</p>
<p>简而言之：</p>
<ul>
<li>GET：安全方法，幂等方法，不可包含消息主体</li>
<li>POST：非安全方法」，非幂等方法，可包含消息主体</li>
</ul>
<p>P.S: 更正（2015-08-15），貌似「GET方法不可包含消息主体」的说法不靠谱！</p>
<h3 id="PUT方法"><a href="#PUT方法" class="headerlink" title="PUT方法"></a>PUT方法</h3><p>PUT方法请求服务器去把请求里的实体存储在请求URI（Request-URI）标识下。如果请求 URI（Request-URI）指定的的资源已经在源服务器上存在，那么此请求里的实体应该被当作是源服务器关于此URI所指定资源实体的最新修改版本。如果请求URI（Request-URI）指定的资源不存在，并且此URI被用户代理定义为一个新资源，那么源服务器就应该根据请求里的实体创建一个此URI所标识下的资源。如果一个新的资源被创建了，源服务器必须能向用户代理（user agent）发送201（已创建）响应。如果已存在的资源被改变了，那么源服务器应该发送200（Ok）或者204（无内容）响应。如果资源不能根据请求URI创建或者改变，一个合适的错误响应应该给出以反应问题的性质。实体的接收者不能忽略任何它不理解和不能实现的Content-*（如：Content-Range）头，并且必须返回501（没有被实现）响应。</p>
<p>P.S: 其他方法略过，很少用到。</p>
<div class="imagediv" style="width: 394px; height: 148px"></div>

<h2 id="HTTP和MIME"><a href="#HTTP和MIME" class="headerlink" title="HTTP和MIME"></a>HTTP和MIME</h2><p>最开始HTTP协议是不允许在「消息实体」中挂载二进制文件的，后来逐渐扩展，开始支持MIME协议，这才允许在消息实体中挂载二进制文件，譬如音频、图片等。所以「实体头」Content-Type的很多值MIME-Type中所定义的值。</p>
<h3 id="multipleForm-form-data消息"><a href="#multipleForm-form-data消息" class="headerlink" title="multipleForm/form-data消息"></a>multipleForm/form-data消息</h3><p>经过不断的演化，HTTP协议借鉴并包容了MIME协议，使得HTTP协议能够服务器和客户端之间传输各种文件（文本文件譬如txt文件、二进制文件譬如png文件），具体的处理方式是将这些文件放在<strong>消息主体</strong>中，关于这个上文已有所述。</p>
<p>但是有一个问题：<strong>消息主体中能够承载多个实体（entity）吗</strong>？换句话说，<strong>如果一次HTTP交互涉及多个文件的传输，该如何处理</strong>？</p>
<p>如果只是基于上文所涉及的内容，是没办法做到在一次HTTP消息传输中传输多个文件的。而实现多个文件的传输就得涉及所谓的<code>multipleForm/form-data</code>消息了。</p>
<p>根据HTTP/1.1 RFC2616的协议规定，我们的请求方式只有OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE等，<code>multipart/form-data</code>是个什么东东呢？</p>
<p>对于<code>multipart/form-data</code>，似乎没有找到权威的定义，RFC2616对于它的描述只是出现在<strong>Media Type部分</strong>。根据我的理解，姑且认为<code>multipart/form-data</code>是一种类型的消息主体。</p>
<p>传输<code>multipart/form-data</code>消息主体的基础方法是POST；简单来说，当需要在一次<strong>请求消息</strong>中传输多个文件时，就将着多个文件揉成一个<code>multipart/form-data</code>消息主体，然后以POST形式传到服务器。</p>
<p><code>multipart/form-data</code>消息有啥不同之处呢？</p>
<p>首先是Content-Type不同，其他的HTTP消息的Content-Type可能是<code>image/png</code>、<code>text/plain</code>之类的，但是<code>multipart/form-data</code>消息的Content-Type必须是<code>multipart/form-data</code>。</p>
<p>其次是<code>multipart/form-data</code>的消息主体内嵌了一个或多个其他的消息主体。</p>
<p>举个例子，假设有这么一段HTML代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">FORM</span> <span class="attr">ACTION</span>=<span class="string">"http://server.dom/cgi/handle"</span> <span class="attr">ENCTYPE</span>=<span class="string">"multipart/form-data"</span> <span class="attr">METHOD</span>=<span class="string">POST</span>&gt;</span></div><div class="line">    What is your name? <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">TEXT</span> <span class="attr">NAME</span>=<span class="string">submitter</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">    What files are you sending? <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">FILE</span> <span class="attr">NAME</span>=<span class="string">pics</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></div></pre></td></tr></table></figure>
<p>对应的网页如下：</p>
<div class="imagediv" style="width: 330px; height: 100px"></div>

<p>当用户在姓名输入框中输入「张不坏」，并且选择了一个txt文档file1.txt时，客户端发送的HTTP消息体数据可能如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Content-type: multipart/form-data, boundary=AaB03x</div><div class="line">    </div><div class="line">--AaB03x</div><div class="line">content-disposition: form-data; name=&quot;field1&quot;</div><div class="line">    </div><div class="line">张不坏</div><div class="line">--AaB03x</div><div class="line">content-disposition: form-data; name=&quot;pics&quot;; filename=&quot;file1.txt&quot;</div><div class="line">Content-Type: text/plain</div><div class="line">  ... contents of file1.txt ...</div><div class="line">--AaB03x--</div></pre></td></tr></table></figure>
<p>可以看到，这个示例中涉及两个entity的传输：</p>
<ul>
<li>Content-Type为默认值的文本框输入值</li>
<li>Content-Type为<code>text/plain</code>的纯文本文件</li>
</ul>
<p>P.S: 这里若可以用HTTP协议分析工具分析一下最好了。</p>
<p>关于<code>multipart/form-data</code>消息体，还往往涉及boundary之类的更多概念，本文就不针对这个详述了。</p>
<p>还会经常有一种<code>Content-Type</code>值为<code>multipart/mixed</code>，笔者一度在<code>multipart/form-data</code>和<code>multipart/mixed</code>之间傻傻分不清楚。对于上述示例中“What files are you sending?”之后的文件选择按钮，当选择多个文件时（譬如keynote文件，事实上这个“文件是一个文件包”，它由多个文件组成），则该entity对应的Content-Type是<code>multipart/mixed</code>，表示该form entry对应多个文件，RFC1867的描述如下：</p>
<blockquote>
<p>If multiple files are to be returned as the result of a single form<br>entry, they can be returned as multipart/mixed embedded within the multipart/form-data.</p>
</blockquote>
<p>但无论如何，<code>multipart/mixed</code>消息体都是嵌套在<code>multipart/form-data</code>内部的子消息体。</p>
<p>P.S: <code>multipleForm/form-data</code>消息这一部分内容的叙述不够详细，有时间还是使用HTTP报文分析工具进行更加详细的分析吧。</p>
<h2 id="一些常见问题"><a href="#一些常见问题" class="headerlink" title="一些常见问题"></a>一些常见问题</h2><p>上文是对HTTP协议的基本描述，这一部分列举一些常见Q/A，结合Q/A，会对HTTP协议有更深刻的理解。</p>
<p>Q: POST方法一般将参数放在消息体中，那么其Content-Type是什么？<br>A: 初步判断，一般是<code>application/json</code>。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ol>
<li>HTTP协议RFC2616文档（能够找到中文翻译版，我参考的是“孙超进”翻译版本，感谢他的贡献，但感觉翻译得不是很好）；</li>
<li>RFC2046，MIME协议part2，定义了Media Types；</li>
<li>RFC1867，Form-based File Upload in HTML；</li>
<li>《<a href="http://blog.csdn.net/five3/article/details/7181521" target="_blank" rel="external">HTTP协议之multipart/form-data请求分析</a>》；</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Others/">Others</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-common-code-snipperts-in-ios" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/11/common-code-snipperts-in-ios/" class="article-date">
  	<time datetime="2015-02-11T07:51:12.000Z" itemprop="datePublished">2015-02-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/11/common-code-snipperts-in-ios/">iOS常用代码片段</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在开发过程中，总会有一些简短但使用频率非常高并且不太容易记住的代码，这里总结一下，方便使用。</p>
<h2 id="判断系统版本"><a href="#判断系统版本" class="headerlink" title="判断系统版本"></a>判断系统版本</h2><p>iOS8 之前版本常用方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 变量v是NSString类型</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v) \</span></div><div class="line">([[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] \</div><div class="line">compare:v options:<span class="built_in">NSNumericSearch</span>] != <span class="built_in">NSOrderedAscending</span>)</div></pre></td></tr></table></figure>
<p>记得从某篇博客中了解到iOS8提供了更直接的封装，但忘了方法名了，哎，好记性不如烂笔头啊，以后再补上吧！</p>
<h2 id="根据字体和宽度计算高度"><a href="#根据字体和宽度计算高度" class="headerlink" title="根据字体和宽度计算高度"></a>根据字体和宽度计算高度</h2><p>常用语计算UILabel实例的高度。已知文本内容、字体以及UILabel宽度，计算UILabel的高度。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">CGFloat</span>)computeHeightForText:(<span class="built_in">NSString</span> *)text</div><div class="line">                    havingWidth:(<span class="built_in">CGFloat</span>)widthValue</div><div class="line">                        andFont:(<span class="built_in">UIFont</span> *)font</div><div class="line">&#123;</div><div class="line"><span class="meta">#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v)\</span></div><div class="line">([[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] \</div><div class="line">compare:v options:<span class="built_in">NSNumericSearch</span>] != <span class="built_in">NSOrderedAscending</span>)</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> result = font.pointSize + <span class="number">4</span>;</div><div class="line">    <span class="keyword">if</span> (text) &#123;</div><div class="line">        <span class="built_in">CGSize</span> size;</div><div class="line">        <span class="keyword">if</span> (SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(<span class="string">@"7.0"</span>)) &#123;</div><div class="line">            <span class="comment">//iOS 7</span></div><div class="line">            <span class="built_in">CGRect</span> frame = [text boundingRectWithSize:<span class="built_in">CGSizeMake</span>(widthValue, <span class="built_in">CGFLOAT_MAX</span>)</div><div class="line">                                              options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span></div><div class="line">                                           attributes:@&#123;<span class="built_in">NSFontAttributeName</span>:font&#125;</div><div class="line">                                              context:<span class="literal">nil</span>];</div><div class="line">            size = <span class="built_in">CGSizeMake</span>(frame.size.width, frame.size.height+<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//iOS 6.0</span></div><div class="line">        &#125;</div><div class="line">        result = MAX(size.height, result); <span class="comment">//At least one row</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="收起键盘"><a href="#收起键盘" class="headerlink" title="收起键盘"></a>收起键盘</h2><p>在UIViewController中收起键盘，除了调用相应控件的resignFirstResponder方法外，还有另外三种办法：</p>
<ol>
<li>重载ViewController中的touchBegin方法，然后在里面执行<code>[self.view endEditing:YES];</code>，这样单击UIViewController的任意地方，就可以收起键盘；</li>
<li>直接执行[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil]，用于在获得当前UIViewController比较困难的时候用；</li>
<li>直接执行<code>[[[UIApplication sharedApplication] keyWindow] endEditing:YES];</code>。</li>
</ol>
<h2 id="取消UIButton被按下时的高亮效果"><a href="#取消UIButton被按下时的高亮效果" class="headerlink" title="取消UIButton被按下时的高亮效果"></a>取消UIButton被按下时的高亮效果</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span>.adjustsImageWhenDisabled    = <span class="literal">false</span>;   <span class="comment">// 取消高亮效果</span></div><div class="line"><span class="built_in">UIButton</span>.adjustsImageWhenHighlighted = <span class="literal">false</span>;   <span class="comment">// 取消失能状态的高亮效果</span></div></pre></td></tr></table></figure>
<h2 id="Button图片和title共存"><a href="#Button图片和title共存" class="headerlink" title="Button图片和title共存"></a>Button图片和title共存</h2><p>很多时候我们在UI中需要实现同时具备image和title的button，最常见的场景如下：</p>
<div class="imagediv" style="width: 320px; height: 90px"></div>

<p>这样的效果如何实现呢？很简单，使用UIButton的<code>titleEdgeInsets</code>和<code>imageEdgeInsets</code>属性控制image和title的位置，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> spacingBetweenIconAndTitle = <span class="number">15.</span>f;  <span class="comment">// icon和title的间距</span></div><div class="line">    <span class="built_in">UIButton</span> *button                   = [[<span class="built_in">UIButton</span> alloc] init];</div><div class="line">    <span class="built_in">UIImage</span> *icon                      = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"order_order"</span>];</div><div class="line">    button.titleLabel.font             = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15.</span>f];</div><div class="line">    button.backgroundColor             = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">    [button setImage:icon forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    [button setTitle:<span class="string">@"购物车"</span> forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    [button setTitleEdgeInsets:<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, spacingBetweenIconAndTitle, <span class="number">0</span>, <span class="number">0</span>)];</div><div class="line">    [button setImageEdgeInsets:<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, spacingBetweenIconAndTitle)];</div><div class="line">    [button setTitleColor:[<span class="built_in">UIColor</span> lightGrayColor] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    [button sizeToFit];     <span class="comment">// 匹配最合适的size</span></div><div class="line">    <span class="built_in">CGRect</span> buttonFrame     = button.frame;</div><div class="line">    buttonFrame.size.width += spacingBetweenIconAndTitle;</div><div class="line">    button.frame           = buttonFrame;</div><div class="line">    button.center          = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.view.center.x, <span class="number">50</span>);</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.view addSubview:button];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/10/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/12/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>