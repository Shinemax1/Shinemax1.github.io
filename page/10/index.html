<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/10/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.67px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 15px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 18.33px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.67px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 20px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 13.33px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 16.67px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.67px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/Transition/" style="font-size: 13.33px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js基础/" style="font-size: 15px;">js基础</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，Android开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-thread-basics-in-ios" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/17/thread-basics-in-ios/" class="article-date">
  	<time datetime="2015-04-17T12:37:32.000Z" itemprop="datePublished">2015-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/17/thread-basics-in-ios/">iOS Thread基础知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>无论是什么开发环境，多线程总是一个绕不开的概念，本文是对iOS开发过程中多线程基础知识的汇总。本文最主要的参考资料是《<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a>》，为了方便，下文所指的<strong>文档</strong>除非有特别说明，否则都是指《Threading Programming Guide》；本文还参考《UNIX环境高级编程》，该书在CS领域地位非常之高，大家习惯称之为APUE，显得逼格更高，本文也不避俗，下文中使用APUE代指《UNIX环境高级编程》。</p>
<h2 id="多线程编程的几种方式"><a href="#多线程编程的几种方式" class="headerlink" title="多线程编程的几种方式"></a>多线程编程的几种方式</h2><p><strong>Cocoa有哪几种方法多线程编程方式？</strong></p>
<p>iOS开发领域多线程编程方式有很多中，这里只谈论基于Cocoa的多线程编程，不包括比较底层的C语言级别的多线程编程（譬如基于POSIX API）。</p>
<p>主要有三种方式：</p>
<ul>
<li>基于<code>NSThread</code></li>
<li>基于GCD</li>
<li>基于<code>NSOperation</code></li>
</ul>
<h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p>相较于后两种多线程编程方式，基于<code>NSThread</code>的多线程编程麻烦多了，需要考虑很多问题，包括：</p>
<ul>
<li>手动创建线程</li>
<li>配置线程属性</li>
<li>线程内存池管理</li>
<li>终止线程</li>
</ul>
<p>本文只是为了做个简介，如下内容只涉及两方面：创建线程、运行线程。</p>
<p><strong>创建线程</strong></p>
<p><code>NSThread</code>是一个类名，顾名思义，它是iOS对thread的一种封装。基于<code>NSThread</code>创建线程有两种方式：</p>
<ul>
<li>使用<code>detachNewThreadSelector:toTarget:withObject:</code>类方法来生成一个新的线程</li>
<li>创建一个新的<code>NSThread</code>对象，并调用它的<code>start</code>方法（在iOS和Mac OS X 10.5+版本才支持）</li>
</ul>
<p><code>detachNewThreadSelector:toTarget:withObject:</code>类方声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)detachNewThreadSelector:(SEL _Nonnull)aSelector</div><div class="line">                       toTarget:(<span class="keyword">id</span> _Nonnull)aTarget</div><div class="line">                     withObject:(<span class="keyword">id</span> _Nullable)anArgument;</div><div class="line"><span class="comment">/* 参数说明：</span></div><div class="line"> * aSelector</div><div class="line"> *     The selector for the message to send to the target. </div><div class="line"> *     This selector must take only one argument and must not have a return value.</div><div class="line"> * aTarget  </div><div class="line"> *     The object that will receive the message aSelector on the new thread.</div><div class="line"> * anArgument   </div><div class="line"> *     The single argument passed to the target. May be nil.</div><div class="line"> */</div></pre></td></tr></table></figure>
<p>如果调用该接口，会立马创建并启动一个新线程；如果想创建一个线程但并不立马启动它，则使用如下方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSThread</span> *myThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span></div><div class="line">                                             selector:<span class="keyword">@selector</span>(doNothing)</div><div class="line">                                               object:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>此方法和<code>detachNewThreadSelector:toTarget:withObject:</code>方法初始化一个新的<code>NSThread</code>实例需要相同的开销。然而它并没有启动一个线程，若需要启动一个线程，可以显式调用对象的<code>start</code>方法，即<code>[myThread start];</code>。</p>
<p>值得一提的是，如果你拥有一个<code>NSThread</code>对象，它的线程当前正在运行，你可以给该线程发送消息的唯一方法是在你应用程序里面的任何对象使用<code>performSelector:onThread:withObject:waitUntilDone:</code>方法。</p>
<p><strong>Using NSObject to Spawn a Thread</strong></p>
<p>除了以上两种方式之外，还可以使用<code>NSObject</code>派生出一个thread。iOS和OS X v10.5+版本都可以使用接口<code>performSelectorInBackground:withObject:</code>来派生出一个新thread，这个API和上文的<code>detachNewThreadSelector:toTarget:withObject:</code>有些类似，不同的是它没有target参数，因为target就是调用者本身，这里需要传入的第一个参数对应的是调用者的某个方法。</p>
<p>P.S: 不晓得这个接口有什么应用场景？</p>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>本博客有多篇关于GCD的博客，详见<a href="/tags/GCD/">GCD</a>。</p>
<h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p>《<a href="/nsoperation-vs-gcd/">NSOperation v.s GCD</a>》一文中对<code>NSOperation</code>的使用有详细说明。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>线程同步可是多线程领域的热门话题。线程是不存在独立内存空间的，同属一个进程的线程们共享所属进程的内存空间。当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图。如果每个线程使用的变量都是其他线程不会读取或修改的，那么就不存在一致性（同步）问题；同样地，如果变量是只读的，那么线程同时读取该变量也不会有一致性（同步）问题。但是，当某个线程可以修改变量，而其他线程也可以读取或者修改这个变量时，就需要对这些线程进行同步，以确保它们在访问变量的存储内容时不会访问到无效的数值。</p>
<p>《<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-124887" target="_blank" rel="external">Threading Programming Guide</a>》中介绍了5种同步工具：</p>
<ul>
<li>原子操作</li>
<li>内存屏障和volatile变量</li>
<li>锁</li>
<li>条件变量</li>
<li>Perform Selector Routines</li>
</ul>
<p>根据我的理解，第二种同步工具「内存屏障和volatile变量」的本质是从控制编译的思路解决线程同步问题，这个太高深，本文就不涉及了，况且文档明确警告慎用：</p>
<blockquote>
<p>Because both memory barriers and volatile variables decrease the number of optimizations the compiler can perform, they should be used sparingly and only where needed to ensure correctness. For information about using memory barriers, see the OSMemoryBarrier man page.</p>
</blockquote>
<p>至于最后一种同步工具在我看来把它划分到线程通信或许更合适。</p>
<p>因此本文只介绍其余3种同步工具。</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作是同步的一个简单的形式，它处理简单的数据类型。对于简单的操作，比如递增一个计数器，原子操作比使用锁（下文会提到）具有更高的性能优势。</p>
<p>对原子操作的理解是非常基础的知识，本文就不多赘述了，我好奇的是Mac OS X/iOS的原子操作的实现机制。刚开始怀疑它是对下文要提到的互斥锁的一种封装，但看官方文档感觉不像，毕竟官方文档明确表明，对于简单的操作，原子操作比互斥锁具有更高的性能。如果是对互斥锁的封装，性能怎么可能会超过互斥锁呢？博文《<a href="http://www.infoq.com/cn/articles/atomic-operation/" target="_blank" rel="external">原子操作的实现原理</a>》对这个问题进行了比较详细的分析，虽然不确定详细实现，但能确定Apple的原子性实现是基于非常底层的处理。</p>
<p>在iOS开发中，我们如何使用<strong>原子操作</strong>这个同步工具呢？最常见的莫过于是对属性进行原子保护，只需要使用<code>atomic</code>修饰需要保护的属性即可；至于在其他场合使用原子操作工具，可以参考<code>/usr/include/libkern/OSAtomic.h</code>，该文件提供了大量的原子操作接口。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>锁是最常用的同步工具</strong>。你可以是使用锁来保护临界区（critical section），这些代码段在同一个时间只能允许被一个线程访问。比如，一个临界区可能会操作一个特定的数据结构，或使用了每次只能一个客户端访问的资源。根据应用场景不同，锁有许多划分：</p>
<ul>
<li>互斥锁（mutex）</li>
<li>递归锁（recursive lock）</li>
<li>读写锁（read-write lock）</li>
<li>分布锁（distributed lock）</li>
<li>自旋锁（spin lock）</li>
<li>双重检查锁（double-checked lock）</li>
</ul>
<p>不同开发语言中定义的锁的种类和应用场景可能不尽相同，如上这些锁是在文档中涉及过的；此外，和其他资源一样，下文中的锁资源只涉及Objective-C类型资源，更底层的譬如POSIX接口资源就不涉及了。</p>
<p><strong>互斥锁（Mutex）</strong></p>
<p>互斥锁在APUE中被称为<strong>互斥量</strong>，<strong>互斥锁</strong>的叫法更为广泛。根据我的理解，和其他锁一样，互斥锁的本质是基于信号量的封装，文档中明确写道：A mutex is a type of semaphore that grants access to only one thread at a time.</p>
<p>简单来说，<strong>互斥锁是一种特殊的变量，用来保护同一时间只有一个线程访问数据</strong>。顾名思义，可以把它看做一把锁，在访问共享资源前对之进行加锁（lock），在访问完后释放之（unlock）。对mutex加锁后，其他任何试图再次对mutex加锁的线程将会被阻塞直到当前线程释放mutex（unlock）。如果释放mutex时有多个线程阻塞，则所有在该mutex上的阻塞线程都会变成可运行状态，第一个变为可运行状态的线程可以对mutex加锁，进而访问共享资源，而其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新被释放。</p>
<p>P.S: 容易想到，加锁和释放锁的操作都是原子的！</p>
<p>值得注意的是，在开发时需要确保所有的线程必须遵守相同的数据访问规则：在使用共享资源时先获取锁，使用完了便释放锁。只有这样，互斥机制才能正常工作。操作系统并不会做数据访问的串行化，如果允许其中的某个线程在没有得到锁的情况下也可以访问共享资源，那么即使其他的线程在使用共享资源前都获取了锁，也还是会出现数据不一致的情况。</p>
<p>互斥锁的使用非常简单，基本套路就是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[lock lock];            <span class="comment">// 上锁</span></div><div class="line">handle common source    <span class="comment">// 处理公共资源</span></div><div class="line">[lock unlock];          <span class="comment">// 释放锁</span></div></pre></td></tr></table></figure>
<p>如下是一个比较详细的示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span> </span>&#123;</div><div class="line">    <span class="built_in">NSLock</span> *testLock;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化「锁」</span></div><div class="line">    testLock = [[<span class="built_in">NSLock</span> alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">// 1号线程</span></div><div class="line">    <span class="built_in">NSThread</span> *thread1 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span></div><div class="line">                                                selector:<span class="keyword">@selector</span>(commonSource)</div><div class="line">                                                  object:<span class="literal">nil</span>];</div><div class="line">    thread1.name = <span class="string">@"1号线程"</span>;</div><div class="line">    [thread1 start];</div><div class="line"></div><div class="line">    <span class="comment">// 2号线程</span></div><div class="line">    <span class="built_in">NSThread</span> *thread2 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span></div><div class="line">                                                selector:<span class="keyword">@selector</span>(commonSource)</div><div class="line">                                                  object:<span class="literal">nil</span>];</div><div class="line">    thread2.name = <span class="string">@"2号线程"</span>;</div><div class="line">    [thread2 start];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)commonSource &#123;</div><div class="line">    [testLock lock];    <span class="comment">// 上锁</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ 已经锁住公共资源"</span>, [<span class="built_in">NSThread</span> currentThread].name);</div><div class="line">    sleep(<span class="number">5</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ 将要释放公共资源"</span>, [<span class="built_in">NSThread</span> currentThread].name);</div><div class="line">    [testLock unlock];  <span class="comment">// 释放锁</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>NSLock</code>提供的接口除了<code>lock</code>和<code>unlock</code>之外，还有<code>-(BOOL)tryLock</code>和<code>-(BOOL)lockBeforeDate:</code>这两个API。</p>
<p><code>tryLock</code>尝试给<code>NSLock</code>对象上锁，若上锁成功，则返回<code>YES</code>，否则，返回<code>False</code>，但它不会阻塞线程，<code>tryLock</code>的一般用法是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([testLock tryLock]) &#123;</div><div class="line">    handle common source    <span class="comment">// 处理公共资源</span></div><div class="line">    [testLock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>lockBeforeDate:</code>，它给获取锁设定一个时间，在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回<code>NO</code>；</p>
<p><strong>使用@synchronized指令</strong></p>
<p><code>@synchronized</code>指令而不是<code>@synthesize</code>哦！<code>@synchronized</code>是实现互斥锁的一种简洁版本。使用方式如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)myMethod:(<span class="keyword">id</span>)anObj &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(anObj) &#123;</div><div class="line">        <span class="comment">// Everything between the braces is protected by the @synchronized directive.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传给<code>@synchronized</code>指令的参数<code>self</code>是几个意思呢？文档说明如下：</p>
<blockquote>
<p>The object passed to the @synchronized directive is a unique identifier used to distinguish the protected block. If you execute the preceding method in two different threads, passing a different object for the <em>anObj</em> parameter on each thread, each would take its lock and continue processing without being blocked by the other. If you pass the same object in both cases, however, one of the threads would acquire the lock first and the other would block until the first thread completed the critical section.</p>
</blockquote>
<p><strong>递归锁（recursive lock）</strong></p>
<p>使用<strong>互斥锁</strong>这个同步工具，哪怕各个线程在使用公共资源时都严格遵守「上锁-使用-释放」规则，仍然会有问题：当某个线程在持有锁的情况下再次获取锁时会造成死锁，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)commonSource &#123;</div><div class="line">    [testLock lock];    <span class="comment">// 上锁</span></div><div class="line">    [testLock lock];    <span class="comment">// 上锁</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ 已经锁住公共资源"</span>, [<span class="built_in">NSThread</span> currentThread].name);</div><div class="line">    sleep(<span class="number">5</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ 将要释放公共资源"</span>, [<span class="built_in">NSThread</span> currentThread].name);</div><div class="line">    [testLock unlock];  <span class="comment">// 释放锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>递归锁</strong>和<strong>互斥锁</strong>差不多，只是不同的是它允许线程可以多次获取锁而不会造成死锁。</p>
<p>在Cocoa中，<strong>递归锁</strong>对应的类型是<code>NSRecursiveLock</code>，其接口和<code>NSLock</code>完全一致，就不再使用示例说明其用法了。</p>
<p><strong>读写锁（read-write lock）</strong></p>
<p>Cocoa没有提供<strong>读写锁</strong>相关的类型，引自文档：</p>
<blockquote>
<p>The system supports read-write locks using POSIX threads only. For more information on how to use these locks, see the pthread man page.</p>
</blockquote>
<p>本文只对<strong>读写锁</strong>进行简要介绍。</p>
<p><strong>读写锁</strong>与<strong>互斥锁</strong>类似，不过<strong>读写锁</strong>允许更高的并行性。<strong>互斥锁</strong>要么是锁住状态要么是不加锁状态，而且一次只能有一个线程对其加锁。<strong>读写锁</strong>可以有三种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有<strong>写模式</strong>的读写锁，但是多个线程可以同时占有<strong>读模式</strong>的读写锁。</p>
<p>当<strong>读写锁</strong>是<strong>写加锁</strong>状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。</p>
<p>当<strong>读写锁</strong>是<strong>读加锁</strong>状态时，所有试图以<strong>读模式</strong>对它进行加锁的线程都可以得到访问权，但是如果线程希望以<strong>写模式</strong>对此锁进行加锁，它必须阻塞直到所有线程释放读锁。虽然<strong>读写锁</strong>的实现各不相同，但当<strong>读写锁</strong>处于<strong>读模式</strong>锁住状态时，如果有另外的线程试图以<strong>写模式</strong>加锁，读写锁通常会阻塞随后的<strong>读模式</strong>锁请求，这样可以避免<strong>读模式</strong>长期占用，而等待的<strong>写模式</strong>请求一直得不到满足。</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。</p>
<p>当<strong>读写锁</strong>在<strong>写模式</strong>下时，它所保护的数据结构就可以被安全地修改，因为当前只有一个线程可以在<strong>写模式</strong>下拥有这个锁。</p>
<p>当<strong>读写锁</strong>在<strong>读模式</strong>下时，只要线程获取了读模式下的读写锁，该锁所保护的数据结构可以被多个获得读模式锁的线程所保护。</p>
<p>读写锁也叫做「共享-独占锁」，当<strong>读写锁</strong>以<strong>读模式</strong>锁住时，它是以共享模式锁住的，当它以<strong>写模式</strong>锁住时，它是以独占模式锁住的。</p>
<p><strong>分布锁（distributed lock）</strong></p>
<p><strong>分布锁</strong>是进程级别的同步工具：</p>
<blockquote>
<p>A distributed lock provides mutually exclusive access at the process level. Unlike a true mutex, a distributed lock does not block a process or prevent it from running. It simply reports when the lock is busy and lets the process decide how to proceed.</p>
</blockquote>
<p>本文略过！</p>
<p><strong>自旋锁（spin lock）</strong></p>
<p>引自百度百科：</p>
<blockquote>
<p><strong>自旋锁是专为防止多处理器并发而引入的一种锁</strong>。何谓<strong>自旋锁</strong>？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，「自旋」一词就是因此而得名。</p>
</blockquote>
<p>Mac OS X/iOS系统没有提供自旋锁的实现：</p>
<blockquote>
<p>The system does not provide any implementations of spin locks because of their polling nature, but you can easily implement them in specific situations. For information on implementing spin locks in the kernel, see <em>Kernel Programming Guide</em>.</p>
</blockquote>
<p>本文略过！</p>
<p><strong>双重检查锁（double-checked lock）</strong></p>
<p>关于双重检查锁，能够找到的资料不多，引自文档：</p>
<blockquote>
<p>A double-checked lock is an attempt to reduce the overhead of taking a lock by testing the locking criteria prior to taking the lock. Because double-checked locks are potentially unsafe, the system does not provide explicit support for them and their use is discouraged.</p>
</blockquote>
<h2 id="关于锁的一些总结"><a href="#关于锁的一些总结" class="headerlink" title="关于锁的一些总结"></a>关于锁的一些总结</h2><p><strong>避免死锁</strong></p>
<p>锁是最常用的同步工具，同时，使用锁作为同步工具也存在一些问题，最经典的问题莫过于死锁。</p>
<p>上文在介绍递归锁时已经介绍了一种死锁情况：如果线程试图对一个<strong>互斥锁</strong>加锁两次，那么它自身就会陷入<strong>死锁</strong>状态。除此之外，还有一些更不明显的方式也可能会产生死锁。例如，程序中使用多个<strong>互斥锁</strong>时，如果允许一个线程一直占有第一个<strong>互斥锁</strong>，并且在试图锁住第二个互斥锁时处于阻塞状态，但是拥有第二个<strong>互斥锁</strong>的线程也在试图锁住第一个<strong>互斥锁</strong>，此时也会发生死锁，因为此时两个线程都在相互请求对方拥有的资源，所以这两个线程都无法向前运行，于是就产生<strong>死锁</strong>。</p>
<p><strong>原子操作和互斥锁的代价</strong></p>
<p>在很多场合下，既可以选择使用<strong>原子操作</strong>作为同步工具，也可以选择使用<strong>互斥锁</strong>；面对这种场景，应该选择哪个呢？站在性能的角度，当然应该选择性能更棒的，针对二者的性能对比，文档提供了一张表：</p>
<div class="imagediv" style="width: 780px; height: 320px"></div>

<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>关于条件变量，文档的描述如下：</p>
<blockquote>
<p><strong>A condition is another type of semaphore</strong> that allows threads to signal each other when a certain condition is true. Conditions are typically used to indicate the availability of a resource or to ensure that tasks are performed in a specific order. When a thread tests a condition, it blocks unless that condition is already true. It remains blocked until some other thread explicitly changes and signals the condition.</p>
</blockquote>
<p><strong>条件变量</strong>为多个线程提供了一个会合的场所，和<strong>锁</strong>不同，<strong>条件变量</strong>允许线程以无竞争的方式等待特定的条件发生。</p>
<p>P.S: 所谓「无竞争」，根据我的理解，指的是线程之间不会以无序混乱的方式抢占公共资源，对于互斥锁，如果不考虑两个线程的时间先后顺序，它们抢占公共资源的概率均是50%，谁先获得是未知的。</p>
<p>基于<strong>条件变量</strong>的同步操作，主要包括两个动作：一个线程等待「条件变量的条件为真」；另一个线程使「条件成立」。前者<strong>读</strong>（或曰测试）条件变量，后者修改条件变量，当然需要保证其操作原子性，所以一般使用互斥锁保护条件变量本身。</p>
<p>文档介绍了一种需要条件变量作为同步工具的应用场景：</p>
<blockquote>
<p>One way you might use a condition is to manage a pool of pending events. The event queue would use a condition variable to signal waiting threads when there were events in the queue. If one event arrives, the queue would signal the condition appropriately. If a thread were already waiting, it would be woken up whereupon it would pull the event from the queue and process it. If two events came in to the queue at roughly the same time, the queue would signal the condition twice to wake up two threads.</p>
</blockquote>
<p>OK，来介绍<code>NSCondition</code>（Cocoa中实现condition的类型）的使用方法。<code>NSCondition</code>的接口非常少，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSCondition</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt;</span></div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)wait;         <span class="comment">// 等待「条件满足」，被唤醒</span></div><div class="line">- (<span class="built_in">BOOL</span>)waitUntilDate:(<span class="built_in">NSDate</span> *)limit;</div><div class="line">- (<span class="keyword">void</span>)signal;       <span class="comment">// 通知条件已满足，唤醒某个等待的线程</span></div><div class="line">- (<span class="keyword">void</span>)broadcast;    <span class="comment">// 通知条件已满足，唤醒所有等待的线程</span></div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>NSCondition</code>将用于保护condition原子性的互斥锁和condition打包封装到了一起，它遵循<code>NSLocking</code>协议，所以实现了<code>lock</code>和<code>unlock</code>这两个方法，用户不用额外创建锁。<code>NSCondition</code>的一般使用形式如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// myCondition: NSCondition object</span></div><div class="line"><span class="comment">// someCheckIsTrue: test condition</span></div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)method1 &#123;</div><div class="line">    [myCondition lock];             <span class="comment">// 设置锁，防止condition被别个线程修改</span></div><div class="line">    <span class="keyword">while</span> (!someCheckIsTrue) &#123;      <span class="comment">// 测试condition</span></div><div class="line">        [myCondition wait];         <span class="comment">// 睡眠，等待被唤醒</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Do something.</span></div><div class="line">    </div><div class="line">    [myCondition unlock];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">    [myCondition lock];             <span class="comment">// 设置锁，防止别个线程读取condition</span></div><div class="line">    </div><div class="line">    <span class="comment">// Do something.</span></div><div class="line">    </div><div class="line">    someCheckIsTrue = <span class="literal">YES</span>;          <span class="comment">// 更新condition</span></div><div class="line">    [myCondition signal];           <span class="comment">// 通知condition已满足，唤醒某个正在等待的线程</span></div><div class="line">    [myCondition unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对代码进行说明：</p>
<ol>
<li>所谓test condition，并不是指test <code>NSCondition</code>对象，被test的condition可以是任何形式，譬如<code>[myArray count] == 0</code>等；</li>
<li>method1中<code>while</code>循环不能使用<code>if</code>代替，在<code>while</code>循环中检查条件，被唤醒后会再次test condition，若不满足会继续睡眠；</li>
<li>method2中的最后两行代码在我看来顺序无所谓，因为condition已经在上一行代码中更新完了，晚点儿解锁也没问题；</li>
</ol>
<h2 id="其他线程同步方式"><a href="#其他线程同步方式" class="headerlink" title="其他线程同步方式"></a>其他线程同步方式</h2><p>对于iOS开发而言，如上所介绍的线程同步工具并非最好的选择，根据《Effective Objective-C 2.0》的说法，以上同步工具都不如使用GCD工具。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://book.douban.com/subject/1788421/" target="_blank" rel="external">UNIX环境高级编程</a></li>
<li><a href="http://www.infoq.com/cn/articles/atomic-operation/" target="_blank" rel="external">原子操作的实现原理</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD/">GCD</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-basics-in-objective-c" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/12/basics-in-objective-c/" class="article-date">
  	<time datetime="2015-04-12T14:27:32.000Z" itemprop="datePublished">2015-04-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/12/basics-in-objective-c/">Objective-C基础知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文属于汇总文，对Objective-C语言层面的一些基础问题进行汇总，有的问题可直接在本文找到答案，有的知识提供其他博文的链接。</p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>「内联函数」是一个很老的概念，在其他语言譬如C++语言中也出现了。所谓「内联函数」指的是：有函数的结构，但不具备函数的性质，类似于宏替换功能的代码块。</p>
<p>在实际应用中，常常把规模较小、逻辑较简单的操作定义成内联函数，定义内联函数只要在函数前面加上<code>inline</code>关键字修饰即可；站在编译器的角度，处理内联函数就是在每个它的调用点上「内联地」展开。假设有定义如下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="built_in">NSString</span> * getNavigationTitleWithCount(<span class="keyword">int</span> cnt) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"已选中%d项"</span>, (<span class="keyword">int</span>)cnt];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>则编译器对如下代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UILabel</span> *label = [<span class="built_in">UILabel</span> new];</div><div class="line">label.text = getNavigationTitleWithCount(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>的处理，如同对如下代码代码的处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UILabel</span> *label = [<span class="built_in">UILabel</span> new];</div><div class="line">label.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"已选中%d项"</span>, (<span class="keyword">int</span>)<span class="number">0</span>];</div></pre></td></tr></table></figure>
<p>一句话说明：<strong>程序在调用内联函数时的开销和调用宏的开销是一样的，但内联函数显然比宏要强大一些，至少它保证了类型安全</strong>；相较于普通函数，调用内联函数没有「保护现场、push栈、pop栈等等」之类的开销。</p>
<p>内联函数的好处显而易见，但并不是所有函数都可以形成真正的内联函数。如上所述，定义一个内联函数只要在定义时加上<code>inline</code>关键字即可，但能否形成真正的内联函数，还要看编译器对内联函数体内部定义的具体处理。</p>
<p>一般来说，内联函数定义的代码量逻辑简单、代码量小，并且属于那种频繁使用的代码块；<strong>内联函数不能使用循环语句，不能使用递归调用</strong>；</p>
<h2 id="const的使用"><a href="#const的使用" class="headerlink" title="const的使用"></a>const的使用</h2><p>在Objective-C代码中，经常需要定义一些常量指针，譬如AFNetworking中有如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityDidChangeNotification;</div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityNotificationStatusItem;</div></pre></td></tr></table></figure>
<p>和其他语言一样，定义常量的关键字是<code>const</code>，但问题是常常不知道<code>const</code>该往哪里放，<code>NSString * const XXOO</code>还是<code>NSString const * XXOO</code>？</p>
<p>其实，在Objective-C中还好一点，C/C++中<code>const</code>的各种使用姿势更难懂，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * label1       = <span class="string">""</span>;</div><div class="line"><span class="keyword">char</span> <span class="keyword">const</span> * label2       = <span class="string">""</span>;</div><div class="line"><span class="keyword">char</span> * <span class="keyword">const</span> label3       = <span class="string">""</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> label4 = <span class="string">""</span>;</div></pre></td></tr></table></figure>
<p>经常傻傻分不清楚。不过还好，脑子恰好还残留着一些本科老师讲过的内容，记得本科C语言老师教过一种简单的记忆方法：const总是修饰其左边的东东，如果其左边没有东东，则修饰右边的东东。</p>
<p>如何理解呢？对于<code>char const * label2</code>而言，const的左边是char，所以const修饰的是char本身，即内容本身，所以表示“label1指向的内容是常量，不可变”；对于<code>const char * label1</code>而言，const左边没有东东，所以它修饰右边的东东，即char，所以表示“label2指向的内容是常量，不可变”；对于<code>char * const label3</code>，const左边的东东是*，所以修饰的是指针，即表示“label3指针本身是常量，不可变”，所以解释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * label1       = <span class="string">""</span>;      <span class="comment">// 内容是常量，不可变</span></div><div class="line"><span class="keyword">char</span> <span class="keyword">const</span> * label2       = <span class="string">""</span>;      <span class="comment">// 内容是常量，不可变</span></div><div class="line"><span class="keyword">char</span> * <span class="keyword">const</span> label3       = <span class="string">""</span>;      <span class="comment">// 指针是常量，不可变</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> label4 = <span class="string">""</span>;      <span class="comment">// 指针和内容都是常量，不可变</span></div></pre></td></tr></table></figure>
<p>这个判断方法同样适用于Objective-C，所以如下代码是没问题的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// const的左边是NSString，修饰的是NSString对象，表示“NSString对象本身不可修改”（但指针可以）</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> <span class="keyword">const</span> * testString = <span class="string">@"I am an iOS developer"</span>;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    testString = <span class="string">@"我是一个iOS开发者"</span>; <span class="comment">// 合法</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, testString);   <span class="comment">// print "我是一个iOS开发者"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但如下代码不合法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// const的左边是*，修饰的是指针本身，表示testString地址值不可修改</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> testString = <span class="string">@"I am an iOS developer"</span>;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    testString = <span class="string">@"我是一个iOS开发者"</span>; <span class="comment">// 非法</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, testString);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="mm文件"><a href="#mm文件" class="headerlink" title=".mm文件"></a>.mm文件</h2><ul>
<li>.m文件是Objective-C文件</li>
<li>.mm文件相当于C++或者C文件</li>
</ul>
<h2 id="Extension和Category"><a href="#Extension和Category" class="headerlink" title="Extension和Category"></a>Extension和Category</h2><p>参考：<a href="http://blog.csdn.net/leikezhu1981/article/details/19091049" target="_blank" rel="external">http://blog.csdn.net/leikezhu1981/article/details/19091049</a></p>
<h2 id="Compiler-Directives"><a href="#Compiler-Directives" class="headerlink" title="Compiler Directives"></a>Compiler Directives</h2><p><a href="http://nshipster.com/at-compiler-directives/" target="_blank" rel="external">http://nshipster.com/at-compiler-directives/</a></p>
<p><a href="http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/</a></p>
<h2 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h2><p>详细内容参考《<a href="http://nshipster.cn/pragma/" target="_blank" rel="external">NSHipster – #pragma</a>》和《<a href="/pragma/">预处理指令#pragma</a>》</p>
<h2 id="0-nil-Nil-NULL-NSNull"><a href="#0-nil-Nil-NULL-NSNull" class="headerlink" title="0/nil/Nil/NULL/NSNull"></a>0/nil/Nil/NULL/NSNull</h2><p>这一部分内容摘自<a href="http://nshipster.cn/nil/" target="_blank" rel="external">nil/Nil/NULL/NSNull</a>，原文详见<a href="http://nshipster.com/nil/" target="_blank" rel="external">这里</a>。</p>
<p>理解「不存在」的概念不仅仅是一个哲学的问题，也是一个实际的问题。我们是有形宇宙的居民，而原因在于逻辑宇宙的存在不确定性。作为一个逻辑系统的物理体现，电脑面临一个棘手的问题，就是如何用存在表达「不存在」。</p>
<p>在Objective－C中，有几个不同种类的「不存在」。C语言用<code>0</code>来作为不存在的原始值，而<code>NULL</code>作为指针（这在指针环境中相当于<code>0</code>）。</p>
<p>Objective-C在C的基础上增加了<code>nil</code>。<code>nil</code>是一个指向不存在的对象指针，虽然它在语义上与<code>NULL</code>不同，但它们在技术上是相等的。</p>
<p>在框架层面，Foundation定义了<code>NSNull</code>，<code>NSNull</code>中有一个类方法<code>+null</code>，它返回一个单独的<code>NSNull</code>对象。NSNull与nil以及NULL不同，因为它是一个实际的对象，而不是一个零值。</p>
<p>另外，在<a href="https://gist.github.com/4469665" target="_blank" rel="external">Foundation/NSObjCRuntime.h</a>中，<code>Nil</code>被定义为指向零的类指针，可以把它看做是<code>nil</code>的表亲。虽然它鲜为人知，但至少值得注意一下。</p>
<p>总的来说，这里的四个表达没有的值是每个Objective-C程序员都应该知道的：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th style="text-align:center">值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NULL</td>
<td style="text-align:center">(void *)0</td>
<td style="text-align:center">C指针的字面零值</td>
</tr>
<tr>
<td style="text-align:center">nil</td>
<td style="text-align:center">(id)0</td>
<td style="text-align:center">Objective-C对象的字面零值</td>
</tr>
<tr>
<td style="text-align:center">Nil</td>
<td style="text-align:center">(Class)0</td>
<td style="text-align:center">Objective-C类的字面零值</td>
</tr>
<tr>
<td style="text-align:center">NSNull</td>
<td style="text-align:center">[NSNull null]</td>
<td style="text-align:center">用来表示零值的单独的对象</td>
</tr>
</tbody>
</table>
<h2 id="关于nil的一些事儿"><a href="#关于nil的一些事儿" class="headerlink" title="关于nil的一些事儿"></a>关于nil的一些事儿</h2><p>刚被分配的NSObject的内容被设置为0。也就是说那个对象所有的指向其他对象的指针都从<code>nil</code>开始，所以在<code>init</code>方法中设置<code>self.(association) = nil</code>之类的表达是没有必要的。</p>
<p>当然，也许nil最显著的行为是，它虽然为零，仍然可以有消息发送给它。在其他的语言中，比如C++，这样做会使你的程序崩溃，<strong>但在Objective-C中，在<code>nil</code>上调用方法返回一个零值</strong>。这大大的简化了表达，因为它避免了在使用<code>nil</code>之前对它的检查。</p>
<h2 id="isEqual-和"><a href="#isEqual-和" class="headerlink" title="isEqual:和=="></a>isEqual:和==</h2><p>参考<a href="http://nshipster.com/equality/。" target="_blank" rel="external">http://nshipster.com/equality/。</a></p>
<h2 id="基本数据类型长度"><a href="#基本数据类型长度" class="headerlink" title="基本数据类型长度"></a>基本数据类型长度</h2><table>
<thead>
<tr>
<th style="text-align:center">名字</th>
<th style="text-align:center">typedef（32bit/64bit）</th>
<th style="text-align:center">长度（32bit/64bit）（单位：bit）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">-</td>
<td style="text-align:center">32/32</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">-</td>
<td style="text-align:center">32/64</td>
</tr>
<tr>
<td style="text-align:center">long long</td>
<td style="text-align:center">-</td>
<td style="text-align:center">64/64</td>
</tr>
<tr>
<td style="text-align:center">NSInteger</td>
<td style="text-align:center">int/long</td>
<td style="text-align:center">32/64</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">-</td>
<td style="text-align:center">32/32</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">-</td>
<td style="text-align:center">64/64</td>
</tr>
<tr>
<td style="text-align:center">long double</td>
<td style="text-align:center">-</td>
<td style="text-align:center">128/128</td>
</tr>
<tr>
<td style="text-align:center">CGFloat</td>
<td style="text-align:center">float/double</td>
<td style="text-align:center">32/64</td>
</tr>
</tbody>
</table>
<p>对于<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>，在不同的平台下（32位和64位）下唯一有区别的是<code>long</code>，其余三个在不同硬件平台所占据数据长度是一致的；至于<code>NSInteger</code>和<code>NSFloat</code>，数据长度和平台完全对应，由此可见，基于Cocoa编程尽可能使用<code>NSInteger</code>和<code>NSFloat</code>，而不直接使用<code>int</code>、<code>float</code>等。</p>
<p>P.S：与<code>NSInteger</code>和<code>int</code>对应的是<code>NSUInteger</code>和<code>unsigned int</code>，但是不存在所谓的<code>unsigned float</code>和<code>CGUFloat</code>哦！</p>
<p><code>int</code>和<code>long</code>的最大值和最小值比较容易计算，<code>float</code>和<code>double</code>的最大值和最小值计算则麻烦多了，IEEE-754协议对此专门做了定义，详见<a href="http://baike.baidu.com/view/1698149.htm" target="_blank" rel="external">百度百科：IEEE-754</a>和<a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" rel="external">wiki: IEEE floating point</a></p>
<h2 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h2><p><strong>#import v.s #include</strong></p>
<p><code>#import</code>和<code>#include</code>的作用类似：都是先要求<strong>预处理器</strong>读取某个文件（一般是头文件），然后将读入的内容添加至输出到对应的位置；或者简单来说，二者都用作<strong>导入文件</strong>。前者确保<strong>预处理器</strong>对指定的文件只导入一次，后者则允许多次导入同一个文件。</p>
<p><strong>尖括号 v.s 双引号</strong></p>
<p>如果使用尖括号（<code>&lt;&gt;</code>），则编译器会先在预先设定好的标准目录下查找相应的文件（譬如系统头文件）；如果使用双引号（<code>&quot;&quot;</code>），则编译器会先在项目目录下查找相应的头文件。</p>
<p><strong>#import v.s @import</strong></p>
<p>如下内容摘自《<a href="http://www.cnblogs.com/sammyCoding/p/3654743.html" target="_blank" rel="external">在ios 7下，使用@import代替#import</a>》：</p>
<blockquote>
<p>在xcode 5 下，为了更易于开发，增加了modules和 auto-linking 这两个新特性。用 @import 来增加框架 到项目中比用 #import会更有效. 我们来看看为什么：</p>
<blockquote>
<p>Modules for system frameworks speed build time and provide an alternate means to import APIs from the SDK instead of using the C preprocessor. Modules provide many of the build-time improvements of precompiled headers with less maintenance or need for optimization. They are designed for easy adoption with little or no source changes. Beyond build-time improvements, modules provide a cleaner API model that enables many great features in the tools, such as Auto Linking.</p>
</blockquote>
<p>Modules and auto-linking 默认情况下是enabled的。 如果是旧的项目，你可以通过设置”Language - Modules.” 来设置Enable Modules 和Link Frameworks Automatically 为Yes。<br>另外一个使用moudules的好处是你再也不用去链接你的framework到你的项目了。<br>例如，在以前，如果你要使用MapKit这个框架，你要这样做<br>1) 使用语句 #import <mapkit mapkit.h=""> 导入框架<br>2) 去到项目的build phases 设置项，找到MapKit.framework.并加入到Link Binary With Libraries里面。<br>如果使用modules的话，只需要加入语句 “@import MapKit;” 你就可以开始使用了,根本不需要链接到你的项目。</mapkit></p>
</blockquote>
<p>更多内容参考《<a href="http://stackoverflow.com/questions/18947516/import-vs-import-ios-7" target="_blank" rel="external">stackoverflow: @import vs #import - iOS 7</a>》。</p>
<h2 id="弱引用的自动置零特性"><a href="#弱引用的自动置零特性" class="headerlink" title="弱引用的自动置零特性"></a>弱引用的自动置零特性</h2><p>当某个由弱引用指向的对象被释放时，相应的指针变量会被<strong>归零</strong>（zerod），即赋为<code>nil</code>。</p>
<h2 id="多态、动态类型和动态绑定"><a href="#多态、动态类型和动态绑定" class="headerlink" title="多态、动态类型和动态绑定"></a>多态、动态类型和动态绑定</h2><p><strong>什么是多态</strong></p>
<p>一句话解释：不同对象对同一个消息的不同响应。</p>
<p><strong>什么是动态绑定</strong></p>
<p>「动态绑定」是指在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>
<p><strong>动态类型id</strong></p>
<p><code>id</code>数据类型是一种通用的对象类型。也就是说，它可以用来存储任何对象。在代码中可以向id类型发送任何消息，Objective-C系统（编译器）不会在编译期对之进行类型检验，只有运行到相关代码时才会判断所引用对象的实际类型，然后根据实际的类型调用其相应的方法。</p>
<p>举个例子说明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">id</span> number = @<span class="number">5</span>;</div><div class="line">    <span class="keyword">if</span> ([number isEqualToString:<span class="string">@"whatTheFuck"</span>]) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"见鬼了"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，首先创建一个NSNumber类型实例，并把它赋给<code>id</code>类型变量number；在if语句中，向number发送<code>isEqualToString:</code>消息，根据我们对NSNumber的了解，它是没有定义<code>isEqualToString:</code>方法的，因此不会对这个消息进行响应。然而，这段代码完全可以以「0 error、0 warning」通过编译，只是在运行时会抛出NSInvalidArgumentException异常：<br>reason: ‘-[__NSCFNumber isEqualToString:]: unrecognized selector sent to instance 0x7bf67200’</p>
<p>这个示例形象阐述「动态绑定」的含义，并且验证了「id类型可以用来存储任何对象」的说法。</p>
<p><strong>Objective-C如何实现多态的</strong></p>
<p>根据上述对「多态」、「动态绑定」以及「动态类型id」的解释，可以直接回答：Objective-C实现多态的方式是动态绑定。</p>
<p>P.S：也有人认为「继承体系中方法重载也是实现多态的一种方式」，笔者对此比较疑惑，因为我总觉得「动态绑定」已将此包括进去了。</p>
<h2 id="synthesize-v-s-dynamic"><a href="#synthesize-v-s-dynamic" class="headerlink" title="@synthesize v.s @dynamic"></a>@synthesize v.s @dynamic</h2><p>引用<a href="http://stackoverflow.com/questions/1160498/synthesize-vs-dynamic-what-are-the-differences" target="_blank" rel="external">stackoverflow: @synthesize vs @dynamic, what are the differences?</a>：</p>
<blockquote>
<p>@synthesize will generate getter and setter methods for your property. @dynamic just tells the compiler that the getter and setter methods are implemented not by the class itself but somewhere else (like the superclass or will be provided at runtime).</p>
</blockquote>
<p>简单来说，<code>@synthesize</code>的作用是：指示编译器，让其在编译期间自动生成getter/setter方法；当有自定义的setter或getter实现时，自定义setter或getter会屏蔽自动生成的setter或getter。不晓得从什么时候开始，Xcode默认帮助合成属性，无需显式使用<code>@synthesize</code>指令。</p>
<p>P.S：根据我的理解，准确来说，<code>@synthesize</code>的作用还包括「自动合成property对应的实例变量」，当然，如果已然有对应的实例变量存在，则会略过。比如说property名为foo，存在一个名为_foo的实例变量，那么就不会再自动合成新变量了。总之，<code>@synthesize</code>是一个帮助省功夫的指令。</p>
<p>P.S：不晓得为什么，当对某个属性同时自定义setter和getter时，XCode要求必须显式书写<code>@synthesize</code>，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UserInfo</span> : <span class="title">NSObject</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div><div class="line">    </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UserInfo</span></span></div><div class="line">    </div><div class="line"><span class="keyword">@synthesize</span> name = _name;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    _name = [name <span class="keyword">copy</span>];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="keyword">return</span> _name;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>而<code>@dynamic</code>告诉编译器，不在编译期自动生成getter/setter方法，setter和getter会在runtime提供。<code>@dynamic</code>的主要应用场景是Core Data，除此之外，在category使用关联属性时也会用到。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-using-afnetworking-part-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/05/using-afnetworking-part-2/" class="article-date">
  	<time datetime="2015-04-04T18:04:32.000Z" itemprop="datePublished">2015-04-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/using-afnetworking-part-2/">AFNetworking使用笔记 第二弹</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>接着<a href="/using-afnetworking-part-1/">AFNetworking使用笔记 第一弹</a>继续写。本文分析两个问题：</p>
<ul>
<li>AFNetworking网络任务的创建是在哪个线程执行的？</li>
<li>网络任务的completion handler在哪一个线程被调用？</li>
</ul>
<h2 id="发送请求消息"><a href="#发送请求消息" class="headerlink" title="发送请求消息"></a>发送请求消息</h2><p>这一部分内容的着重点在于回答「AFNetworking网络任务的创建是在哪个线程执行的？」这个问题。其实这个问题也可以这样问「AFNetworking网络任务的创建是在main thread中完成的吗？」。</p>
<p>开始分析，以<code>AFHTTPSessionManager</code>的POST方法为例，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                    parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                       success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> responseObject))success</div><div class="line">                       failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error))failure</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"POST"</span></div><div class="line">                                                        URLString:URLString</div><div class="line">                                                       parameters:parameters</div><div class="line">                                                          success:success</div><div class="line">                                                          failure:failure];</div><div class="line">    </div><div class="line">    [dataTask resume];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其所作的事情很简单，创建一个<code>NSURLSessionDataTask</code>实例，并将它激活（resume），然后返回它。</p>
<p>进入<code>NSURLSessionDataTask</code>实例创建过程，最终进入如下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                            completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response,</div><div class="line">                                                        <span class="keyword">id</span> responseObject,</div><div class="line">                                                        <span class="built_in">NSError</span> *error))completionHandler</div><div class="line">&#123;</div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), ^&#123;</div><div class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask completionHandler:completionHandler];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然<code>url_session_manager_creation_queue()</code>是关键：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_creation_queue() &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_creation_queue;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        af_url_session_manager_creation_queue =</div><div class="line">        dispatch_queue_create(<span class="string">"com.alamofire.networking.session.manager.creation"</span>,</div><div class="line">                              DISPATCH_QUEUE_SERIAL);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> af_url_session_manager_creation_queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在应该可以得出答案了：</p>
<ul>
<li>根据上述的<code>dataTaskWithRequest:completionHandler:</code>里的代码段<code>dispatch_sync(...)</code>可以知道，创建网络任务的过程是同步完成的；</li>
<li>根据<code>url_session_manager_creation_queue()</code>的实现代码可以知道，创建网络任务的过程是并不是在main thread中完成的；</li>
</ul>
<p>这里分析的是基于POST请求消息的data task，其他task也是差不多，总之，我们可以得出结论，网络任务的创建并不是在main thread中进行的。</p>
<h2 id="处理响应消息"><a href="#处理响应消息" class="headerlink" title="处理响应消息"></a>处理响应消息</h2><p>这一部分内容的着重点在于回答「网络任务的completion handler在哪一个线程被调用？」。</p>
<p>依旧以POST请求消息的响应为例，<code>dataTaskWithHTTPMethod:URLString:parameters:success:failure:</code>方法代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                      parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                                         success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="keyword">id</span>))success</div><div class="line">                                         failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="built_in">NSError</span> *))failure</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *request =</div><div class="line">        [<span class="keyword">self</span>.requestSerializer requestWithMethod:method</div><div class="line">                                    URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString</div><div class="line">                                                      relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString]</div><div class="line">                                   parameters:parameters</div><div class="line">                                        error:&amp;serializationError];</div><div class="line">    <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">        <span class="keyword">if</span> (failure) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(<span class="literal">nil</span>, serializationError);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</div><div class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response,</div><div class="line">                                           <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            <span class="keyword">if</span> (failure) &#123;</div><div class="line">                failure(dataTask, error);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (success) &#123;</div><div class="line">                success(dataTask, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有上述代码可以看到，当构造请求消息失败时，会异步在main thread中调用completionHandler block。</p>
<p>当接收到响应消息时，相应的处理在<code>AFURLSessionManager</code>类的<br><code>URLSession:task:didCompleteWithError:</code>方法中完成，该方法代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</div><div class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</div><div class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</div><div class="line">                <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:[<span class="built_in">NSData</span> dataWithData:<span class="keyword">self</span>.mutableData] error:&amp;serializationError];</div><div class="line">    </div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</div><div class="line">                responseObject = <span class="keyword">self</span>.downloadFileURL;</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            <span class="keyword">if</span> (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</div><div class="line">                    <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</div><div class="line">                &#125;</div><div class="line">    </div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中出现了<code>url_session_manager_processing_queue()</code>方法，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_processing_queue() &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_processing_queue;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        af_url_session_manager_processing_queue = dispatch_queue_create(<span class="string">"com.alamofire.networking.session.manager.processing"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> af_url_session_manager_processing_queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这段代码可以看到，当response出现错误时，AFNetworking会在main thread异步调用completionHandler block；若response没有错误时，就会在异步并行队列中对response进行处理，处理完之后，再在main thread中调用completionHandler block。</p>
<p>总之，请求消息的构建工作是以同步形式在非main thread中进行的；对response的处理是以异步形式在非main thread中处理的；无论是哪个步骤的处理失败和成功，都会在main thread中执行completionHandler block。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AFNetworking/">AFNetworking</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-using-afnetworking-part-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/05/using-afnetworking-part-1/" class="article-date">
  	<time datetime="2015-04-04T18:04:16.000Z" itemprop="datePublished">2015-04-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/using-afnetworking-part-1/">AFNetworking使用笔记 第一弹</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h2><p>归根到底，使用AFNetworking的最终目的无非是处理网络任务，网络任务包括三类：</p>
<ul>
<li>download task</li>
<li>upload task</li>
<li>data task</li>
</ul>
<p>P.S: 上传、下载都比较容易理解，data task是什么玩意儿？上传、下载一般处理的对象主要是文件，而data task处理的对象是文本数据。譬如登录、修改用户昵称，这类操作就是data task。</p>
<p>忽略开发语言以及框架之类的东东，回想一下，启动一个HTTP任务大概需要哪些过程？答案很简单：构建请求消息 – 发送请求消息。</p>
<p><strong>发送请求消息</strong>相对而言比较死板，这一部分往往由框架在底层实现（当然，这一部分也是最复杂的，因为涉及线程神马的）；但是<strong>构建请求消息</strong>相较而言就比较灵活了。</p>
<p>「请求消息」的结构是固定的，包括三个部分：请求行、消息头、消息体。（更多内容参考<a href="/http/">HTTP学习笔记</a>）。</p>
<p>所以无论是什么HTTP任务，万变不离其宗，无非是针对请求行、消息头、消息体进行不同设置和构建。只是在<code>NSURLSession</code>框架里，Apple站在功能的角度做了更进一步的封装，它将request message根据功能封装成download task、upload task、data task。</p>
<p>这3种task分别对应三个类：<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>，它们都是<code>NSURLSessionTask</code>的子类，继承关系如下：</p>
<div class="imagediv" style="width:612px; height:294px"></div>

<p>关于这3种task，《<a href="https://objccn.io/issue-5-4/" target="_blank" rel="external">从NSURLConnection到NSURLSession</a>》有比较清晰的描述：</p>
<blockquote>
<p>当一个<code>NSURLSessionDataTask</code>完成时，它会带有相关联的数据，而一个<code>NSURLSessionDownloadTask</code>任务结束时，它会带回已下载文件的一个临时的文件路径。因为一般来说，服务端对于一个上传任务的响应也会有相关数据返回，所以<code>NSURLSessionUploadTask</code>继承自<code>NSURLSessionDataTask</code>。</p>
</blockquote>
<p>所以，在<code>NSURLSession</code>框架下，启动一个HTTP任务的过程变成了：</p>
<ol>
<li>创建一个<code>NSURLSession</code>实例，并配置之；</li>
<li>创建一个<code>NSURLSessionTask</code>实例，并将之关联到<code>NSURLSession</code>实例中；</li>
<li>激活<code>NSURLSessionTask</code>实例；</li>
</ol>
<p>P.S: 对于单客户单-单服务器，<code>NSURLSession</code>创建一次即可；激活<code>NSURLSessionTask</code>调用其<code>resume</code>方法即可。</p>
<p>所以，在<code>AFHTTPSessionManager</code>中，创建各种HTTP任务流程（参考<a href="https://github.com/AFNetworking/AFNetworking/" target="_blank" rel="external">github:AFNetworking</a>）如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="comment">// 这里没有指定request的方法名，我猜是使用默认方法POST</span></div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask =</div><div class="line">[manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</div><div class="line">    <span class="built_in">NSURL</span> *aDirectoryURL =</div><div class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span></div><div class="line">                                           inDomain:<span class="built_in">NSUserDomainMask</span></div><div class="line">                                  appropriateForURL:<span class="literal">nil</span></div><div class="line">                                             create:<span class="literal">NO</span></div><div class="line">                                              error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [aDirectoryURL URLByAppendingPathComponent:response.suggestedFilename];</div><div class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure>
<p>这段代码中的<code>NSURLRequest</code>对象的创建全部采用默认值，猜测其默认method是POST，在实际应用中，会对<code>NSURLRequest</code>做更多的配置；再就是download task的创建显然不止一种，根据我的理解，基于<code>NSURLSessionDataTask</code>，GET请求消息、POST请求消息都可以完成download task，只是自己要写更多的代码，譬如将download结果从response中取出来。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// data task</span></div><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line">    </div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/upload"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="comment">// 这里没有指定request的方法名，我猜是使用默认方法POST</span></div><div class="line">    </div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *dataTask =</div><div class="line">[manager dataTaskWithRequest:request</div><div class="line">           completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">               <span class="keyword">if</span> (error) &#123;</div><div class="line">                   <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">               &#125;</div><div class="line">&#125;];</div><div class="line">[dataTask resume];</div></pre></td></tr></table></figure>
<p>实际应用中，处理data task时，不会直接像这样写代码，更多的时候会直接使用<code>AFHTTPSessionManager</code>中定义的POST、GET等方法，虽然这些方法的实现和这段代码类似…</p>
<p>Data task和download task相对来说比较简单一些，但upload task就复杂多了。根据复杂程度来看，upload task可以分为<strong>单文件上传</strong>和<strong>多文件上传</strong>。对于前者，相较而言比较简单，直接把要上传的文件作为POST请求消息的消息体即可。对于多文件上传，就复杂得多了。</p>
<p>P.S: 多文件上传并不是很复杂，只要熟读了HTTP相关文档，了解了<code>multipart/form-data</code>相关概念之后，实现多文件上传代码也是挺容易的，关于<code>multipart/form-data</code>，<a href="/http/">HTTP学习笔记</a>有介绍。</p>
<p>先说单文件上传，单文件上传根据文件来源构建<code>NSURLSessionUploadTask</code>对象的方式有这么几种：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 单文件（file路径）上传，进度信息，completion handler</span></div><div class="line">uploadTaskWithRequest:fromFile:progress:completionHandler:</div><div class="line"><span class="comment">// 2. 单文件（file data）上传，进度信息，completion handler</span></div><div class="line">uploadTaskWithRequest:fromData:progress:completionHandler:</div></pre></td></tr></table></figure>
<p>具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单文件（file路径）上传</span></div><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/upload"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *filePath = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.png"</span>];</div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask =</div><div class="line">[manager uploadTaskWithRequest:request</div><div class="line">                      fromFile:filePath</div><div class="line">                      progress:<span class="literal">nil</span></div><div class="line">             completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                 <span class="keyword">if</span> (error) &#123;</div><div class="line">                     <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">                 &#125; <span class="keyword">else</span> &#123;</div><div class="line">                     <span class="built_in">NSLog</span>(<span class="string">@"Success: %@ %@"</span>, response, responseObject);</div><div class="line">                 &#125;</div><div class="line">             &#125;];</div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<p>多文件上传时，需要自行写更多代码构建消息体，具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableURLRequest</span> *request =</div><div class="line">[[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:<span class="string">@"POST"</span></div><div class="line">                                                           URLString:<span class="string">@"http://example.com/upload"</span></div><div class="line">                                                          parameters:<span class="literal">nil</span></div><div class="line">                                           constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;</div><div class="line">                                               [formData appendPartWithFileURL:[<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.jpg"</span>]</div><div class="line">                                                                          name:<span class="string">@"file"</span></div><div class="line">                                                                      fileName:<span class="string">@"filename.jpg"</span></div><div class="line">                                                                      mimeType:<span class="string">@"image/jpeg"</span> error:<span class="literal">nil</span>];</div><div class="line">                                           &#125;</div><div class="line">                                                               error:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">AFURLSessionManager *manager =</div><div class="line">[[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</div><div class="line"><span class="built_in">NSProgress</span> *progress = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask =</div><div class="line">[manager uploadTaskWithStreamedRequest:request</div><div class="line">                              progress:&amp;progress</div><div class="line">                     completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                         <span class="keyword">if</span> (error) &#123;</div><div class="line">                             <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">                         &#125; <span class="keyword">else</span> &#123;</div><div class="line">                             <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">                         &#125;</div><div class="line">                     &#125;];</div><div class="line">    </div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<p>当然，多文件上传代码也可用来实现单文件上传。</p>
<p>本文站在应用的角度对AFNetworking使用进行了简单的描述。但对<code>NSURLSession</code>的阐述不够，希望以后补充吧。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ol>
<li><a href="https://objccn.io/issue-5-4/" target="_blank" rel="external">从NSURLConnection到NSURLSession</a>，这篇文章的作者是Mattt Thompson，也就是AFNetworking的作者</li>
<li><a href="https://github.com/AFNetworking/AFNetworking/" target="_blank" rel="external">AFNetworking使用文档</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AFNetworking/">AFNetworking</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-http" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/04/http/" class="article-date">
  	<time datetime="2015-04-04T07:57:35.000Z" itemprop="datePublished">2015-04-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/04/http/">HTTP学习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>对于程序员而言，HTTP协议是一个非常熟悉的名词。每个人或多或少都对此有所了解。知道它是Web设计、客户端开发等的基础协议。通过它可以让服务器和客户端进行XML、JSON甚至是二进制数据的传输。笔者近期在对之前的程序（iOS项目）的梳理过程中，发现对HTTP协议的了解程度还远远谈不上熟悉，更多的时候是能够凭借网络资源找到某种问题的解决方案，譬如图片的上传与下载，多个文件的上传与下载等等之类的。但是很难从原理层面对这些或有用或无用的信息进行甄别，更谈不上完全独立针对某个网络问题进行合理的程序设计。于是，决定对HTTP相关知识进行一次梳理。</p>
<p>本文的内容只是站在自身的角度，将那些不是特别明白但是可能会经常涉及的知识点进行整理。关于HTTP的更多内容还得看<a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="external">RFC2616文档</a>。</p>
<p>说明：本文会经常出现「客户端」「服务器」「发送端」「接收端」这些概念；就本文而言，「服务端」指的是管理HTTP资源的端点，「客户端」指的是请求HTTP资源的端点；而「发送端」和「接收端」是相对的，譬如客户端发送一个GET请求到服务器，则针对这条消息，客户端是发送端，服务器是接收端；然后服务器返回一个消息给客户端，针对这条响应消息，服务器是发送端，客户端是接收端。</p>
<h2 id="HTTP协议须知"><a href="#HTTP协议须知" class="headerlink" title="HTTP协议须知"></a>HTTP协议须知</h2><p>HTTP，即所谓的超文本传输协议，全称叫<strong>HyperText Transfer Protocol</strong>，是一个客户端和服务端请求和应答的标准（TCP）：</p>
<ul>
<li>HTTP是应用层的协议</li>
<li>HTTP协议是建立在TCP协议之上的协议，后者是传输层的协议</li>
</ul>
<h2 id="HTTP消息概述"><a href="#HTTP消息概述" class="headerlink" title="HTTP消息概述"></a>HTTP消息概述</h2><p>HTTP消息，顾名思义，指的是遵循HTTP协议，客户端和服务端的交流语言（笔者的一家之言，注意，在HTTP协议中，客户端和服务端是相对的，称<strong>请求端</strong>和<strong>应答端</strong>或许更好）。</p>
<p>从方向或应答角度来看，HTTP消息有两种：<strong>请求消息（Request）</strong>、<strong>响应消息（Response）</strong>；</p>
<p>HTTP协议定义了HTTP消息的格式，请求消息和响应消息都由1个开始行（start-line）、0个或多个消息头（headers）、可有可无的消息主体（message-body）组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">generic-message =</div><div class="line">    start-line                 ; 开始行</div><div class="line">    *(message-header CRLF)     ; 消息头</div><div class="line">    CRLF</div><div class="line">    [message-body]             ; 消息主体</div><div class="line">    </div><div class="line">;  其中CRLF表示“结束符”</div><div class="line">;  *表示“0个或多个“”</div><div class="line">;  []表示“可有可无”</div></pre></td></tr></table></figure>
<p>下面将围绕<strong>开始行</strong>、<strong>消息头</strong>、<strong>消息主体</strong>这几个概念进行详细阐述。</p>
<h3 id="开始行"><a href="#开始行" class="headerlink" title="开始行"></a>开始行</h3><p>首先是<strong>开始行</strong>，开始行是什么样的格式？这可不一定，因为对于不同的消息类型（请求消息和响应消息），开始行的格式是不同的：</p>
<ul>
<li>对于请求消息，<strong>start-line</strong>是Request-Line（请求行），请求行的格式后文会介绍；</li>
<li>对于响应消息，<strong>start-line</strong>是Status-Line（状态行），状态行的格式后文会介绍；</li>
</ul>
<h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>然后是<strong>消息头</strong>，根据作用域来分，消息头分为：常用头（general-header）、请求头（request-header）、响应头（response-header）、实体头（entity-header）。无论如何，它们的格式总是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">message-header = field-name &quot;:&quot; [field-value]</div></pre></td></tr></table></figure>
<p>其中<code>field-name</code>对大小写不敏感。</p>
<h3 id="消息主体"><a href="#消息主体" class="headerlink" title="消息主体"></a>消息主体</h3><p>接着是<strong>消息主体</strong>，RFC2616中讲：</p>
<blockquote>
<p>The message-body (if any) of an HTTP message is used to carry the entity-body associated with the request or response.</p>
</blockquote>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">message-body = entity-body | &lt;entity-body encoded as per Transfer-Encoding&gt;</div></pre></td></tr></table></figure>
<p>这是什么意思呢？</p>
<p>HTTP协议中有两个概念非常容易混淆，消息主体（message-body）和实体主体（entity-body）：</p>
<ul>
<li>entity-body可以被理解为客户端想让服务端看到的内容</li>
<li>message-body指的是服务端接收到的（来自于客户端）实际内容</li>
</ul>
<p>二者的区别在于传输过程中可能会对entity-body进行编码；</p>
<p>并非任何<strong>请求消息</strong>或者<strong>响应消息</strong>都可以有<strong>消息主体</strong>这一部分内容。<strong>消息主体</strong>可否存在于某个消息中由<strong>请求类型</strong>和<strong>响应类型</strong>决定的。</p>
<p>P.S: 或许其他资料没有「请求类型」「响应类型」这种说法，不同的<strong>请求类型</strong>在本文的意思是指不同方法的请求，譬如我们熟悉的GET请求、POST请求等；同样，不同的<strong>响应类型</strong>指不同状态码的请求，譬如404响应、403响应、200响应等；</p>
<p><strong>Note:</strong> 对于请求消息，某些情况是不允许包含消息主体的，譬如HEAD请求；对于服务端而言，在处理不允许包含消息主体的请求消息时，应该忽略不理会这些消息的消息主体，哪怕这些消息包含了消息主体。但对于某些允许包含消息主体的请求消息，也可以不包含消息主体，譬如对于POST请求消息，本身是被允许包含消息主体的，但真正发送请求消息时，也可以不包含任何的消息主体。</p>
<p>那么问题来了，服务器如何识别某个可能包含消息主体的请求消息是否真的包含消息主体呢？</p>
<p>根据RFC2616的描述，服务器可以通过两个message-header来判别某个请求消息中是否包含请求主体，这两个message-header分别是Content-Length和Transfer-Encoding，前者记录entity-body的长度，后者记录对entity-body的编码标准。</p>
<p>更细化来看，客户端或者服务器的处理逻辑消息主体的逻辑如下：</p>
<ol>
<li>对于不能包含消息主体的消息（譬如HEAD请求消息、1xx响应消息），完全忽略消息主体，当它不存在；</li>
<li>如果消息中出现「Transfer-Encoding」头，并且其值不是「identity」时：then the transfer-length is defined by use of the “chunked” transfer-coding (section 3.6), unless the message is terminated by closing the connection.<br>P.S: 不太理解这一句，但感觉的意思是，如果所接收到的消息中包含「Transfer-Encoding」头且其值不是「identity」，则计算所接收到消息主体并处理之；</li>
<li>如果消息中出现「Content-Length」头，则认为所接收到的消息主体的长度为Content-Length的值，并且该值也是entity-body的值（即认为entity-body没有进行特别的传输编码）；<br>P.S: 如果entity-body进行了特别的传输编码，千万不要定义「Content-Length」这个header，因为这会让服务器造成误解；<br>P.S: 如果消息中同时包含「Transfer-Encoding」头和「Content-Length」头，则后者会被忽略不处理；</li>
<li>If the message uses the media type “multipart/byteranges”, and the transfer-length is not otherwise specified, then this self-delimiting media type defines the transfer-length. This media type MUST NOT be used unless the sender knows that the recipient can parse it; the presence in a request of a Range header with multiple byte-range specifiers from a 1.1 client implies that the client can parse multipart/byteranges responses<br>P.S: 看不懂！</li>
</ol>
<h2 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h2><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>正如前文所述，对于请求消息，<strong>开始行</strong>被称为<strong>请求行</strong>，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Request-Line = Method SP Request-URL SP HTTP-Version CRLF</div><div class="line">;  </div><div class="line">;  SP表示“分隔符”</div><div class="line">;  CRLF表示“结束符”</div></pre></td></tr></table></figure>
<p>其中，Method包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Method = &quot;OPTIONS&quot;</div><div class="line">         | &quot;GET&quot;</div><div class="line">         | &quot;HEAD&quot;</div><div class="line">         | &quot;POST&quot;</div><div class="line">         | &quot;PUT&quot;</div><div class="line">         | &quot;DELETE&quot;</div><div class="line">         | &quot;TRACE&quot;</div><div class="line">         | &quot;CONNECT&quot;</div><div class="line">         | extension-method</div></pre></td></tr></table></figure></p>
<p>关于Method这部分内容，相对比较熟悉，直接摘抄RFC2616：</p>
<blockquote>
<p>The list of methods allowed by a resource can be specified in an Allow header field (section 14.7). The return code of the response always notifies the client whether a method is currently allowed on a resource, since the set of allowed methods can change dynamically.<br>&nbsp;<br>An origin server SHOULD return the status code 405 (Method Not Allowed) if the method is known by the origin server but not allowed for the requested resource, and 501 (Not Implemented) if the method is unrecognized or not implemented by the origin server.<br>&nbsp;<br>The methods GET and HEAD MUST be supported by all general-purpose servers. All other methods are OPTIONAL;</p>
</blockquote>
<h2 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h2><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>正如前文所述，对于响应消息，<strong>开始行</strong>被称为<strong>状态行</strong>，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</div><div class="line">;  </div><div class="line">;  SP表示“分隔符”</div><div class="line">;  CRLF表示“结束符”</div><div class="line">;  Status-Code表示“状态码”，譬如经典的404</div><div class="line">;  Reason-Phrase表示“状态码的简单文字描述”</div></pre></td></tr></table></figure>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码都是三位数，第一位数（最高位）定义响应类别，第一位有5种值：</p>
<ul>
<li>1xx: Informational - Request received, continuing process</li>
<li>2xx: Success - The action was successfully received, understood, and accepted</li>
<li>3xx: Redirection - Further action must be taken in order to complete the request</li>
<li>4xx: Client Error - The request contains bad syntax or cannot be fulfilled</li>
<li>5xx: Server Error - The server failed to fulfill an apparently valid request</li>
</ul>
<h2 id="实体（entity）"><a href="#实体（entity）" class="headerlink" title="实体（entity）"></a>实体（entity）</h2><p>如果不被请求方法和响应状态码限制，<strong>请求消息</strong>和<strong>响应消息</strong>都可以传输entity。实体包括<strong>实体头</strong>（entity-header）和<strong>实体主体</strong>（entity-body），有些响应只包括实体头（譬如针对HEAD请求的响应）。</p>
<h3 id="实体类型"><a href="#实体类型" class="headerlink" title="实体类型"></a>实体类型</h3><p>实体可能是一个文件，也可能是一段文本，所以必然有一个重要的<strong>属性</strong>用来描述<strong>实体类型</strong>，这个<strong>属性</strong>是<strong>实体头</strong>Content-Type，实体类型比较繁多，譬如.png文件对应的实体类型是<code>image/png</code>，更多Content-Type参考<a href="http://tool.oschina.net/commons" target="_blank" rel="external">这里</a>。</p>
<h2 id="POST、GET、HEAD等方法"><a href="#POST、GET、HEAD等方法" class="headerlink" title="POST、GET、HEAD等方法"></a>POST、GET、HEAD等方法</h2><p>RFC2616对请求消息的方法进行了分类：<strong>安全方法</strong>（Safe Methods）和<strong>幂等方法</strong>（Idempotent Mehtods）。</p>
<p>要理解<strong>安全方法</strong>，先介绍一个概念：副作用，<strong>副作用</strong>指当你发送完一个请求以后，网站上的资源状态没有发生修改，即认为这个请求是无副作用的。比如注册用户这个请求是有副作用的，获取用户详情可以认为是无副作用的。</p>
<p>对于<strong>幂等方法</strong>，<strong>幂等</strong>是说一个请求原封不动的发送N次和M次（N不等于M，N和M都大于1）服务器上资源的状态最终是一致的。比如发贴是非幂等的，重放10次发贴请求会创建10个帖子。但修改帖子内容是幂等的，一个修改请求重放无论多少次，帖子最终状态都是一致的。</p>
<p><strong>请求消息</strong>的方法众多，有些的方法只是读取服务器的资源，有的方法可能会修改服务器的资源。GET和HEAD属于前者，它们只是获取资源，这些方法被称为<strong>安全方法</strong>；POST、PUT、DELETE属于后者，它们可能使服务器的资源发生变化，这些方法被称为<strong>幂等方法</strong>。</p>
<p>P.S: 根据我的理解，所谓的<strong>安全方法</strong>和<strong>幂等方法</strong>只是一种臆想，不是绝对的。举个例子，服务器有某篇文章，现在浏览器通过GET方法获取这篇文章，当然，客户端并没有修改这篇文章，但是，服务器可能做了这样的处理：将这篇文章的浏览次数+1；客观来讲，这个GET方法还是修改了服务器的资源；所以，知道<strong>安全方法</strong>和<strong>幂等方法</strong>这两个概念就好，不必当真。</p>
<h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><p>GET方法的意思是获取被请求URI（Request-URI）指定的信息（以实体的格式）。如果请求URI 涉及到一个数据生成过程，那么这个过程生成的数据应该被作为实体在响应中返回而不是过程的源文本，除非源文本恰好是过程的输出。</p>
<p>如果请求消息包含If-Modified-Since、If-Unmodified-Since、If-Match、If-None-Match或者If-Range头，GET的语义将变成<strong>条件（conditionall）GET</strong>。一个条件GET方法会请求满足条件头域的实体。条件GET方法的目的是为了减少不必要的网络使用，这通过允许利用缓存里仍然保鲜的实体而不用多次请求或传输客户端已经拥有的实体来实现的。</p>
<p>如果请求方法包含一个Range头域，那么GET方法就变成“部分Get”（partial GET）方法。 一个部分GET会请求实体的一部分。部分GET方法的目的是为了减少不必要的网络使用，可以允许客户端从服务器获取实体的部分数据，而不需要获取客户端本地已经拥有的部分实体数据。</p>
<p>P.S: 关键词 – <strong>条件GET</strong>和<strong>部分GET</strong>。</p>
<h3 id="HEAD方法"><a href="#HEAD方法" class="headerlink" title="HEAD方法"></a>HEAD方法</h3><p>除了服务器不能在响应里返回消息主体，HEAD方法和GET方法基本一致。HEAD请求的「响应消息」里的「消息头」应该和GET请求的「响应消息」里的「消息头」一致。此方法被用来获取请求实体的元信息而不需要传输实体主体（entity-body）。此方法经常被用来测试超文本链接的有效性、可访问性以及最近的改变等，对于涉及下载的服务，HEAD方法还用来获取「欲下载文件的大小」。</p>
<h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><p>在实际应用中，GET和POST是用得最多的。相对于GET方法，POST方法在Request-URI所标识的资源后附加新的数据，而GET方法直接将数据放在URI中；此外，POST还可以携带「消息主体」，而GET不成。</p>
<p>简而言之：</p>
<ul>
<li>GET：安全方法，幂等方法，不可包含消息主体</li>
<li>POST：非安全方法」，非幂等方法，可包含消息主体</li>
</ul>
<p>P.S: 更正（2015-08-15），貌似「GET方法不可包含消息主体」的说法不靠谱！</p>
<h3 id="PUT方法"><a href="#PUT方法" class="headerlink" title="PUT方法"></a>PUT方法</h3><p>PUT方法请求服务器去把请求里的实体存储在请求URI（Request-URI）标识下。如果请求 URI（Request-URI）指定的的资源已经在源服务器上存在，那么此请求里的实体应该被当作是源服务器关于此URI所指定资源实体的最新修改版本。如果请求URI（Request-URI）指定的资源不存在，并且此URI被用户代理定义为一个新资源，那么源服务器就应该根据请求里的实体创建一个此URI所标识下的资源。如果一个新的资源被创建了，源服务器必须能向用户代理（user agent）发送201（已创建）响应。如果已存在的资源被改变了，那么源服务器应该发送200（Ok）或者204（无内容）响应。如果资源不能根据请求URI创建或者改变，一个合适的错误响应应该给出以反应问题的性质。实体的接收者不能忽略任何它不理解和不能实现的Content-*（如：Content-Range）头，并且必须返回501（没有被实现）响应。</p>
<p>P.S: 其他方法略过，很少用到。</p>
<div class="imagediv" style="width: 394px; height: 148px"></div>

<h2 id="HTTP和MIME"><a href="#HTTP和MIME" class="headerlink" title="HTTP和MIME"></a>HTTP和MIME</h2><p>最开始HTTP协议是不允许在「消息实体」中挂载二进制文件的，后来逐渐扩展，开始支持MIME协议，这才允许在消息实体中挂载二进制文件，譬如音频、图片等。所以「实体头」Content-Type的很多值MIME-Type中所定义的值。</p>
<h3 id="multipleForm-form-data消息"><a href="#multipleForm-form-data消息" class="headerlink" title="multipleForm/form-data消息"></a>multipleForm/form-data消息</h3><p>经过不断的演化，HTTP协议借鉴并包容了MIME协议，使得HTTP协议能够服务器和客户端之间传输各种文件（文本文件譬如txt文件、二进制文件譬如png文件），具体的处理方式是将这些文件放在<strong>消息主体</strong>中，关于这个上文已有所述。</p>
<p>但是有一个问题：<strong>消息主体中能够承载多个实体（entity）吗</strong>？换句话说，<strong>如果一次HTTP交互涉及多个文件的传输，该如何处理</strong>？</p>
<p>如果只是基于上文所涉及的内容，是没办法做到在一次HTTP消息传输中传输多个文件的。而实现多个文件的传输就得涉及所谓的<code>multipleForm/form-data</code>消息了。</p>
<p>根据HTTP/1.1 RFC2616的协议规定，我们的请求方式只有OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE等，<code>multipart/form-data</code>是个什么东东呢？</p>
<p>对于<code>multipart/form-data</code>，似乎没有找到权威的定义，RFC2616对于它的描述只是出现在<strong>Media Type部分</strong>。根据我的理解，姑且认为<code>multipart/form-data</code>是一种类型的消息主体。</p>
<p>传输<code>multipart/form-data</code>消息主体的基础方法是POST；简单来说，当需要在一次<strong>请求消息</strong>中传输多个文件时，就将着多个文件揉成一个<code>multipart/form-data</code>消息主体，然后以POST形式传到服务器。</p>
<p><code>multipart/form-data</code>消息有啥不同之处呢？</p>
<p>首先是Content-Type不同，其他的HTTP消息的Content-Type可能是<code>image/png</code>、<code>text/plain</code>之类的，但是<code>multipart/form-data</code>消息的Content-Type必须是<code>multipart/form-data</code>。</p>
<p>其次是<code>multipart/form-data</code>的消息主体内嵌了一个或多个其他的消息主体。</p>
<p>举个例子，假设有这么一段HTML代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">FORM</span> <span class="attr">ACTION</span>=<span class="string">"http://server.dom/cgi/handle"</span> <span class="attr">ENCTYPE</span>=<span class="string">"multipart/form-data"</span> <span class="attr">METHOD</span>=<span class="string">POST</span>&gt;</span></div><div class="line">    What is your name? <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">TEXT</span> <span class="attr">NAME</span>=<span class="string">submitter</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">    What files are you sending? <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">FILE</span> <span class="attr">NAME</span>=<span class="string">pics</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></div></pre></td></tr></table></figure>
<p>对应的网页如下：</p>
<div class="imagediv" style="width: 330px; height: 100px"></div>

<p>当用户在姓名输入框中输入「张不坏」，并且选择了一个txt文档file1.txt时，客户端发送的HTTP消息体数据可能如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Content-type: multipart/form-data, boundary=AaB03x</div><div class="line">    </div><div class="line">--AaB03x</div><div class="line">content-disposition: form-data; name=&quot;field1&quot;</div><div class="line">    </div><div class="line">张不坏</div><div class="line">--AaB03x</div><div class="line">content-disposition: form-data; name=&quot;pics&quot;; filename=&quot;file1.txt&quot;</div><div class="line">Content-Type: text/plain</div><div class="line">  ... contents of file1.txt ...</div><div class="line">--AaB03x--</div></pre></td></tr></table></figure>
<p>可以看到，这个示例中涉及两个entity的传输：</p>
<ul>
<li>Content-Type为默认值的文本框输入值</li>
<li>Content-Type为<code>text/plain</code>的纯文本文件</li>
</ul>
<p>P.S: 这里若可以用HTTP协议分析工具分析一下最好了。</p>
<p>关于<code>multipart/form-data</code>消息体，还往往涉及boundary之类的更多概念，本文就不针对这个详述了。</p>
<p>还会经常有一种<code>Content-Type</code>值为<code>multipart/mixed</code>，笔者一度在<code>multipart/form-data</code>和<code>multipart/mixed</code>之间傻傻分不清楚。对于上述示例中“What files are you sending?”之后的文件选择按钮，当选择多个文件时（譬如keynote文件，事实上这个“文件是一个文件包”，它由多个文件组成），则该entity对应的Content-Type是<code>multipart/mixed</code>，表示该form entry对应多个文件，RFC1867的描述如下：</p>
<blockquote>
<p>If multiple files are to be returned as the result of a single form<br>entry, they can be returned as multipart/mixed embedded within the multipart/form-data.</p>
</blockquote>
<p>但无论如何，<code>multipart/mixed</code>消息体都是嵌套在<code>multipart/form-data</code>内部的子消息体。</p>
<p>P.S: <code>multipleForm/form-data</code>消息这一部分内容的叙述不够详细，有时间还是使用HTTP报文分析工具进行更加详细的分析吧。</p>
<h2 id="一些常见问题"><a href="#一些常见问题" class="headerlink" title="一些常见问题"></a>一些常见问题</h2><p>上文是对HTTP协议的基本描述，这一部分列举一些常见Q/A，结合Q/A，会对HTTP协议有更深刻的理解。</p>
<p>Q: POST方法一般将参数放在消息体中，那么其Content-Type是什么？<br>A: 初步判断，一般是<code>application/json</code>。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ol>
<li>HTTP协议RFC2616文档（能够找到中文翻译版，我参考的是“孙超进”翻译版本，感谢他的贡献，但感觉翻译得不是很好）；</li>
<li>RFC2046，MIME协议part2，定义了Media Types；</li>
<li>RFC1867，Form-based File Upload in HTML；</li>
<li>《<a href="http://blog.csdn.net/five3/article/details/7181521" target="_blank" rel="external">HTTP协议之multipart/form-data请求分析</a>》；</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Others/">Others</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/9/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/11/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>