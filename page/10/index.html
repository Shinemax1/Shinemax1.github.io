<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/10/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.67px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 15px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 18.33px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.67px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 20px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 13.33px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 16.67px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.67px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/Transition/" style="font-size: 13.33px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，Android开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-using-gcd-part-3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/01/using-gcd-part-3/" class="article-date">
  	<time datetime="2015-02-01T05:53:40.000Z" itemprop="datePublished">2015-02-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/01/using-gcd-part-3/">GCD实践（三）使用dispatch_once来执行只需运行一次的线程安全代码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>单例模式（singleton）对Objective-C开发者而言并不陌生，常见的实现方式为：在类编写名为<code>sharedInstance</code>的方法，该方法只会返回全类共用的单例实例，而不会在每次调用时都创建新的实例。假设有一个类叫<code>TestClass</code>，那么这个共享实例一般会这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)sharedInstance &#123;</div><div class="line">    <span class="keyword">static</span> TestClass *sharedInstance = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!sharedInstance) &#123;</div><div class="line">            sharedInstance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单例模式很容易引起激励讨论，Objective-C的单例尤其如此。线程安全是大家争论的主要问题。为了保证线程安全，上述代码将创建单例实例的代码包裹在<strong>同步块</strong>里。无论是好是坏，反正这种实现方式很常用，这样的代码也随处可见。</p>
<p>不过，GCD引入了一项特性，能使单例实现起来更加容易。所用的函数是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="built_in">dispatch_once</span>(<span class="built_in">dispatch_once_t</span> *token, dispatch_block_t block);</div></pre></td></tr></table></figure>
<p>此函数接受类型为<code>dispatch_once_t</code>的特殊参数，称其为<strong>标记</strong>（token），此外还接受block参数，对于给定token来说，该函数保证相关的block必定会执行，且仅执行一次。首次调用该函数时，必然会执行block的代码，最重要的一点在于，此操作完全是线程安全的。请注意，对于只需执行一次的块来说，每次调用函数时传入的token都必须是完全相同的。因此，开发者通常将标记变量声明在<code>static</code>或<code>global</code>作用域里。</p>
<p>上述实现单例模式所用的<code>sharedInstance</code>方法，可以用此函数来改写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)sharedInstance &#123;</div><div class="line">    <span class="keyword">static</span> TestClass *sharedInstance;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;   <span class="comment">// typedef long dispatch_once_t;</span></div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用<code>disptch_once</code>可以简化代码并且彻底保证线程安全，开发者根本无须担心加锁或同步。所有问题都由GCD在底层处理。由于每次调用时都必须使用完全相同的token，所以token要声明成<code>static</code>。把该变量定义在<code>static</code>作用域中，可以保证编译器在每次执行<code>sharedInstance</code>方法时都会复用这个变量，而不会创建新变量。</p>
<p>此外，<code>dispatch_once</code>更高效。它没有使用重量级的同步机制，若是那样做的话，每次运行代码前都要获取锁，相反，此函数采用原子访问（atomic access）来查询标记，以判断其所对应的代码原来是否已经执行过。《Effective Objective-C 2.0》的作者在装有64位的Mac OS X 10.8.2系统的电脑上简单测试了性能，分别采用<code>@synchronized</code>方式及<code>dispatch_once</code>方式来实现<code>sharedInstance</code>，结果显示，后者的速度几乎是前者的2倍。</p>
<p>总结：</p>
<ol>
<li>经常需要编写<strong>只需执行一次的线程安全代码</strong>（thread-safe single-code execution），通过GCD提供的<code>dispatch_once</code>函数，很容易就能实现此功能。</li>
<li>token应该声明在<code>static</code>或<code>global</code>中，这样的话，在把只需一次执行的块传给<code>dispatch_once</code>函数时，传进去的标记也是相同的。</li>
</ol>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://book.douban.com/subject/21370593/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD/">GCD</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-using-gcd-part-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/28/using-gcd-part-2/" class="article-date">
  	<time datetime="2015-01-28T05:53:22.000Z" itemprop="datePublished">2015-01-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/28/using-gcd-part-2/">GCD实践（二）少用performSelector系列方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文几乎全部参考《Effective Objective-C 2.0》 Item 42。</p>
<h2 id="performSelector介绍"><a href="#performSelector介绍" class="headerlink" title="performSelector介绍"></a>performSelector介绍</h2><p>Objective-C本质上是一门非常动态的语言，<code>NSObject</code>定义了几个方法，令开发者可以随意调用任何方法。这几个方法可以推迟执行方法调用，也可以指定运行方法所用的线程。这些功能在出现GCD之前非常有用。</p>
<p>这其中最简单的是<code>performSelector:(SEL)selector</code>。该方法与直接调用选择子等效。所以下面两行代码的执行效果相同：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[object performSelector:<span class="keyword">@selector</span>(selectorName)];</div><div class="line">[object selectorName];</div></pre></td></tr></table></figure>
<p>这种方法看上去似乎有些多余。如果某个方法只是这么来调用的话，那么此方式确实多余，然而，如果selector是在running time才决定的，那么就能体现出此方式的强大之处了。这就等于在动态绑定之上再次使用动态绑定，因而可以实现出下面这种功能：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SEL selector;</div><div class="line"><span class="keyword">if</span> ( <span class="comment">/* some condition */</span> ) &#123;</div><div class="line">    selector = <span class="keyword">@selector</span>(foo);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/* some other condition */</span> ) &#123;</div><div class="line">    selector = <span class="keyword">@selector</span>(bar);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    selector = <span class="keyword">@selector</span>(baz);</div><div class="line">&#125;</div><div class="line">    </div><div class="line">[object performSelector:selector];</div></pre></td></tr></table></figure>
<p>这种编程方式极为灵活，经常可用来简化复杂的代码。还有一种用法，即时先把选择子保存起来，等某个事件发生之后再调用。不管哪种用法，编译器都不知道要执行的选择子是什么，者必须到了运行期才能确定。然而，使用此特性的代价是，如果在ARC下编译代码，那么编译器会发出如下警示信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">warningL performSelector may casue a leak because its selector</div><div class="line">is unknown [-Warc-performSelector-leaks]</div></pre></td></tr></table></figure>
<p>你可能没料到会出现这种警告。要是早就料到了，那么也许应该已经知道使用这些方法为何要小心了。这条消息看上去可能比较奇怪，而且令人纳闷：为什么其中会提到内存泄漏问题呢？只不过是用<code>performSelector:</code>调用了一个方法。原因在于，编译器并不知道将要调用的selector是什么，因此，也就不了解其方法签名及返回值，甚至连是否有返回值都不清楚。而且，由于编译器不知道方法名，所以就没办法用ARC的内存管理规则来判定返回值是不是该释放。鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作。然而，这么做可能导致内存泄漏，因为方法在返回对象时已经将其保留了。</p>
<p>这段话不是很容易懂，下面这段代码应该有助于理解：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">SEL selector;</div><div class="line"><span class="keyword">if</span> ( <span class="comment">/* some condition */</span> ) &#123;</div><div class="line">    selector = <span class="keyword">@selector</span>(newObject);</div><div class="line">    <span class="comment">// newObject返回一个new object</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/* some other condition */</span> ) &#123;</div><div class="line">    selector = <span class="keyword">@selector</span>(<span class="keyword">copy</span>);</div><div class="line">    <span class="comment">// copy根据当前object copy出一个新的object</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    selector = <span class="keyword">@selector</span>(someProperty));</div><div class="line">    <span class="comment">// someProperty可以认为是对象的某个property</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">id</span> ret = [object performSelector:selector];</div></pre></td></tr></table></figure>
<p>此代码与刚才那个例子有所不同，以便展示问题所在，如果调用的是前两个选择子之一，那么ret对象应由这段代码来释放，而如果是第三个选择子，则无需释放。如果不使用ARC（此时编译器也不发出警告信息了），那么前两种情况下需要手动释放ret对象，而后一种不需要释放。如果使用ARC，则ARC应该帮忙处理这些事情，但是目前来说ARC是很难解决这个问题的，正如上文所述，其采取的是谨慎的做法：不添加释放操作，这就给程序带来了内存泄漏的可能。</p>
<p>显然，这已然是performSelector的一大缺点（或说这是performSelector系列函数的一个坑吧）了。这个问题很容易被忽视，而且就算用静态分析器，也很难侦测到随后的内存泄漏。</p>
<p>performSelector系列的方法之所以要谨慎使用，这就是其中一个原因。</p>
<p>performSelector的另一个局限在于：返回值只能是<code>void</code>或对象类型（<code>id</code>类型）。如果想返回整数或浮点数等scalar类型值，那么就需要执行一些复杂的转换操作，而这种转换操作很容易出错。由于<code>id</code>类型表示指向任意Objective-C对象的指针，所以从技术上来讲，只要返回的大小和指针所占大小相同就行，也就是说，在32位架构的计算机上，可以返回任意32位大小的类型；而在64位架构的计算机上，则可以返回任意64位大小的类型。除此之外，还可以返回<code>NSNumber</code>进行转换…若返回的类型为C语言结构体，则不可使用performSelector方法。</p>
<h2 id="多用GCD，少用performSelector系列方法"><a href="#多用GCD，少用performSelector系列方法" class="headerlink" title="多用GCD，少用performSelector系列方法"></a>多用GCD，少用performSelector系列方法</h2><p>performSelector系列方法中有某些方法可以被GCD代替。</p>
<p>performSelector还有如下几个版本，可以在发消息时顺便传递参数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)object;</div><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)object1 withObject:(<span class="keyword">id</span>)object2;</div></pre></td></tr></table></figure>
<p>比方说，可以用下面这两个版本来设置对象中名为value的属性值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> object = <span class="comment">/* an object with a property called value */</span></div><div class="line"><span class="keyword">id</span> newValue = <span class="comment">/* new value for the property */</span></div><div class="line">[object performSelector:<span class="keyword">@selector</span>(setValue:) withObject:newValue];</div></pre></td></tr></table></figure>
<p>这些方法貌似有用，但是局限颇多！由于参数类型是<code>id</code>，所以传入的参数必须是对象才行。如果选择子所接受的参数是整数或浮点数，那就不能采用这些方法了。此外，选择子最多只能接受两个参数，也就是调用<code>performSelector:withObject:withObject:</code>这个版本。在参数不止两个的情况下，则没有对应的performSelector方法能够执行这种选择子。</p>
<p>performSelector系列方法还有两个功能，就是可以延后执行选择子，或将选择子放在另一个线程上执行。下面列出此方法中一些更为常用的版本：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</div><div class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</div><div class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</div></pre></td></tr></table></figure>
<p>当然，这几个方法还有一两个别的变种，这里就略过了。然而，很快就会发现，这些方法太过局限了。例如，具备延后功能的那些方法无法处理带有两个参数的选择子。而能够指定执行线程的哪些方法，则与之类似，所以也不是特别通用。如果要用这些方法，就得把很多参数打包到字典中，然后在被调用的方法中将这些参数提取出来，这样会增加开销，同时也提高了产生bug的可能性。</p>
<p>如果改用替代方案GCD，那么就不受这些限制了。</p>
<p>performSelector系列方法所提供的线程功能，可以通过GCD机制中的块来实现；performSelector系列方法所提供的延后执行功能，也可以用<code>dispatch_after</code>来实现，在另一个线程上执行任务则可通过<code>dispatch_async</code>和<code>dispatch_sync</code>来实现。</p>
<p>例如，要延后执行某项任务，可以有下面两种方式实现，而我们应该优先考虑第二种：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// using performSelector:withObject:afterDelay:</span></div><div class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(doSomething:) withObject:<span class="literal">nil</span> afterDelay:<span class="number">5.0</span>]</div><div class="line"></div><div class="line"><span class="comment">// using dispatch_after</span></div><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5.0</span> * <span class="built_in">NSEC_PER_SEC</span>));</div><div class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</div><div class="line">    [<span class="keyword">self</span> doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>想把任务放在主线程上执行，也可以有下面两种方式，而我们还应该优先选择后者：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// using performSelectorOnMainThread:withObject:waitUntilDone:</span></div><div class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(doSomething) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</div><div class="line">    </div><div class="line"><span class="comment">// using dispatch_async</span></div><div class="line"><span class="comment">// (or if waitUntilDone is YES, then dispatch_sync)</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">    [<span class="keyword">self</span> doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>performSelector系列方法在内存管理上容易有缺失，它无法确定将要执行的选择子是什么，因而ARC编译器也无法插入适当的内存管理方法，这是一个大坑，使用GCD则不存在这个问题。</li>
<li>performSelector系列方法能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都受到限制，不过GCD似乎也没有比较好的解决方法（或许只是笔者不知道）；</li>
<li>如果想把任务放在另外一个线程上执行，或者想延时执行某个任务，最好应该把任务封装到block中，然后调用GCD的相关方法来实现。</li>
</ol>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://book.douban.com/subject/21370593/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD/">GCD</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-copy-in-objective-c" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/28/copy-in-objective-c/" class="article-date">
  	<time datetime="2015-01-28T01:14:48.000Z" itemprop="datePublished">2015-01-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/28/copy-in-objective-c/">Objective-C copy那些事儿</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Objective-C中的copy相关内容比我想象中要丰富多了。</p>
<h2 id="NSCopying和NSMutableCopying协议"><a href="#NSCopying和NSMutableCopying协议" class="headerlink" title="NSCopying和NSMutableCopying协议"></a>NSCopying和NSMutableCopying协议</h2><p>使用对象时经常需要拷贝它。在Objective-C中，此操作是通过<code>copy</code>和<code>mutableCopy</code>方法完成的，基类<code>NSObject</code>中与copy相关的API如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)<span class="keyword">copy</span>;</div><div class="line">- (<span class="keyword">id</span>)mutableCopy;</div><div class="line">    </div><div class="line">+ (<span class="keyword">id</span>)copyWithZone:(<span class="keyword">struct</span> _NSZone *)zone OBJC_ARC_UNAVAILABLE;</div><div class="line">+ (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="keyword">struct</span> _NSZone *)zone OBJC_ARC_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>显然，<code>NSObject</code>已经实现了<code>copy</code>和<code>mutableCopy</code>方法。</p>
<p>如果想让自己的类（继承自<code>NSObject</code>，假设叫<code>CustomClass</code>）支持拷贝操作，该怎么弄呢？第一个想到的处理方式恐怕是重写<code>copy</code>方法（暂时不谈<code>mutableCopy</code>，稍后再叙）。</p>
<p>但是，这种做法是错误的。</p>
<p>正确的做法是让自定义类遵循<code>NSCopying</code>协议（<code>NSObject</code>并未遵循该协议），该协议只有一个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSCopying</span></span></div><div class="line">    </div><div class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>简单来说，当对某个对象发送<code>copy</code>消息时，<code>NSObject#copy</code>的实现逻辑会去自动调用<code>copyWithZone:</code>方法，有点回调的感觉；因此，若想支持拷贝操作，需要在自定义类中让其支持<code>NSCopying</code>，即实现<code>copyWithZone:</code>方法，而不是重写<code>copy</code>方法。</p>
<p>参数<code>zone</code>是什么鬼？这是因为在以前开发程序时，会把内存分为不同的<strong>区</strong>（zone），而对象会创建在某个区里面。现在不用了，每个程序只有一个区：默认区（default zone）。所以说，尽管必须实现<code>copyWithZone:</code>方法，但是不必担心其中的zone参数。</p>
<p>举个栗子，有个表示个人信息的类，可以在其接口定义中声明此类遵循<code>NSCopying</code>协议，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UserInfo</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line">    </div><div class="line">- (<span class="keyword">instancetype</span>)initWithFirstName:(<span class="built_in">NSString</span> *)firstName</div><div class="line">                      andLastName:(<span class="built_in">NSString</span> *)lastName;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div><div class="line">    </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UserInfo</span></span></div><div class="line">    </div><div class="line">- (<span class="keyword">instancetype</span>)initWithFirstName:(<span class="built_in">NSString</span> *)firstName</div><div class="line">                      andLastName:(<span class="built_in">NSString</span> *)lastName &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        _firstName = [firstName <span class="keyword">copy</span>];</div><div class="line">        _lastName = [lastName <span class="keyword">copy</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">#pragma mark - NSCopying</span></div><div class="line">    </div><div class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</div><div class="line">    UserInfo *<span class="keyword">copy</span> = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] initWithFirstName:_firstName</div><div class="line">                                                              andLastName:_lastName];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">copy</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>再来讲一下<code>mutableCopy</code>方法和<code>NSMutableCopying</code>协议；它们俩与<code>copy</code>方法和<code>NSCopying</code>协议相对应。当你的类还有mutable版本时，你还应该遵循<code>NSMutableCopying</code>协议，并实现<code>mutableCopyWithZone:</code>方法，这样，当向该类对象发送<code>mutableCopy</code>消息时，NSObject的<code>mutableCopy</code>方法实现代码中会回调你的<code>mutableCopyWithZone:</code>方法。</p>
<p><strong>Note:</strong> 虽然在自定义<code>copyWithZone:</code>和<code>mutableCopyWithZone:</code>中可以弄各种花样，但是务必保证如下逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[CustomClass copy] -&gt; CustomClass</div><div class="line">// 向immutable对象发送copy消息，得到一个immutable对象</div><div class="line"></div><div class="line">[MutableCustomClass copy] -&gt; CustomClass</div><div class="line">// 向mutable对象发送一个copy消息，得到一个immutable对象</div><div class="line"></div><div class="line">[CustomClass mutableCopy] -&gt; MutableCustomClass</div><div class="line">// 向immutable对象发送mutableCopy消息，得到mutable对象</div><div class="line"></div><div class="line">[MutableCustomClass mutableCopy] -&gt; MutableCustomClass</div><div class="line">// 向mutable对象发送mutableCopy消息，得到mutable对象</div></pre></td></tr></table></figure>
<p>下一个问题：向immutable对象发送<code>copy</code>消息一定会得到一个新对象吗？</p>
<p>No！下面的测试栗子所做的事情是分别向不可变的<code>NSString</code>、<code>NSArray</code>、<code>NSDictionary</code>以及<code>NSSet</code>对象发送<code>copy</code>消息，得到几个新的对象，新对象显然是immutable的，问题是：这些新对象真的是<strong>新</strong>对象吗？如下栗子分别把新老对象的地址给打印出来：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *testString = <span class="string">@"1"</span>;</div><div class="line"><span class="built_in">NSString</span> *copyString = [testString <span class="keyword">copy</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"testString address = %x"</span>, testString);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"copyString address = %x"</span>, copyString);</div><div class="line"><span class="comment">// print:</span></div><div class="line"><span class="comment">// testString address = 79720cc0</span></div><div class="line"><span class="comment">// copyString address = 79720cc0</span></div><div class="line">    </div><div class="line"><span class="built_in">NSArray</span> *testArray = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>];</div><div class="line"><span class="built_in">NSArray</span> *copyArray = [testArray <span class="keyword">copy</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"testArray address = %x"</span>, testArray);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"copyArray address = %x"</span>, copyArray);</div><div class="line"><span class="comment">// print:</span></div><div class="line"><span class="comment">// testArray address = 79722fb0</span></div><div class="line"><span class="comment">// copyArray address = 79722fb0</span></div><div class="line">    </div><div class="line"><span class="built_in">NSDictionary</span> *testDictionary = @&#123;@<span class="number">1</span>:@<span class="number">2</span>&#125;;</div><div class="line"><span class="built_in">NSDictionary</span> *copyDictionary = [testDictionary <span class="keyword">copy</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"testDictionary address = %x"</span>, testDictionary);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"copyDictionary address = %x"</span>, copyDictionary);</div><div class="line"><span class="comment">// print:</span></div><div class="line"><span class="comment">// testDictionary address = 79722fd0</span></div><div class="line"><span class="comment">// copyDictionary address = 79722fd0    </span></div><div class="line">    </div><div class="line"><span class="built_in">NSSet</span> *testSet = [<span class="built_in">NSSet</span> setWithObject:@<span class="number">1</span>];</div><div class="line"><span class="built_in">NSSet</span> *copySet = [testSet <span class="keyword">copy</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"testSet address = %x"</span>, testSet);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"copySet address = %x"</span>, copySet);</div><div class="line"><span class="comment">// print:</span></div><div class="line"><span class="comment">// testSet address = 79722ff0</span></div><div class="line"><span class="comment">// copySet address = 79722ff0</span></div></pre></td></tr></table></figure>
<p>答案很明了！<code>NSString</code>、<code>NSArray</code>、<code>NSDictionary</code>以及<code>NSSet</code>，这是我们最常用的四个含有mutable版本的类型；向这些类型的immutable对象发送<code>copy</code>消息，这些对象会直接返回本身，而不是返回一个新创建的对象。</p>
<p>关于这一点，我反复使用各种姿势测试了很多次，均得到这样的结果；但是目前还没能找到比较权威的说法对这个现象进行说明。不过想想也很容易理解，对于一个immutable对象，真的没必要再复制一个，毕竟其中的内容不会发生改变，如果复制了，那么内存中将会存在两个一模一样的资源，岂不浪费？</p>
<p>总结这一段内容的要点如下：</p>
<ul>
<li>若想令自己的类具备拷贝功能，则需要遵循<code>NSCopying</code>协议，实现其定义的<code>copyWithZone:</code>方法；</li>
<li>若自定义的类分为immutable和mutable版本，则需要同时遵循<code>NSCopying</code>和<code>NSMutableCopying</code>协议；</li>
<li>向immutable对象发送<code>copy</code>消息，并不一定会得到一个新对象；</li>
</ul>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>在很长时间里，我都认为<strong>浅拷贝</strong>（shallow copy）指的是「指针拷贝」，而<strong>深拷贝</strong>（deep copy）才是真正copy一个对象；显然，这种说法是不正确的。</p>
<p>一般来说，「深拷贝」和「浅拷贝」这两个概念是分析集合类型才会谈及的。深拷贝的意思是：在拷贝对象时，将其底层数据也一并复制过去。<strong>Foundation框架中所有集合类型在默认情况下都执行浅拷贝，也就是说，只拷贝容器对象本身，而不复制其中数据。这样做的原因在于，容器内的对象未必能拷贝，而且调用者也未必想在拷贝容器时一并拷贝其中每一个对象。</strong></p>
<p>深拷贝和浅拷贝对比图如下：</p>
<div class="imagediv" style="width: 560px; height: 280px"></div>

<h2 id="理解-property中的copy修饰符"><a href="#理解-property中的copy修饰符" class="headerlink" title="理解@property中的copy修饰符"></a>理解@property中的copy修饰符</h2><p>经常看到@property中有些对象类型属性被<code>strong</code>修饰，有些被<code>copy</code>修饰。<code>strong</code>修饰符的作用不消多说，该如何理解<code>copy</code>修饰符呢？</p>
<p>关于@property中<code>copy</code>修饰符的使用，我曾经历了这么两个阶段：</p>
<ol>
<li>使用<code>copy</code>修饰mutable类型，使用<code>strong</code>修饰immutable类型；</li>
<li>使用<code>copy</code>修饰immutable类型，使用<code>strong</code>修饰mutable类型；</li>
</ol>
<p>关于第1个阶段，我忘记了当时是怎么想的，它显然是错的；</p>
<p>关于第2个阶段，我之所以有这样的认识是因为曾在<a href="http://stackoverflow.com/questions/387959/nsstring-property-copy-or-retain" target="_blank" rel="external">stackoverflow</a>中看到了如下这么一段说明：</p>
<blockquote>
<p>For attributes whose type is an immutable value class that conforms to the <code>NSCopying</code> protocol, you almost always should specify <code>copy</code> in your <code>@property</code> declaration. Specifying retain is something you almost never want in such a situation.</p>
</blockquote>
<p>这句话错了吗？当然没有，要不也不会得到这么多的votes。但为什么这么说呢？不晓得是当时没耐心还是咋地，反正没怎么思考这个问题。</p>
<p>接着以上文提到的<code>UserInfo</code>为栗子，对之进行简化，只是定义两个<code>NSString</code>属性：<code>firstName</code>和<code>lastName</code>，作为对比前者使用<code>copy</code>修饰，后者使用<code>strong</code>修饰。如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UserInfo</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line">    </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>基于<code>UserInfo</code>创建实例进行测试：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableString</span> *mutableFirstName = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"张"</span>];</div><div class="line"><span class="built_in">NSMutableString</span> *mutableLastName = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"不坏"</span>];</div><div class="line">    </div><div class="line">UserInfo *u = [[UserInfo alloc] init];</div><div class="line">u.firstName = mutableFirstName;</div><div class="line">u.lastName  = mutableLastName;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"全名：%@%@"</span>, u.firstName, u.lastName);</div><div class="line"><span class="comment">// print: 全名：张不坏</span></div><div class="line">    </div><div class="line"><span class="comment">// 改mutableFirstName「张」为「长孙」</span></div><div class="line">[mutableFirstName deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>)];</div><div class="line">[mutableFirstName appendString:<span class="string">@"长孙"</span>];</div><div class="line"><span class="comment">// 改mutableLastName「不坏」为「不坏蛋」</span></div><div class="line">[mutableLastName appendString:<span class="string">@"蛋"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"全名：%@%@"</span>, u.firstName, u.lastName);</div><div class="line"><span class="comment">// print: 全名：张不坏蛋</span></div></pre></td></tr></table></figure>
<p>简单来说，对于immutable对象类型属性，假设该类型存在mutable版本，若使用<code>strong</code>修饰该属性，则将会是不安全的。</p>
<p>在上述代码中，<code>u.lastName</code>被<code>strong</code>修饰，对之赋值一个mutable类型<code>mutableLastName</code>，之后改变<code>mutableLastName的</code>值（由「不坏」变为「不坏蛋」），显然也影响到了<code>u.lastName</code>的值，这通常是我们所不希望发生的；作为对比，<code>u.firstName</code>被<code>copy</code>修饰，也为之赋值mutable类型<code>mutableFirstName</code>，之后也改变<code>mutableFirstName</code>的值（由「张」变为「长孙」），但是<code>u.firstName</code>不受影响。</p>
<p>再往深一点看：<code>@property</code>的<code>copy</code>的作用机制是什么？根据我的理解，<code>copy</code>修饰符的意义有两点：</p>
<ol>
<li>在系统自动合成属性的setter提供「指示」，使用类似于<code>_iVar = [var copy];</code>的方式进行赋值；</li>
<li>告诉使用者，安心的使用吧！</li>
</ol>
<p>因此，根据我的理解，系统合成UserInfo的firstName和lastName的setter代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setFirstName:(<span class="built_in">NSString</span> *)firstName &#123;</div><div class="line">    _firstName = [firstName <span class="keyword">copy</span>];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (<span class="keyword">void</span>)setLastName:(<span class="built_in">NSString</span> *)lastName &#123;</div><div class="line">    _lastName = lastName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写到这里，可以回答一个常见的问题了：<strong>如何重写带copy关键字的setter？</strong></p>
<p>换句话说，即便<code>firstName</code>属性被<code>copy</code>修饰，但是如果重写setter时采用错误的方式，<code>copy</code>带来的好处会荡然无存。譬如这样重写<code>setFirstName:</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setFirstName:(<span class="built_in">NSString</span> *)firstName &#123;</div><div class="line">    _firstName = firstName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>得到的结果如下（显然，<code>firstName</code>也是不安全的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">全名：张不坏</div><div class="line">全名：长孙不坏蛋</div></pre></td></tr></table></figure>
<p>继续深挖：</p>
<ol>
<li>是不是所有遵循<code>NSCopying</code>类型属性都应该使用<code>copy</code>修饰呢？</li>
<li>mutable类型属性可以使用<code>copy</code>修饰吗？</li>
</ol>
<p>对于第一个问题，答案是No！对于向<code>NSString</code>、<code>NSDictionary</code>等属性才需要使用<code>copy</code>修饰，因为它们存在mutable版本，在为属性赋值时，右值很可能是它们的mutable类型对象，若使用<code>strong</code>修饰则会带来不稳定因子；另外一个方面，如果属性类型不存在对应的mutable版本，则完全不用担心这点，反正你也无法在外部修改它，不稳定因子自然不存在了。</p>
<p>对于第二个问题，答案仍然是No！被修饰符<code>copy</code>修饰的属性，默认的setter赋值方式是<code>_iVar = [var copy];</code>而<code>copy</code>方法返回的是immutable类型，将immutable对象赋值给mutable类型指针显然是不对的。</p>
<p>P.S：如果存在<code>mutableCopy</code>修饰符，或许可以使用<code>mutableCopy</code>修饰mutable属性^_^</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li>《Effective Objective-2.0》</li>
<li><a href="http://stackoverflow.com/questions/387959/nsstring-property-copy-or-retain" target="_blank" rel="external">NSString: copy还是retain</a></li>
<li><a href="http://www.objc.io/issue-7/value-objects.html" target="_blank" rel="external">Value Objects</a></li>
<li><a href="http://objccn.io/issue-7-2/" target="_blank" rel="external">值对象</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-using-gcd-part-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/26/using-gcd-part-1/" class="article-date">
  	<time datetime="2015-01-26T13:49:05.000Z" itemprop="datePublished">2015-01-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/26/using-gcd-part-1/">GCD实践之（一）使用GCD保护property</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>作为一个iOS开发者，必须要熟练使用GCD，本文是站在实际应用的角度总结GCD的用法之一：使用barrier保护property。</p>
<p>在多线程环境下，如果有多个线程要执行同一份代码，那么有时会出现问题，为了保证某些资源操作的可控性，需要一些手段来对这些公共资源进行保护，无论是什么语言，只要支持多线程，都得面临这个问题，即所谓的<strong>线程同步</strong>问题。本文围绕property讨论各种<strong>同步工具</strong>的保护效果，这同样可以延伸到其他需要保护的公共资源上。</p>
<h2 id="atomic保护property"><a href="#atomic保护property" class="headerlink" title="atomic保护property"></a>atomic保护property</h2><p>维持property原子操作的最简单的保护措施是为其添加<code>atomic</code>修饰词，这样编译器在为其生成setter和getter时对其进行原子保护。问题来了，对于使用<code>atomic</code>修饰的property，编译器为其生成的getter和setter是什么样子的呢？在很长时间里，由于受到不靠谱网友的误导，以为是这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    &#123;lock&#125;        <span class="comment">// 上锁</span></div><div class="line">    _ret = _name; <span class="comment">// get name</span></div><div class="line">    &#123;unlock&#125;      <span class="comment">// 释放锁</span></div><div class="line">    <span class="keyword">return</span> _ret;  <span class="comment">// 返回</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)newName &#123;</div><div class="line">    &#123;lock&#125;        <span class="comment">// 上锁</span></div><div class="line">    &#123;set name&#125;    <span class="comment">// set name</span></div><div class="line">    &#123;unlock&#125;      <span class="comment">// 释放锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看来认真看了Apple官方文档<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a>，意识到这种说法是错误的。Apple的原子操作的底层实现并不是基于锁的，具体是什么样子呢？我也不知道，但肯定不是如上这样的（以后有时间深入了解一下，希望能够找到答案吧）。</p>
<p>那么修饰词<code>atomic</code>靠谱吗？它能保证相关属性getter和setter的原子性吗？能信赖它吗？</p>
<p>根据我的理解，不太靠谱。对于某个被<code>atomic</code>修饰的属性，当完全依赖于编译器自动合成getter和setter时，相信它们的原子性能够得到保证（不管它是如何合成实现的）；但是我们常常免不了自己动手写setter或者getter，此时会将系统默认合成的setter或getter给覆盖掉，我们自己的代码能够保证原子性吗？如果我们只是自己实现setter和getter中的其中一个，另外一个依赖于编译器合成，那么自定义的这个该如何实现呢？</p>
<p>种种问题外加种种不确定，导致了在iOS开发中几乎不使用<code>atomic</code>修饰符（至少没在著名第三方库中看到使用它修饰属性的案例）。</p>
<p>P.S: 这种说法纯属一家之言，以后补充更靠谱的佐证吧！</p>
<h2 id="NSLock保护property"><a href="#NSLock保护property" class="headerlink" title="NSLock保护property"></a>NSLock保护property</h2><p>上文的代码块恰好是互斥锁（<code>NSLock</code>）或者递归锁（<code>NSRecursiveLock</code>）保护property的基本套路，为了方便说明，再次罗列如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    &#123;lock&#125;        <span class="comment">// 上锁</span></div><div class="line">    _ret = _name; <span class="comment">// get name</span></div><div class="line">    &#123;unlock&#125;      <span class="comment">// 释放锁</span></div><div class="line">    <span class="keyword">return</span> _ret;  <span class="comment">// 返回</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)newName &#123;</div><div class="line">    &#123;lock&#125;        <span class="comment">// 上锁</span></div><div class="line">    &#123;set name&#125;    <span class="comment">// set name</span></div><div class="line">    &#123;unlock&#125;      <span class="comment">// 释放锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据我的理解，在一般情况下，<code>NSLock</code>是能够保证property原子性的。但根据《Effective Objective-C 2.0》的描述：一旦遇到死锁，就会非常麻烦。</p>
<p>什么情况下会出现死锁呢？我认为至少有这么一种情况：保护<code>name</code>属性的锁在其他地方也被使用了，即当前线程正在持有该锁，此时正在访问别处的某个公共资源，保护该资源的锁正被另外一个线程持有，而那个线程正在获取当前线程持有的这把锁…</p>
<p>当然，对于属性而言，这种情况过于极端，但如果<code>NSLock</code>保护的不是属性而是别的更复杂的公共资源，那么这种极端情况就不是那么极端了；再者，如果保护<code>name</code>属性的这把锁也被用来保护其他的资源，那么问题就变得更复杂了。</p>
<p>总之，根据我的理解，如果确实需要使用<strong>锁</strong>保护property，要做到：</p>
<ul>
<li>尽量使用<code>NSRecursiveLock</code>，避免多次持有该锁造成死锁</li>
<li>每个属性有一个单独的锁为之服务，不可与别的资源共用，否则问题会变得更复杂</li>
</ul>
<p>P.S: 《Effective Objective-C 2.0》中关于<code>NSLock</code>保护property的这部分内容讲得非常不到位，以上纯属个人理解！</p>
<h2 id="synchronized块保护属性"><a href="#synchronized块保护属性" class="headerlink" title="@synchronized块保护属性"></a>@synchronized块保护属性</h2><p>所谓<code>@synchronized</code>块在中文世界里常被称为<strong>同步块</strong>，根据Threading Programming Guide的描述，<strong>同步块</strong>是使用<strong>同步锁</strong>的简写形式，本质仍然是使用同步锁保护公共资源。同步块保护属性的一般形式是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="built_in">NSString</span> *)someString &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">return</span> _someString;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种做法有什么问题呢？相对于<code>NSLock</code>，这种处理问题更大！主要问题是：<code>@synchronized(self)</code>效率极低。</p>
<p>根据《Effective Objective-C 2.0》的说法。因为<code>@synchronized(){}</code>的本质是根据给定的对象，自动创建一个锁，并等待块中的代码执行完毕。执行到这段代码结尾处，锁就被释放了。通常传给<code>@synchronized</code>块的对象是<code>self</code>。这意味着同步锁将<code>self</code>整个对象都保护起来了，如果滥用，其他属性也都用<code>@synchronized(self){}</code>这种方式确保原子性，这样在<code>self</code>对象上频繁加锁，那么程序可能要等待另一段与此无关的代码执行完毕，才能继续执行当前代码，这显然会降低代码效率。</p>
<h2 id="GCD串行队列保护property"><a href="#GCD串行队列保护property" class="headerlink" title="GCD串行队列保护property"></a>GCD串行队列保护property</h2><p>将对property的读写方法都安排在同一个队列中，即可保证数据同步，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> serialQueue;</div><div class="line">    </div><div class="line"><span class="keyword">@synthesize</span> name = _name;</div><div class="line">    </div><div class="line"><span class="comment">// create a serial dispatch queue</span></div><div class="line">_serialQueue = dispatch_queue_create(<span class="string">"com.zhangbuhuai.test"</span>, <span class="literal">nil</span>);</div><div class="line">    </div><div class="line"><span class="comment">// getter</span></div><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    __block <span class="built_in">NSString</span> *localName;</div><div class="line">    <span class="built_in">dispatch_sync</span>(_serialQueue, ^&#123;</div><div class="line">        localName = _name;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> localName;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// setter</span></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="built_in">dispatch_sync</span>(_serialQueue, ^&#123;</div><div class="line">        _name = name;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此模式的思路是：把setter和getter都安排在序列化的队列里执行，这样的话，所有针对属性的访问就都同步了。为了使代码块能够设置局部变量，getter中用到了<code>__block</code>关键字，若是抛开这一点，这种写法比之前的那些更为整洁。全部加锁任务都在GCD中处理，而GCD是在相当深的底层来实现的，于是能够做许多优化。因此，开发者无需担心那些事，只要专心把访问方法写好就行了。</p>
<p>然而，<strong>还可以进一步优化，毕竟setter方法不一定非得是同步的。设置实例变量所用的block，并不需要向setter返回什么值</strong>。</p>
<p>也就是说，setter代码可以改成下面这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// setter</span></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(_serialQueue, ^&#123;</div><div class="line">        _name = name;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这次只是把同步派发改成了异步派发，从调用者的角度来看，这个小改动可以提升设置方法的执行速度（毕竟直接返回而不用等待block执行完成），而读取操作与写入操作依然会按顺序执行。但是这么改有一个坏处：如果测试一下程序的性能，那么可能发现这种写法比原来慢，因为执行异步派发时，需要拷贝block。若拷贝block所用的时间明显超过执行块所用时间，则这种做法将比原来更慢。</p>
<p>所以，setter的block设置为asynchronous或者synchronous，得看setter的block的复杂度。</p>
<h2 id="GCD并行队列和barrier保护property"><a href="#GCD并行队列和barrier保护property" class="headerlink" title="GCD并行队列和barrier保护property"></a>GCD并行队列和barrier保护property</h2><p>其实在更多的时候，调用getter可以并发执行，而getter和setter之前不能并发执行。利用这个特点，还能写一些更快一些的代码。此时正可以体现出GCD写法的好处。用同步块或锁对象，是无法轻易实现出如下这种方案的，这次不用serial dispatch queue，而改用并发队列：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> concurrentQueue;</div><div class="line">    </div><div class="line"><span class="keyword">@synthesize</span> name = _name;</div><div class="line">    </div><div class="line"><span class="comment">// create a concurrent dispatch queue</span></div><div class="line">_concurrentQueue = dispatch_queue_create(<span class="string">"com.zhangbuhuai.test"</span>, <span class="number">0</span>);</div><div class="line">    </div><div class="line"><span class="comment">// getter</span></div><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    __block <span class="built_in">NSString</span> *localName;</div><div class="line">    <span class="built_in">dispatch_sync</span>(_concurrentQueue, ^&#123;</div><div class="line">        localName = _name;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> localName;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// setter</span></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(_concurrentQueue, ^&#123;</div><div class="line">        _name = name;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，如上这样的代码，还无法正确实现同步。所有读取操作与写入操作都会在同一个队列上执行，不过由于是并发队列，所以读取与写入操作可能随时执行。而我们恰恰不想让这些操作随意执行。此问题用一个简单的GCD功能即可解决，它就是栅栏（barrier）。下列函数可以向队列中派发块，将其作为栅栏使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> dispatch_barrier_sync(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</div><div class="line"><span class="keyword">void</span> dispatch_barrier_async(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
<p>在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按顺序逐个来执行的。并发队列如果发现接下来的要处理的block是barrier block，那么就一直要等当前所有并发块都执行完毕，才会单独执行这个栅栏块。待栅栏块执行完成后，再按正常方式继续向下执行。</p>
<p>在本例中，可以用栅栏块来实现属性的setter方法。在设置方法中使用了栅栏块之后，对属性的读取操作依然可以并发执行，但是写入操作却必须单独执行了，如下图所示：</p>
<div class="imagediv" style="width: 301px; height: 298px"></div>

<p>代码实现很简单：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> concurrentQueue;</div><div class="line">    </div><div class="line"><span class="keyword">@synthesize</span> name = _name;</div><div class="line">    </div><div class="line"><span class="comment">// create a concurrent dispatch queue</span></div><div class="line">_concurrentQueue = dispatch_queue_create(<span class="string">"com.zhangbuhuai.test"</span>, <span class="number">0</span>);</div><div class="line">    </div><div class="line"><span class="comment">// getter</span></div><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    __block <span class="built_in">NSString</span> *localName;</div><div class="line">    <span class="built_in">dispatch_sync</span>(_concurrentQueue, ^&#123;</div><div class="line">        localName = _name;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> localName;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// setter</span></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    dispatch_barrier_async(_concurrentQueue, ^&#123;</div><div class="line">        _name = name;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试一下性能，就会发现，这种做法肯定比使用串行队列要快。当然，将上述代码中的<code>dispatch_barrier_async</code>改为<code>dispatch_barrier_sync</code>也是没问题的，也可能会更高效，至于原因上文已经讲到了。在实际使用时，最好还是测一测每种做法的性能，然后从中选出最适合当前场景的方案。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://book.douban.com/subject/21370593/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
<li><a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD/">GCD</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-gcd-basics" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/26/gcd-basics/" class="article-date">
  	<time datetime="2015-01-26T12:05:56.000Z" itemprop="datePublished">2015-01-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/26/gcd-basics/">GCD基础知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p>在英文世界里，「并行」和「并发」的区别比较清晰，「并行」对应「parallelism」，「并发」对应「concurrency」；但在中文世界里二者仅一字之差，两个概念非常容易弄混淆。</p>
<p>各种资料对<strong>并行</strong>和<strong>并发</strong>有各种各样的解释和比喻。我比较喜欢的一种，是播客节目<a href="http://ipn.li/kernelpanic/13" target="_blank" rel="external">内核恐慌</a>中的主播Rio的描述，大概意思是：</p>
<blockquote>
<p>「并发」和「并行」是一种计算模型，使得计算机能够在同一时间处理多个任务；「并发」表示逻辑概念上的「同时」，「并行」表示物理概念上的「同时」。</p>
</blockquote>
<p>简单来说，若说两个任务A和B并发执行，则表示任务A和任务B在同一时间段里被执行（更多的可能是二者交替执行）；若说任务A和B并行执行，则表示任务A和任务B在同时被执行（这要求计算机有多个运算器）；</p>
<p>一句话：并行要求并发，但并发并不能保证并行。</p>
<p>P.S: 关于并发和并行，《<a href="https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1" target="_blank" rel="external">Grand Central Dispatch In-Depth: Part 1/2</a>》中有更详细的图文解释。</p>
<h2 id="Dispatch-Queues介绍"><a href="#Dispatch-Queues介绍" class="headerlink" title="Dispatch Queues介绍"></a>Dispatch Queues介绍</h2><p>Dispatch Queues是GCD处理异步任务和并发任务的关键载体，简而言之，在GCD中，将task放入某个Dispatch Queue中，然后等待系统去处理之。</p>
<p>Dispatch queue是object-like structure，也就是说Dispatch queue在Objective-C中不是类结构，而是类类结构。dispatch queue对task的管理都遵循FIFO。GCD提供了一些公共的dispatch queue，但是用户也可以自定义一些dispatch queue；iOS对dispatch queue做了归类，分为三类：</p>
<ul>
<li>Serial Dispatch Queue</li>
<li>Concurrent Dispatch Queue</li>
<li>Main Dispatch Queue</li>
</ul>
<h3 id="Serial-Dispatch-Queue"><a href="#Serial-Dispatch-Queue" class="headerlink" title="Serial Dispatch Queue"></a>Serial Dispatch Queue</h3><p>顾名思义，serial dispatch queue中的block按照先进先出（FIFO）的顺序去执行，实际上为单线程执行。即每次从queue中取出一个task进行处理；用户可以根据需要创建任意多的serial dispatch queue，serial dispatch queue彼此之间是并发的；</p>
<p>创建serial dispatch queue使用<code>dispatch_queue_create</code>方法，指定其第二个参数为<code>DISPATCH_QUEUE_SERIAL</code>（即<code>NULL</code>）即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue;</div><div class="line">queue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure>
<p>注意：如果不算“Main Dispatch Queue”，系统中不存在所谓的global serial dispatch queue。</p>
<p>P.S: main dispatch queue其实也算serial dispatch queue，后文有述。</p>
<h3 id="Concurrent-Dispatch-Queue"><a href="#Concurrent-Dispatch-Queue" class="headerlink" title="Concurrent Dispatch Queue"></a>Concurrent Dispatch Queue</h3><p>相对于Serial Dispatch Queue，Concurrent Dispatch Queue一次性并发执行一个或者多个task；和Serial Dispatch Queue不同，系统提供了四个global concurrent queue，使用<code>dispatch_get_global_queue</code>函数就可以获取这些global concurrent queue；</p>
<p>和Serial Dispatch Queue一样，用户也可以根据需要自己定义concurrent queue；创建concurrent dispatch queue也使用<code>dispatch_queue_create</code>方法，所不同的是需要指定其第二个参数为<code>DISPATCH_QUEUE_CONCURRENT</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue;</div><div class="line">queue = dispatch_queue_create(<span class="string">"com.example.MyConcurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<p>P.S: 根据我的理解，对于concurrent queue，其管理的task可能在多个不同thread上执行，至于dispatch queue管理多少个thread是未知的，这要视系统资源而定，用户无需为此烦扰。</p>
<h3 id="Main-Dispatch-Queue"><a href="#Main-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue"></a>Main Dispatch Queue</h3><p>关于Main Dispatch Queue，《Concurrency Programming Guide》（Apple官方文档）的描述如下：</p>
<blockquote>
<p>The main dispatch queue is a globally available serial queue that executes tasks on the application’s main thread.</p>
</blockquote>
<p>根据我的理解，application的主要任务（譬如UI管理之类的）都在main dispatch queue中完成；根据文档的描述，main dispatch queue中的task都在一个thread中运行，即application’s main thread（thread 1）。</p>
<p>所以，如果想要更新UI，则必须在main dispatch queue中处理，获取main dispatch queue也很容易，调用<code>dispatch_get_main_queue()</code>函数即可。</p>
<h3 id="关于Dispatch-Queues的一些误解"><a href="#关于Dispatch-Queues的一些误解" class="headerlink" title="关于Dispatch Queues的一些误解"></a>关于Dispatch Queues的一些误解</h3><p>在学习GCD过程中，我一路上有许多关于dispatch的错误理解，如下是总结：</p>
<ul>
<li>不存在所谓的「同步队列」和「异步队列」</li>
</ul>
<p>同步或异步描述的是task与其上下文之间的关系，所以，我觉得「同步队列」和「异步队列」对于Objective-C的GCD而言是不靠谱的概念。</p>
<p>P.S: 补充！虽然没有「同步队列」和「异步队列」的说法，但是有「同步串行队列」和「同步并发队列」的概念。</p>
<ul>
<li>Serial Dispatch Queue上的tasks并非只在同一个thread上执行</li>
</ul>
<p>吾尝以为serial queue上的tasks都是在同一个thread上运行，后来明白了不是这样的，对于那些同步请求的任务，譬如使用dispatch_sync函数添加到serial dispatch queue中的任务，其运行的task往往与所在的上下文是同一个thread；对于那些异步请求的任务，譬如使用dispatch_async函数添加到serial dispatch queue中的任务，其运行的task往往是另一个的thread。举例说明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> aSerialQueue = dispatch_queue_create(<span class="string">"haha"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_sync</span>(aSerialQueue, ^&#123;</div><div class="line">        <span class="comment">// block 1</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current 1: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(aSerialQueue, ^&#123;</div><div class="line">        <span class="comment">// block 2</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current 2: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 执行结果：</span></div><div class="line"><span class="comment">// current 1: &lt;NSThread: 0x7f8f397152f0&gt;&#123;number = 1, name = main&#125;</span></div><div class="line"><span class="comment">// current 2: &lt;NSThread: 0x7f8f39464db0&gt;&#123;number = 2, name = (null)&#125;</span></div></pre></td></tr></table></figure>
<p>block 1和block 2都由同一个serial dispatch queue管理，但它们的执行线程显然不同，前者的执行线程是thread 1，后者的执行线程是thread 2。</p>
<ul>
<li>dispatch queue和thread并不存在一对一或者一对多的关系</li>
</ul>
<p>通过设置断点等测试手段可以知道可能多个dispatch queue共用一个thread，也可能一个dispatch queue中的tasks在多个不同threads上执行。</p>
<p>总之，根据我的理解，thread和dispatch queue之间没有从属关系。</p>
<h2 id="dispatch-sync和dispatch-async"><a href="#dispatch-sync和dispatch-async" class="headerlink" title="dispatch_sync和dispatch_async"></a>dispatch_sync和dispatch_async</h2><p>在GCD中，<code>dispatch_sync</code>和<code>dispatch_async</code>是两个函数，前者用于派发同步任务，后者用于派发异步任务，二者使用格式如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dispatch task synchronously</span></div><div class="line"><span class="built_in">dispatch_sync</span>(someQueue1, ^&#123;</div><div class="line">    <span class="comment">// do something 1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// do something 2</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dispatch task asynchronously</span></div><div class="line"><span class="built_in">dispatch_async</span>(someQueue2, ^&#123;</div><div class="line">    <span class="comment">// do something 3</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// do something 4</span></div></pre></td></tr></table></figure>
<p><code>do something 2</code>一定会在<code>do something 1</code>完成之后执行，即所谓的<strong>同步</strong>。当执行到<code>dispatch_sync(...)</code>时，其上下文被阻塞，直到<code>dispatch_sync</code>派发的block被执行完毕。</p>
<p>根据我的理解：<strong>dispatch_sync派发的block的执行线程和dispatch_sync上下文线程是同一个线程</strong>。</p>
<p>P.S: 这个说法还没有找到权威的、直接明了的佐证。</p>
<p>而<code>do something 4</code>会立即执行，而不会等到<code>do something 3</code>执行完，即所谓<strong>异步</strong>。当执行到<code>dispatch_async(...)</code>时，其上下文不被阻塞，继续运行。</p>
<p>根据我的理解：<code>do something 3</code>和<code>do something 4</code>的执行线程往往不是同一个，即<strong>dispatch_async派发的block的执行线程和dispatch_async上下文线程不是同一个线程</strong>；</p>
<p>来看一个示例，如下有一段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. create a serial dispatch queue</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> serial_queue=</div><div class="line">dispatch_queue_create(<span class="string">"com.zhangbuhuai.test"</span>, DISPATCH_QUEUE_SERIAL);    <span class="comment">// Thread 1</span></div><div class="line">    </div><div class="line"><span class="comment">// 2. add tasks to serial dispatch queue</span></div><div class="line"><span class="comment">// 1) add a task synchronously</span></div><div class="line"><span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</div><div class="line">    sleep(<span class="number">3</span>);               <span class="comment">// 休眠3秒</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task 1"</span>);       <span class="comment">// Thread 1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 2) add a task synchronously too</span></div><div class="line"><span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task 2"</span>);       <span class="comment">// Thread 1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 3) add a task asynchronously</span></div><div class="line"><span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task 3"</span>);       <span class="comment">// Thread x  (x != 1)</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 4) add a task asynchronously too</span></div><div class="line"><span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task 4"</span>);       <span class="comment">// Thread x  (x != 1)</span></div><div class="line">&#125;);</div><div class="line">    </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"test end"</span>);         <span class="comment">// Thread 1</span></div></pre></td></tr></table></figure>
<p>假设创建<code>serial_queue</code>所在的上下文的执行线程为Thread 1，则测试结果是：<code>NSLog(@&quot;task 1&quot;)</code>和<code>NSLog(@&quot;task 2&quot;)</code>也都在Thread 1中执行，而<code>NSLog(@&quot;task 3&quot;)</code>和<code>NSLog(@&quot;task 4&quot;)</code>在别的Thread中执行。</p>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">task 1</div><div class="line">task 2</div><div class="line">test end</div><div class="line">task 3</div><div class="line">task 4</div></pre></td></tr></table></figure>
<p>结果说明，对于serial dispatch queue中的tasks，无论是同步派发还是异步派发，其执行顺序都遵循FIFO；同样，这个示例也可以直观阐述<code>dispatch_sync</code>和<code>dispatch_async</code>的不同效果。</p>
<p><strong>dispatch_sync和dispatch_async的使用时机</strong></p>
<p>在大多数时候，<code>dispatch_sync</code>和<code>dispatch_async</code>的使用时机非常清晰的：</p>
<ul>
<li>如果派发的task耗时长，不想让上下文线程被阻塞，就用<code>dispatch_async</code></li>
<li>如果要处理的代码比较短，想要实现代码保护（线程安全），选用<code>dispatch_sync</code></li>
</ul>
<p>P.S: 关于<code>dispatch_sync</code>与线程同步（代码保护）之间的关系，<del>以后补充</del>。</p>
<p>但有些时候，使用<code>dispatch_sync</code>或者<code>dispatch_async</code>都可以的情况下（譬如实现setter），就不是那么好选择了。</p>
<p>在《Effective Objective-C 2.0》Item 41（中文版P169）中看到非常重要的一句话：</p>
<blockquote>
<p>…，因为在执行异步派发时，需要拷贝块。</p>
</blockquote>
<p>我对这句话的理解是：</p>
<ul>
<li>执行同步派发（<code>dispatch_sync</code>）时，是不需要拷贝block的，这是因为<code>dispatch_sync</code>中所派发的task往往和当前上下文所处同一个Thread</li>
<li>执行异步派发（<code>dispatch_async</code>）时，需要拷贝block，这是因为<code>dispatch_async</code>中所派发的task往往和当前上下文不同于一个Thread</li>
</ul>
<p>所以，当选择<code>dispatch_sync</code>或者<code>dispatch_async</code>都可以的情况下，站在效率的角度，如果拷贝block的时间成本过高，则使用<code>dispatch_sync</code>；如果拷贝block的时间成本远低于执行block的时间成本，则使用<code>dispatch_async</code>。</p>
<p>如上所引用的「…，因为在执行异步派发时，需要拷贝块」这句话，在某种程度上佐证了上文提到的两个说法：</p>
<ul>
<li><code>dispatch_sync</code>派发的block的执行线程和<code>dispatch_sync</code>上下文线程是同一个线程；</li>
<li><code>dispatch_async</code>派发的block的执行线程和<code>dispatch_async</code>上下文线程不是同一个线程；</li>
</ul>
<p>———————-如下是补充内容———————-</p>
<h2 id="使用串行同步队列保护代码"><a href="#使用串行同步队列保护代码" class="headerlink" title="使用串行同步队列保护代码"></a>使用串行同步队列保护代码</h2><p>先来看一段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                            completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response,</div><div class="line">                                                        <span class="keyword">id</span> responseObject,</div><div class="line">                                                        <span class="built_in">NSError</span> *error))completionHandler</div><div class="line">&#123;</div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), ^&#123;  <span class="comment">// mark 1</span></div><div class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask completionHandler:completionHandler];  <span class="comment">// mark 2</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码是在AFNetworking框架的<code>AFURLSessionManager.m</code>中定义的，用于创建Data Task（<code>NSURLSessionDataTask</code>实例），这短短几行代码的逻辑是：</p>
<ol>
<li><code>mark 1</code>以同步派发的方式提交任务 – 创建一个<code>NSURLSessionDataTask</code>实例；</li>
<li><code>mark 2</code>处被阻塞；</li>
<li><code>NSURLSessionDataTask</code>实例创建完成，继续执行<code>mark 2</code>及后续代码；</li>
</ol>
<p>曾经对这几行代码比较疑惑：为什么使用<code>dispatch_sync</code>派发任务呢？</p>
<p>现在是能够理解了，上述<code>url_session_manager_creation_queue()</code>函数返回的其实是一个serial dispatch queue，这种组合（<code>dispatch_sync</code>+串行队列）即所谓的<strong>串行同步队列</strong>。串行同步队列常被用来保护临界资源，确保临界资源的线程安全，作用类似于同步锁，估摸着<code>dataTaskWithRequest:</code>并不是一个线程安全方法。</p>
<h2 id="使用dispatch-sync的注意事项"><a href="#使用dispatch-sync的注意事项" class="headerlink" title="使用dispatch_sync的注意事项"></a>使用dispatch_sync的注意事项</h2><p><a href="(https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html">Concurrency Programming Guide</a>)有包括关于使用<code>dispatch_sync</code>的提示：</p>
<blockquote>
<p>Important: You should never call the dispatch_sync or dispatch_sync_f function from a task that is executing in the same queue that you are planning to pass to the function. This is particularly important for serial queues, which are guaranteed to deadlock, but should also be avoided for concurrent queues.</p>
</blockquote>
<p>简单来说，在<code>dispatch_sync</code>嵌套使用时要注意：不能在一个嵌套中使用同一个serial dispatch queue，因为会发生死锁；</p>
<p>假设有如下这么一段代码要执行：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)test &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> aSerialDispatchQueue =</div><div class="line">    dispatch_queue_create(<span class="string">"I.am.an.iOS.developer"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">       </div><div class="line">    <span class="built_in">dispatch_sync</span>(aSerialDispatchQueue, ^&#123;</div><div class="line">        <span class="comment">// block 1</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Good Night, Benjamin"</span>);</div><div class="line">        <span class="built_in">dispatch_sync</span>(aSerialDispatchQueue, ^&#123;</div><div class="line">            <span class="comment">// block 2</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Good Night, Daisy"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自己试着执行以下就会发现：「<code>Good Night, Daisy</code>」这一句永远都无法被打印出来，原因很简单，程序产生了死锁。为什么会产生死锁呢？</p>
<p>可以想象<code>aSerialDispatchQueue</code>在底层实现中有一把锁，这把锁确保serial dispatch queue中只有一个block被执行，当执行到<code>block 1</code>代码时，这把锁为<code>block 1</code>所持有，当<code>block 1</code>执行完了，会释放之；然而<code>block 1</code>同步派发了一个任务<code>block 2</code>，同步派发意味着<code>block 1</code>会被阻塞，直到<code>block 2</code>被执行完成；但是这里产生了矛盾，<code>block 2</code>顺利执行的前提是<code>aSerialDispatchQueue</code>的这把锁被<code>block 1</code>释放，但是<code>block 1</code>释放这把锁的前提是<code>block 1</code>执行完成…这就是典型的dead lock。</p>
<p>这一段代码还好，比较容易避免，但是如果对GCD理解不深，更多的时候容易写出如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">// 巴拉巴拉，做了很多事情</span></div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Good Night, Benjamin"</span>);</div><div class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">// refresh UI</span></div><div class="line">    </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Good Night, Daisy"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的问题其实和上一段代码类似，只不过这里的serial dispatch queue恰好是main queue。</p>
<p>上述的死锁问题主要针对<strong>同步串行队列</strong>，对于<strong>同步并发队列</strong>，根据我的理解应该不存在这个deadlock问题，但是《Concurrency Programming Guide》明确说了：</p>
<blockquote>
<p>…This is particularly important for serial queues, which are guaranteed to deadlock, but should also be avoided for concurrent queues.</p>
</blockquote>
<p>P.S: 目前还不理解这个说辞。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">Concurrency Programming Guide</a></li>
<li><a href="https://book.douban.com/subject/21370593/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD/">GCD</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/9/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/11/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>