<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/page/10/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/iOS/">Android相关</a></li>
				        
							<li><a href="/categories/essay">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.67px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 15px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 18.33px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.67px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 20px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 13.33px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 16.67px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.67px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/Transition/" style="font-size: 13.33px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，Android开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/iOS/">Android相关</a></li>
		        
					<li><a href="/categories/essay">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-using-gcd-part-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/26/using-gcd-part-1/" class="article-date">
  	<time datetime="2015-01-26T13:49:05.000Z" itemprop="datePublished">2015-01-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/26/using-gcd-part-1/">GCD实践之（一）使用GCD保护property</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>作为一个iOS开发者，必须要熟练使用GCD，本文是站在实际应用的角度总结GCD的用法之一：使用barrier保护property。</p>
<p>在多线程环境下，如果有多个线程要执行同一份代码，那么有时会出现问题，为了保证某些资源操作的可控性，需要一些手段来对这些公共资源进行保护，无论是什么语言，只要支持多线程，都得面临这个问题，即所谓的<strong>线程同步</strong>问题。本文围绕property讨论各种<strong>同步工具</strong>的保护效果，这同样可以延伸到其他需要保护的公共资源上。</p>
<h2 id="atomic保护property"><a href="#atomic保护property" class="headerlink" title="atomic保护property"></a>atomic保护property</h2><p>维持property原子操作的最简单的保护措施是为其添加<code>atomic</code>修饰词，这样编译器在为其生成setter和getter时对其进行原子保护。问题来了，对于使用<code>atomic</code>修饰的property，编译器为其生成的getter和setter是什么样子的呢？在很长时间里，由于受到不靠谱网友的误导，以为是这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    &#123;lock&#125;        <span class="comment">// 上锁</span></div><div class="line">    _ret = _name; <span class="comment">// get name</span></div><div class="line">    &#123;unlock&#125;      <span class="comment">// 释放锁</span></div><div class="line">    <span class="keyword">return</span> _ret;  <span class="comment">// 返回</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)newName &#123;</div><div class="line">    &#123;lock&#125;        <span class="comment">// 上锁</span></div><div class="line">    &#123;set name&#125;    <span class="comment">// set name</span></div><div class="line">    &#123;unlock&#125;      <span class="comment">// 释放锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看来认真看了Apple官方文档<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a>，意识到这种说法是错误的。Apple的原子操作的底层实现并不是基于锁的，具体是什么样子呢？我也不知道，但肯定不是如上这样的（以后有时间深入了解一下，希望能够找到答案吧）。</p>
<p>那么修饰词<code>atomic</code>靠谱吗？它能保证相关属性getter和setter的原子性吗？能信赖它吗？</p>
<p>根据我的理解，不太靠谱。对于某个被<code>atomic</code>修饰的属性，当完全依赖于编译器自动合成getter和setter时，相信它们的原子性能够得到保证（不管它是如何合成实现的）；但是我们常常免不了自己动手写setter或者getter，此时会将系统默认合成的setter或getter给覆盖掉，我们自己的代码能够保证原子性吗？如果我们只是自己实现setter和getter中的其中一个，另外一个依赖于编译器合成，那么自定义的这个该如何实现呢？</p>
<p>种种问题外加种种不确定，导致了在iOS开发中几乎不使用<code>atomic</code>修饰符（至少没在著名第三方库中看到使用它修饰属性的案例）。</p>
<p>P.S: 这种说法纯属一家之言，以后补充更靠谱的佐证吧！</p>
<h2 id="NSLock保护property"><a href="#NSLock保护property" class="headerlink" title="NSLock保护property"></a>NSLock保护property</h2><p>上文的代码块恰好是互斥锁（<code>NSLock</code>）或者递归锁（<code>NSRecursiveLock</code>）保护property的基本套路，为了方便说明，再次罗列如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    &#123;lock&#125;        <span class="comment">// 上锁</span></div><div class="line">    _ret = _name; <span class="comment">// get name</span></div><div class="line">    &#123;unlock&#125;      <span class="comment">// 释放锁</span></div><div class="line">    <span class="keyword">return</span> _ret;  <span class="comment">// 返回</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)newName &#123;</div><div class="line">    &#123;lock&#125;        <span class="comment">// 上锁</span></div><div class="line">    &#123;set name&#125;    <span class="comment">// set name</span></div><div class="line">    &#123;unlock&#125;      <span class="comment">// 释放锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据我的理解，在一般情况下，<code>NSLock</code>是能够保证property原子性的。但根据《Effective Objective-C 2.0》的描述：一旦遇到死锁，就会非常麻烦。</p>
<p>什么情况下会出现死锁呢？我认为至少有这么一种情况：保护<code>name</code>属性的锁在其他地方也被使用了，即当前线程正在持有该锁，此时正在访问别处的某个公共资源，保护该资源的锁正被另外一个线程持有，而那个线程正在获取当前线程持有的这把锁…</p>
<p>当然，对于属性而言，这种情况过于极端，但如果<code>NSLock</code>保护的不是属性而是别的更复杂的公共资源，那么这种极端情况就不是那么极端了；再者，如果保护<code>name</code>属性的这把锁也被用来保护其他的资源，那么问题就变得更复杂了。</p>
<p>总之，根据我的理解，如果确实需要使用<strong>锁</strong>保护property，要做到：</p>
<ul>
<li>尽量使用<code>NSRecursiveLock</code>，避免多次持有该锁造成死锁</li>
<li>每个属性有一个单独的锁为之服务，不可与别的资源共用，否则问题会变得更复杂</li>
</ul>
<p>P.S: 《Effective Objective-C 2.0》中关于<code>NSLock</code>保护property的这部分内容讲得非常不到位，以上纯属个人理解！</p>
<h2 id="synchronized块保护属性"><a href="#synchronized块保护属性" class="headerlink" title="@synchronized块保护属性"></a>@synchronized块保护属性</h2><p>所谓<code>@synchronized</code>块在中文世界里常被称为<strong>同步块</strong>，根据Threading Programming Guide的描述，<strong>同步块</strong>是使用<strong>同步锁</strong>的简写形式，本质仍然是使用同步锁保护公共资源。同步块保护属性的一般形式是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="built_in">NSString</span> *)someString &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">return</span> _someString;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种做法有什么问题呢？相对于<code>NSLock</code>，这种处理问题更大！主要问题是：<code>@synchronized(self)</code>效率极低。</p>
<p>根据《Effective Objective-C 2.0》的说法。因为<code>@synchronized(){}</code>的本质是根据给定的对象，自动创建一个锁，并等待块中的代码执行完毕。执行到这段代码结尾处，锁就被释放了。通常传给<code>@synchronized</code>块的对象是<code>self</code>。这意味着同步锁将<code>self</code>整个对象都保护起来了，如果滥用，其他属性也都用<code>@synchronized(self){}</code>这种方式确保原子性，这样在<code>self</code>对象上频繁加锁，那么程序可能要等待另一段与此无关的代码执行完毕，才能继续执行当前代码，这显然会降低代码效率。</p>
<h2 id="GCD串行队列保护property"><a href="#GCD串行队列保护property" class="headerlink" title="GCD串行队列保护property"></a>GCD串行队列保护property</h2><p>将对property的读写方法都安排在同一个队列中，即可保证数据同步，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> serialQueue;</div><div class="line">    </div><div class="line"><span class="keyword">@synthesize</span> name = _name;</div><div class="line">    </div><div class="line"><span class="comment">// create a serial dispatch queue</span></div><div class="line">_serialQueue = dispatch_queue_create(<span class="string">"com.zhangbuhuai.test"</span>, <span class="literal">nil</span>);</div><div class="line">    </div><div class="line"><span class="comment">// getter</span></div><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    __block <span class="built_in">NSString</span> *localName;</div><div class="line">    <span class="built_in">dispatch_sync</span>(_serialQueue, ^&#123;</div><div class="line">        localName = _name;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> localName;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// setter</span></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="built_in">dispatch_sync</span>(_serialQueue, ^&#123;</div><div class="line">        _name = name;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此模式的思路是：把setter和getter都安排在序列化的队列里执行，这样的话，所有针对属性的访问就都同步了。为了使代码块能够设置局部变量，getter中用到了<code>__block</code>关键字，若是抛开这一点，这种写法比之前的那些更为整洁。全部加锁任务都在GCD中处理，而GCD是在相当深的底层来实现的，于是能够做许多优化。因此，开发者无需担心那些事，只要专心把访问方法写好就行了。</p>
<p>然而，<strong>还可以进一步优化，毕竟setter方法不一定非得是同步的。设置实例变量所用的block，并不需要向setter返回什么值</strong>。</p>
<p>也就是说，setter代码可以改成下面这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// setter</span></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(_serialQueue, ^&#123;</div><div class="line">        _name = name;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这次只是把同步派发改成了异步派发，从调用者的角度来看，这个小改动可以提升设置方法的执行速度（毕竟直接返回而不用等待block执行完成），而读取操作与写入操作依然会按顺序执行。但是这么改有一个坏处：如果测试一下程序的性能，那么可能发现这种写法比原来慢，因为执行异步派发时，需要拷贝block。若拷贝block所用的时间明显超过执行块所用时间，则这种做法将比原来更慢。</p>
<p>所以，setter的block设置为asynchronous或者synchronous，得看setter的block的复杂度。</p>
<h2 id="GCD并行队列和barrier保护property"><a href="#GCD并行队列和barrier保护property" class="headerlink" title="GCD并行队列和barrier保护property"></a>GCD并行队列和barrier保护property</h2><p>其实在更多的时候，调用getter可以并发执行，而getter和setter之前不能并发执行。利用这个特点，还能写一些更快一些的代码。此时正可以体现出GCD写法的好处。用同步块或锁对象，是无法轻易实现出如下这种方案的，这次不用serial dispatch queue，而改用并发队列：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> concurrentQueue;</div><div class="line">    </div><div class="line"><span class="keyword">@synthesize</span> name = _name;</div><div class="line">    </div><div class="line"><span class="comment">// create a concurrent dispatch queue</span></div><div class="line">_concurrentQueue = dispatch_queue_create(<span class="string">"com.zhangbuhuai.test"</span>, <span class="number">0</span>);</div><div class="line">    </div><div class="line"><span class="comment">// getter</span></div><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    __block <span class="built_in">NSString</span> *localName;</div><div class="line">    <span class="built_in">dispatch_sync</span>(_concurrentQueue, ^&#123;</div><div class="line">        localName = _name;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> localName;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// setter</span></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(_concurrentQueue, ^&#123;</div><div class="line">        _name = name;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，如上这样的代码，还无法正确实现同步。所有读取操作与写入操作都会在同一个队列上执行，不过由于是并发队列，所以读取与写入操作可能随时执行。而我们恰恰不想让这些操作随意执行。此问题用一个简单的GCD功能即可解决，它就是栅栏（barrier）。下列函数可以向队列中派发块，将其作为栅栏使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> dispatch_barrier_sync(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</div><div class="line"><span class="keyword">void</span> dispatch_barrier_async(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
<p>在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按顺序逐个来执行的。并发队列如果发现接下来的要处理的block是barrier block，那么就一直要等当前所有并发块都执行完毕，才会单独执行这个栅栏块。待栅栏块执行完成后，再按正常方式继续向下执行。</p>
<p>在本例中，可以用栅栏块来实现属性的setter方法。在设置方法中使用了栅栏块之后，对属性的读取操作依然可以并发执行，但是写入操作却必须单独执行了，如下图所示：</p>
<div class="imagediv" style="width: 301px; height: 298px"></div>

<p>代码实现很简单：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> concurrentQueue;</div><div class="line">    </div><div class="line"><span class="keyword">@synthesize</span> name = _name;</div><div class="line">    </div><div class="line"><span class="comment">// create a concurrent dispatch queue</span></div><div class="line">_concurrentQueue = dispatch_queue_create(<span class="string">"com.zhangbuhuai.test"</span>, <span class="number">0</span>);</div><div class="line">    </div><div class="line"><span class="comment">// getter</span></div><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    __block <span class="built_in">NSString</span> *localName;</div><div class="line">    <span class="built_in">dispatch_sync</span>(_concurrentQueue, ^&#123;</div><div class="line">        localName = _name;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> localName;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// setter</span></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    dispatch_barrier_async(_concurrentQueue, ^&#123;</div><div class="line">        _name = name;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试一下性能，就会发现，这种做法肯定比使用串行队列要快。当然，将上述代码中的<code>dispatch_barrier_async</code>改为<code>dispatch_barrier_sync</code>也是没问题的，也可能会更高效，至于原因上文已经讲到了。在实际使用时，最好还是测一测每种做法的性能，然后从中选出最适合当前场景的方案。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://book.douban.com/subject/21370593/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
<li><a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD/">GCD</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-gcd-basics" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/26/gcd-basics/" class="article-date">
  	<time datetime="2015-01-26T12:05:56.000Z" itemprop="datePublished">2015-01-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/26/gcd-basics/">GCD基础知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p>在英文世界里，「并行」和「并发」的区别比较清晰，「并行」对应「parallelism」，「并发」对应「concurrency」；但在中文世界里二者仅一字之差，两个概念非常容易弄混淆。</p>
<p>各种资料对<strong>并行</strong>和<strong>并发</strong>有各种各样的解释和比喻。我比较喜欢的一种，是播客节目<a href="http://ipn.li/kernelpanic/13" target="_blank" rel="external">内核恐慌</a>中的主播Rio的描述，大概意思是：</p>
<blockquote>
<p>「并发」和「并行」是一种计算模型，使得计算机能够在同一时间处理多个任务；「并发」表示逻辑概念上的「同时」，「并行」表示物理概念上的「同时」。</p>
</blockquote>
<p>简单来说，若说两个任务A和B并发执行，则表示任务A和任务B在同一时间段里被执行（更多的可能是二者交替执行）；若说任务A和B并行执行，则表示任务A和任务B在同时被执行（这要求计算机有多个运算器）；</p>
<p>一句话：并行要求并发，但并发并不能保证并行。</p>
<p>P.S: 关于并发和并行，《<a href="https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1" target="_blank" rel="external">Grand Central Dispatch In-Depth: Part 1/2</a>》中有更详细的图文解释。</p>
<h2 id="Dispatch-Queues介绍"><a href="#Dispatch-Queues介绍" class="headerlink" title="Dispatch Queues介绍"></a>Dispatch Queues介绍</h2><p>Dispatch Queues是GCD处理异步任务和并发任务的关键载体，简而言之，在GCD中，将task放入某个Dispatch Queue中，然后等待系统去处理之。</p>
<p>Dispatch queue是object-like structure，也就是说Dispatch queue在Objective-C中不是类结构，而是类类结构。dispatch queue对task的管理都遵循FIFO。GCD提供了一些公共的dispatch queue，但是用户也可以自定义一些dispatch queue；iOS对dispatch queue做了归类，分为三类：</p>
<ul>
<li>Serial Dispatch Queue</li>
<li>Concurrent Dispatch Queue</li>
<li>Main Dispatch Queue</li>
</ul>
<h3 id="Serial-Dispatch-Queue"><a href="#Serial-Dispatch-Queue" class="headerlink" title="Serial Dispatch Queue"></a>Serial Dispatch Queue</h3><p>顾名思义，serial dispatch queue中的block按照先进先出（FIFO）的顺序去执行，实际上为单线程执行。即每次从queue中取出一个task进行处理；用户可以根据需要创建任意多的serial dispatch queue，serial dispatch queue彼此之间是并发的；</p>
<p>创建serial dispatch queue使用<code>dispatch_queue_create</code>方法，指定其第二个参数为<code>DISPATCH_QUEUE_SERIAL</code>（即<code>NULL</code>）即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue;</div><div class="line">queue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure>
<p>注意：如果不算“Main Dispatch Queue”，系统中不存在所谓的global serial dispatch queue。</p>
<p>P.S: main dispatch queue其实也算serial dispatch queue，后文有述。</p>
<h3 id="Concurrent-Dispatch-Queue"><a href="#Concurrent-Dispatch-Queue" class="headerlink" title="Concurrent Dispatch Queue"></a>Concurrent Dispatch Queue</h3><p>相对于Serial Dispatch Queue，Concurrent Dispatch Queue一次性并发执行一个或者多个task；和Serial Dispatch Queue不同，系统提供了四个global concurrent queue，使用<code>dispatch_get_global_queue</code>函数就可以获取这些global concurrent queue；</p>
<p>和Serial Dispatch Queue一样，用户也可以根据需要自己定义concurrent queue；创建concurrent dispatch queue也使用<code>dispatch_queue_create</code>方法，所不同的是需要指定其第二个参数为<code>DISPATCH_QUEUE_CONCURRENT</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue;</div><div class="line">queue = dispatch_queue_create(<span class="string">"com.example.MyConcurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<p>P.S: 根据我的理解，对于concurrent queue，其管理的task可能在多个不同thread上执行，至于dispatch queue管理多少个thread是未知的，这要视系统资源而定，用户无需为此烦扰。</p>
<h3 id="Main-Dispatch-Queue"><a href="#Main-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue"></a>Main Dispatch Queue</h3><p>关于Main Dispatch Queue，《Concurrency Programming Guide》（Apple官方文档）的描述如下：</p>
<blockquote>
<p>The main dispatch queue is a globally available serial queue that executes tasks on the application’s main thread.</p>
</blockquote>
<p>根据我的理解，application的主要任务（譬如UI管理之类的）都在main dispatch queue中完成；根据文档的描述，main dispatch queue中的task都在一个thread中运行，即application’s main thread（thread 1）。</p>
<p>所以，如果想要更新UI，则必须在main dispatch queue中处理，获取main dispatch queue也很容易，调用<code>dispatch_get_main_queue()</code>函数即可。</p>
<h3 id="关于Dispatch-Queues的一些误解"><a href="#关于Dispatch-Queues的一些误解" class="headerlink" title="关于Dispatch Queues的一些误解"></a>关于Dispatch Queues的一些误解</h3><p>在学习GCD过程中，我一路上有许多关于dispatch的错误理解，如下是总结：</p>
<ul>
<li>不存在所谓的「同步队列」和「异步队列」</li>
</ul>
<p>同步或异步描述的是task与其上下文之间的关系，所以，我觉得「同步队列」和「异步队列」对于Objective-C的GCD而言是不靠谱的概念。</p>
<p>P.S: 补充！虽然没有「同步队列」和「异步队列」的说法，但是有「同步串行队列」和「同步并发队列」的概念。</p>
<ul>
<li>Serial Dispatch Queue上的tasks并非只在同一个thread上执行</li>
</ul>
<p>吾尝以为serial queue上的tasks都是在同一个thread上运行，后来明白了不是这样的，对于那些同步请求的任务，譬如使用dispatch_sync函数添加到serial dispatch queue中的任务，其运行的task往往与所在的上下文是同一个thread；对于那些异步请求的任务，譬如使用dispatch_async函数添加到serial dispatch queue中的任务，其运行的task往往是另一个的thread。举例说明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> aSerialQueue = dispatch_queue_create(<span class="string">"haha"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_sync</span>(aSerialQueue, ^&#123;</div><div class="line">        <span class="comment">// block 1</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current 1: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(aSerialQueue, ^&#123;</div><div class="line">        <span class="comment">// block 2</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current 2: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 执行结果：</span></div><div class="line"><span class="comment">// current 1: &lt;NSThread: 0x7f8f397152f0&gt;&#123;number = 1, name = main&#125;</span></div><div class="line"><span class="comment">// current 2: &lt;NSThread: 0x7f8f39464db0&gt;&#123;number = 2, name = (null)&#125;</span></div></pre></td></tr></table></figure>
<p>block 1和block 2都由同一个serial dispatch queue管理，但它们的执行线程显然不同，前者的执行线程是thread 1，后者的执行线程是thread 2。</p>
<ul>
<li>dispatch queue和thread并不存在一对一或者一对多的关系</li>
</ul>
<p>通过设置断点等测试手段可以知道可能多个dispatch queue共用一个thread，也可能一个dispatch queue中的tasks在多个不同threads上执行。</p>
<p>总之，根据我的理解，thread和dispatch queue之间没有从属关系。</p>
<h2 id="dispatch-sync和dispatch-async"><a href="#dispatch-sync和dispatch-async" class="headerlink" title="dispatch_sync和dispatch_async"></a>dispatch_sync和dispatch_async</h2><p>在GCD中，<code>dispatch_sync</code>和<code>dispatch_async</code>是两个函数，前者用于派发同步任务，后者用于派发异步任务，二者使用格式如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dispatch task synchronously</span></div><div class="line"><span class="built_in">dispatch_sync</span>(someQueue1, ^&#123;</div><div class="line">    <span class="comment">// do something 1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// do something 2</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dispatch task asynchronously</span></div><div class="line"><span class="built_in">dispatch_async</span>(someQueue2, ^&#123;</div><div class="line">    <span class="comment">// do something 3</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// do something 4</span></div></pre></td></tr></table></figure>
<p><code>do something 2</code>一定会在<code>do something 1</code>完成之后执行，即所谓的<strong>同步</strong>。当执行到<code>dispatch_sync(...)</code>时，其上下文被阻塞，直到<code>dispatch_sync</code>派发的block被执行完毕。</p>
<p>根据我的理解：<strong>dispatch_sync派发的block的执行线程和dispatch_sync上下文线程是同一个线程</strong>。</p>
<p>P.S: 这个说法还没有找到权威的、直接明了的佐证。</p>
<p>而<code>do something 4</code>会立即执行，而不会等到<code>do something 3</code>执行完，即所谓<strong>异步</strong>。当执行到<code>dispatch_async(...)</code>时，其上下文不被阻塞，继续运行。</p>
<p>根据我的理解：<code>do something 3</code>和<code>do something 4</code>的执行线程往往不是同一个，即<strong>dispatch_async派发的block的执行线程和dispatch_async上下文线程不是同一个线程</strong>；</p>
<p>来看一个示例，如下有一段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. create a serial dispatch queue</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> serial_queue=</div><div class="line">dispatch_queue_create(<span class="string">"com.zhangbuhuai.test"</span>, DISPATCH_QUEUE_SERIAL);    <span class="comment">// Thread 1</span></div><div class="line">    </div><div class="line"><span class="comment">// 2. add tasks to serial dispatch queue</span></div><div class="line"><span class="comment">// 1) add a task synchronously</span></div><div class="line"><span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</div><div class="line">    sleep(<span class="number">3</span>);               <span class="comment">// 休眠3秒</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task 1"</span>);       <span class="comment">// Thread 1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 2) add a task synchronously too</span></div><div class="line"><span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task 2"</span>);       <span class="comment">// Thread 1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 3) add a task asynchronously</span></div><div class="line"><span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task 3"</span>);       <span class="comment">// Thread x  (x != 1)</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 4) add a task asynchronously too</span></div><div class="line"><span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task 4"</span>);       <span class="comment">// Thread x  (x != 1)</span></div><div class="line">&#125;);</div><div class="line">    </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"test end"</span>);         <span class="comment">// Thread 1</span></div></pre></td></tr></table></figure>
<p>假设创建<code>serial_queue</code>所在的上下文的执行线程为Thread 1，则测试结果是：<code>NSLog(@&quot;task 1&quot;)</code>和<code>NSLog(@&quot;task 2&quot;)</code>也都在Thread 1中执行，而<code>NSLog(@&quot;task 3&quot;)</code>和<code>NSLog(@&quot;task 4&quot;)</code>在别的Thread中执行。</p>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">task 1</div><div class="line">task 2</div><div class="line">test end</div><div class="line">task 3</div><div class="line">task 4</div></pre></td></tr></table></figure>
<p>结果说明，对于serial dispatch queue中的tasks，无论是同步派发还是异步派发，其执行顺序都遵循FIFO；同样，这个示例也可以直观阐述<code>dispatch_sync</code>和<code>dispatch_async</code>的不同效果。</p>
<p><strong>dispatch_sync和dispatch_async的使用时机</strong></p>
<p>在大多数时候，<code>dispatch_sync</code>和<code>dispatch_async</code>的使用时机非常清晰的：</p>
<ul>
<li>如果派发的task耗时长，不想让上下文线程被阻塞，就用<code>dispatch_async</code></li>
<li>如果要处理的代码比较短，想要实现代码保护（线程安全），选用<code>dispatch_sync</code></li>
</ul>
<p>P.S: 关于<code>dispatch_sync</code>与线程同步（代码保护）之间的关系，<del>以后补充</del>。</p>
<p>但有些时候，使用<code>dispatch_sync</code>或者<code>dispatch_async</code>都可以的情况下（譬如实现setter），就不是那么好选择了。</p>
<p>在《Effective Objective-C 2.0》Item 41（中文版P169）中看到非常重要的一句话：</p>
<blockquote>
<p>…，因为在执行异步派发时，需要拷贝块。</p>
</blockquote>
<p>我对这句话的理解是：</p>
<ul>
<li>执行同步派发（<code>dispatch_sync</code>）时，是不需要拷贝block的，这是因为<code>dispatch_sync</code>中所派发的task往往和当前上下文所处同一个Thread</li>
<li>执行异步派发（<code>dispatch_async</code>）时，需要拷贝block，这是因为<code>dispatch_async</code>中所派发的task往往和当前上下文不同于一个Thread</li>
</ul>
<p>所以，当选择<code>dispatch_sync</code>或者<code>dispatch_async</code>都可以的情况下，站在效率的角度，如果拷贝block的时间成本过高，则使用<code>dispatch_sync</code>；如果拷贝block的时间成本远低于执行block的时间成本，则使用<code>dispatch_async</code>。</p>
<p>如上所引用的「…，因为在执行异步派发时，需要拷贝块」这句话，在某种程度上佐证了上文提到的两个说法：</p>
<ul>
<li><code>dispatch_sync</code>派发的block的执行线程和<code>dispatch_sync</code>上下文线程是同一个线程；</li>
<li><code>dispatch_async</code>派发的block的执行线程和<code>dispatch_async</code>上下文线程不是同一个线程；</li>
</ul>
<p>———————-如下是补充内容———————-</p>
<h2 id="使用串行同步队列保护代码"><a href="#使用串行同步队列保护代码" class="headerlink" title="使用串行同步队列保护代码"></a>使用串行同步队列保护代码</h2><p>先来看一段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                            completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response,</div><div class="line">                                                        <span class="keyword">id</span> responseObject,</div><div class="line">                                                        <span class="built_in">NSError</span> *error))completionHandler</div><div class="line">&#123;</div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), ^&#123;  <span class="comment">// mark 1</span></div><div class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask completionHandler:completionHandler];  <span class="comment">// mark 2</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码是在AFNetworking框架的<code>AFURLSessionManager.m</code>中定义的，用于创建Data Task（<code>NSURLSessionDataTask</code>实例），这短短几行代码的逻辑是：</p>
<ol>
<li><code>mark 1</code>以同步派发的方式提交任务 – 创建一个<code>NSURLSessionDataTask</code>实例；</li>
<li><code>mark 2</code>处被阻塞；</li>
<li><code>NSURLSessionDataTask</code>实例创建完成，继续执行<code>mark 2</code>及后续代码；</li>
</ol>
<p>曾经对这几行代码比较疑惑：为什么使用<code>dispatch_sync</code>派发任务呢？</p>
<p>现在是能够理解了，上述<code>url_session_manager_creation_queue()</code>函数返回的其实是一个serial dispatch queue，这种组合（<code>dispatch_sync</code>+串行队列）即所谓的<strong>串行同步队列</strong>。串行同步队列常被用来保护临界资源，确保临界资源的线程安全，作用类似于同步锁，估摸着<code>dataTaskWithRequest:</code>并不是一个线程安全方法。</p>
<h2 id="使用dispatch-sync的注意事项"><a href="#使用dispatch-sync的注意事项" class="headerlink" title="使用dispatch_sync的注意事项"></a>使用dispatch_sync的注意事项</h2><p><a href="(https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html">Concurrency Programming Guide</a>)有包括关于使用<code>dispatch_sync</code>的提示：</p>
<blockquote>
<p>Important: You should never call the dispatch_sync or dispatch_sync_f function from a task that is executing in the same queue that you are planning to pass to the function. This is particularly important for serial queues, which are guaranteed to deadlock, but should also be avoided for concurrent queues.</p>
</blockquote>
<p>简单来说，在<code>dispatch_sync</code>嵌套使用时要注意：不能在一个嵌套中使用同一个serial dispatch queue，因为会发生死锁；</p>
<p>假设有如下这么一段代码要执行：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)test &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> aSerialDispatchQueue =</div><div class="line">    dispatch_queue_create(<span class="string">"I.am.an.iOS.developer"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">       </div><div class="line">    <span class="built_in">dispatch_sync</span>(aSerialDispatchQueue, ^&#123;</div><div class="line">        <span class="comment">// block 1</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Good Night, Benjamin"</span>);</div><div class="line">        <span class="built_in">dispatch_sync</span>(aSerialDispatchQueue, ^&#123;</div><div class="line">            <span class="comment">// block 2</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Good Night, Daisy"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自己试着执行以下就会发现：「<code>Good Night, Daisy</code>」这一句永远都无法被打印出来，原因很简单，程序产生了死锁。为什么会产生死锁呢？</p>
<p>可以想象<code>aSerialDispatchQueue</code>在底层实现中有一把锁，这把锁确保serial dispatch queue中只有一个block被执行，当执行到<code>block 1</code>代码时，这把锁为<code>block 1</code>所持有，当<code>block 1</code>执行完了，会释放之；然而<code>block 1</code>同步派发了一个任务<code>block 2</code>，同步派发意味着<code>block 1</code>会被阻塞，直到<code>block 2</code>被执行完成；但是这里产生了矛盾，<code>block 2</code>顺利执行的前提是<code>aSerialDispatchQueue</code>的这把锁被<code>block 1</code>释放，但是<code>block 1</code>释放这把锁的前提是<code>block 1</code>执行完成…这就是典型的dead lock。</p>
<p>这一段代码还好，比较容易避免，但是如果对GCD理解不深，更多的时候容易写出如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">// 巴拉巴拉，做了很多事情</span></div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Good Night, Benjamin"</span>);</div><div class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">// refresh UI</span></div><div class="line">    </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Good Night, Daisy"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的问题其实和上一段代码类似，只不过这里的serial dispatch queue恰好是main queue。</p>
<p>上述的死锁问题主要针对<strong>同步串行队列</strong>，对于<strong>同步并发队列</strong>，根据我的理解应该不存在这个deadlock问题，但是《Concurrency Programming Guide》明确说了：</p>
<blockquote>
<p>…This is particularly important for serial queues, which are guaranteed to deadlock, but should also be avoided for concurrent queues.</p>
</blockquote>
<p>P.S: 目前还不理解这个说辞。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">Concurrency Programming Guide</a></li>
<li><a href="https://book.douban.com/subject/21370593/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD/">GCD</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-nserror" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/19/nserror/" class="article-date">
  	<time datetime="2015-01-19T07:29:44.000Z" itemprop="datePublished">2015-01-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/19/nserror/">NSError分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在iOS开发中，<code>NSError</code>的使用非常常见，使用也比较简单，也正因为简单，所以对这一部分知识不甚注重。但是近期在做app底层网络封装时发现了一些问题。我使用的网络框架是AFNetworking，AFNetworking常常会返回一些错误信息，有时需要将这些错误信息告诉用户，通常做法是将<code>NSError#localizedDescription</code>以弹框的形式原原本本展现给用户（譬如“网络不畅”之类的），但是这样非常不友好，一是这些信息往往是英文，二是这些信息过于冗长，不够简洁。所以自然想到了对这些error信息进行包装。这就迫使我不得不去了解更多关于NSError相关的信息，本文着重叙述Error Domain和Error Code。</p>
<h2 id="Error-Domain"><a href="#Error-Domain" class="headerlink" title="Error Domain"></a>Error Domain</h2><p>首先，error domain是一个字符串。因为历史原因，在OS X中将errors分为不同的domains。譬如，对于Carbon框架的error，归于OSStatus domain（<code>NSOSStatusErrorDomain</code>），对于POSIX error，归于<code>NSPOSIXErrorDomain</code>，而对于我们的iOS开发，一般使用<code>NSCocoaErrorDomain</code>。NSError.h定义了四个domain，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Predefined domain for errors from most AppKit and Foundation APIs.</span></div><div class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSCocoaErrorDomain</span>;</div><div class="line">    </div><div class="line"><span class="comment">// Other predefined domains; value of "code" will correspond to preexisting values in these domains.</span></div><div class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSPOSIXErrorDomain</span>;</div><div class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSOSStatusErrorDomain</span>;</div><div class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSMachErrorDomain</span>;</div></pre></td></tr></table></figure>
<p>除了上述的四个domain之外，不同的framework甚至一些classes group（相关的几个classes）也定义了自己的domain，譬如对于Web Kit framework，定义了<code>WebKitErrorDomain</code>，而更常见的，URL相关的classes定义了<code>NSURLErrorDomain</code>。</p>
<p>Domains非常有用，特别当程序非常复杂庞大时，官方文档是这么说的：</p>
<blockquote>
<p>Domains serve several useful purposes. They give Cocoa programs a way to identify the OS X subsystem that is detecting an error. They also help to prevent collisions between error codes from different subsystems with the same numeric value. In addition, domains allow for a causal relationship between error codes based on the layering of subsystems; for example, an error in the NSOSStatusErrorDomain may have an underlying error in the NSMachErrorDomain.</p>
</blockquote>
<p>用户也可以为自己的framework或者app定义自己的domain，官方推荐的domain命名规则是：<br><code>com.company.framework_or_app.ErrorDomain</code>。</p>
<h2 id="Error-Code"><a href="#Error-Code" class="headerlink" title="Error Code"></a>Error Code</h2><p>Error Code的类型是signed integer。Error Code指定了特殊的错误。这个信息对于程序开发来说极为有用。比如访问URL资源timeout错误对应的是<code>NSURLErrorTimedOut</code>（<code>-1001</code>）。</p>
<p>那么如何知道各个error code对应什么样的值呢？iOS开发中常用的error code所对应的头文件如下：</p>
<ul>
<li>Foundation/FoundationErrors.h - Generic Foundation error codes</li>
<li>CoreData/CoreDataErrors.h - Core Data error codes</li>
<li>Foundation/NSURLError.h - URL error codes</li>
</ul>
<p>以Foundation/NSURLError.h为例，其中的URLError Code值从<code>NSURLErrorDataLengthExceedsMaximum</code>到<code>NSURLErrorCancelled</code>，二者分别对应<code>-1103</code>和<code>-999</code>。如果对所有网络error笼统处理，这两个值可以为我所用。</p>
<h2 id="The-User-Info-Dictionary"><a href="#The-User-Info-Dictionary" class="headerlink" title="The User Info Dictionary"></a>The User Info Dictionary</h2><p>Every NSError object has a “user info” dictionary to hold error information beyond domain and code.</p>
<p>User info可以包含很多自定义信息，最常用的或许是localized error information。访问localized error information有两种方式，其一是访问NSError的localizedDescription属性，其二是访问<code>NSError#userInfo</code>的<code>NSLocalizedDescriptionKey</code>域。</p>
<p>关于user info dictionary，比较常见，这里不多讲了，更多内容参考《Error Handling Programming Guide》。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Error/">Error</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-blog-rules" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/01/blog-rules/" class="article-date">
  	<time datetime="2014-12-31T16:00:00.000Z" itemprop="datePublished">2015-01-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/01/blog-rules/">约定</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为了保证一致性以及叙述方便，本博客的博文遵循一些约束。</p>
<p><strong>属性/方法表示法</strong></p>
<ul>
<li><code>A#p</code>表示<code>A</code>的实例对象的实例属性<code>p</code>，其中<code>A</code>是类型名；</li>
<li><code>A.p</code>表示<code>A</code>的类型实例<code>p</code>，其中<code>A</code>是类型名；</li>
<li><code>a.p</code>表示对象<code>a</code>的实例属性<code>p</code>，其中<code>a</code>是一个实例对象；</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/9/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>