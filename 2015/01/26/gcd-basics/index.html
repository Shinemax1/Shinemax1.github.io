<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>GCD基础知识 | Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="并行和并发在英文世界里，「并行」和「并发」的区别比较清晰，「并行」对应「parallelism」，「并发」对应「concurrency」；但在中文世界里二者仅一字之差，两个概念非常容易弄混淆。
各种资料对并行和并发有各种各样的解释和比喻。我比较喜欢的一种，是播客节目内核恐慌中的主播Rio的描述，大概意思是：

「并发」和「并行」是一种计算模型，使得计算机能够在同一时间处理多个任务；「并发」表示逻辑">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD基础知识">
<meta property="og:url" content="http://shinemax1.github.io/2015/01/26/gcd-basics/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="并行和并发在英文世界里，「并行」和「并发」的区别比较清晰，「并行」对应「parallelism」，「并发」对应「concurrency」；但在中文世界里二者仅一字之差，两个概念非常容易弄混淆。
各种资料对并行和并发有各种各样的解释和比喻。我比较喜欢的一种，是播客节目内核恐慌中的主播Rio的描述，大概意思是：

「并发」和「并行」是一种计算模型，使得计算机能够在同一时间处理多个任务；「并发」表示逻辑">
<meta property="og:updated_time" content="2016-08-08T12:02:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GCD基础知识">
<meta name="twitter:description" content="并行和并发在英文世界里，「并行」和「并发」的区别比较清晰，「并行」对应「parallelism」，「并发」对应「concurrency」；但在中文世界里二者仅一字之差，两个概念非常容易弄混淆。
各种资料对并行和并发有各种各样的解释和比喻。我比较喜欢的一种，是播客节目内核恐慌中的主播Rio的描述，大概意思是：

「并发」和「并行」是一种计算模型，使得计算机能够在同一时间处理多个任务；「并发」表示逻辑">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.25px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 13.75px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 16.25px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.25px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 18.75px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 12.5px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.25px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 13.75px;">Tools</a> <a href="/tags/Transition/" style="font-size: 12.5px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 17.5px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js基础/" style="font-size: 20px;">js基础</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，Android开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-gcd-basics" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/26/gcd-basics/" class="article-date">
  	<time datetime="2015-01-26T12:05:56.000Z" itemprop="datePublished">2015-01-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      GCD基础知识
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD/">GCD</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p>在英文世界里，「并行」和「并发」的区别比较清晰，「并行」对应「parallelism」，「并发」对应「concurrency」；但在中文世界里二者仅一字之差，两个概念非常容易弄混淆。</p>
<p>各种资料对<strong>并行</strong>和<strong>并发</strong>有各种各样的解释和比喻。我比较喜欢的一种，是播客节目<a href="http://ipn.li/kernelpanic/13" target="_blank" rel="external">内核恐慌</a>中的主播Rio的描述，大概意思是：</p>
<blockquote>
<p>「并发」和「并行」是一种计算模型，使得计算机能够在同一时间处理多个任务；「并发」表示逻辑概念上的「同时」，「并行」表示物理概念上的「同时」。</p>
</blockquote>
<p>简单来说，若说两个任务A和B并发执行，则表示任务A和任务B在同一时间段里被执行（更多的可能是二者交替执行）；若说任务A和B并行执行，则表示任务A和任务B在同时被执行（这要求计算机有多个运算器）；</p>
<p>一句话：并行要求并发，但并发并不能保证并行。</p>
<p>P.S: 关于并发和并行，《<a href="https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1" target="_blank" rel="external">Grand Central Dispatch In-Depth: Part 1/2</a>》中有更详细的图文解释。</p>
<h2 id="Dispatch-Queues介绍"><a href="#Dispatch-Queues介绍" class="headerlink" title="Dispatch Queues介绍"></a>Dispatch Queues介绍</h2><p>Dispatch Queues是GCD处理异步任务和并发任务的关键载体，简而言之，在GCD中，将task放入某个Dispatch Queue中，然后等待系统去处理之。</p>
<p>Dispatch queue是object-like structure，也就是说Dispatch queue在Objective-C中不是类结构，而是类类结构。dispatch queue对task的管理都遵循FIFO。GCD提供了一些公共的dispatch queue，但是用户也可以自定义一些dispatch queue；iOS对dispatch queue做了归类，分为三类：</p>
<ul>
<li>Serial Dispatch Queue</li>
<li>Concurrent Dispatch Queue</li>
<li>Main Dispatch Queue</li>
</ul>
<h3 id="Serial-Dispatch-Queue"><a href="#Serial-Dispatch-Queue" class="headerlink" title="Serial Dispatch Queue"></a>Serial Dispatch Queue</h3><p>顾名思义，serial dispatch queue中的block按照先进先出（FIFO）的顺序去执行，实际上为单线程执行。即每次从queue中取出一个task进行处理；用户可以根据需要创建任意多的serial dispatch queue，serial dispatch queue彼此之间是并发的；</p>
<p>创建serial dispatch queue使用<code>dispatch_queue_create</code>方法，指定其第二个参数为<code>DISPATCH_QUEUE_SERIAL</code>（即<code>NULL</code>）即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue;</div><div class="line">queue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure>
<p>注意：如果不算“Main Dispatch Queue”，系统中不存在所谓的global serial dispatch queue。</p>
<p>P.S: main dispatch queue其实也算serial dispatch queue，后文有述。</p>
<h3 id="Concurrent-Dispatch-Queue"><a href="#Concurrent-Dispatch-Queue" class="headerlink" title="Concurrent Dispatch Queue"></a>Concurrent Dispatch Queue</h3><p>相对于Serial Dispatch Queue，Concurrent Dispatch Queue一次性并发执行一个或者多个task；和Serial Dispatch Queue不同，系统提供了四个global concurrent queue，使用<code>dispatch_get_global_queue</code>函数就可以获取这些global concurrent queue；</p>
<p>和Serial Dispatch Queue一样，用户也可以根据需要自己定义concurrent queue；创建concurrent dispatch queue也使用<code>dispatch_queue_create</code>方法，所不同的是需要指定其第二个参数为<code>DISPATCH_QUEUE_CONCURRENT</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue;</div><div class="line">queue = dispatch_queue_create(<span class="string">"com.example.MyConcurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<p>P.S: 根据我的理解，对于concurrent queue，其管理的task可能在多个不同thread上执行，至于dispatch queue管理多少个thread是未知的，这要视系统资源而定，用户无需为此烦扰。</p>
<h3 id="Main-Dispatch-Queue"><a href="#Main-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue"></a>Main Dispatch Queue</h3><p>关于Main Dispatch Queue，《Concurrency Programming Guide》（Apple官方文档）的描述如下：</p>
<blockquote>
<p>The main dispatch queue is a globally available serial queue that executes tasks on the application’s main thread.</p>
</blockquote>
<p>根据我的理解，application的主要任务（譬如UI管理之类的）都在main dispatch queue中完成；根据文档的描述，main dispatch queue中的task都在一个thread中运行，即application’s main thread（thread 1）。</p>
<p>所以，如果想要更新UI，则必须在main dispatch queue中处理，获取main dispatch queue也很容易，调用<code>dispatch_get_main_queue()</code>函数即可。</p>
<h3 id="关于Dispatch-Queues的一些误解"><a href="#关于Dispatch-Queues的一些误解" class="headerlink" title="关于Dispatch Queues的一些误解"></a>关于Dispatch Queues的一些误解</h3><p>在学习GCD过程中，我一路上有许多关于dispatch的错误理解，如下是总结：</p>
<ul>
<li>不存在所谓的「同步队列」和「异步队列」</li>
</ul>
<p>同步或异步描述的是task与其上下文之间的关系，所以，我觉得「同步队列」和「异步队列」对于Objective-C的GCD而言是不靠谱的概念。</p>
<p>P.S: 补充！虽然没有「同步队列」和「异步队列」的说法，但是有「同步串行队列」和「同步并发队列」的概念。</p>
<ul>
<li>Serial Dispatch Queue上的tasks并非只在同一个thread上执行</li>
</ul>
<p>吾尝以为serial queue上的tasks都是在同一个thread上运行，后来明白了不是这样的，对于那些同步请求的任务，譬如使用dispatch_sync函数添加到serial dispatch queue中的任务，其运行的task往往与所在的上下文是同一个thread；对于那些异步请求的任务，譬如使用dispatch_async函数添加到serial dispatch queue中的任务，其运行的task往往是另一个的thread。举例说明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> aSerialQueue = dispatch_queue_create(<span class="string">"haha"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_sync</span>(aSerialQueue, ^&#123;</div><div class="line">        <span class="comment">// block 1</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current 1: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(aSerialQueue, ^&#123;</div><div class="line">        <span class="comment">// block 2</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current 2: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 执行结果：</span></div><div class="line"><span class="comment">// current 1: &lt;NSThread: 0x7f8f397152f0&gt;&#123;number = 1, name = main&#125;</span></div><div class="line"><span class="comment">// current 2: &lt;NSThread: 0x7f8f39464db0&gt;&#123;number = 2, name = (null)&#125;</span></div></pre></td></tr></table></figure>
<p>block 1和block 2都由同一个serial dispatch queue管理，但它们的执行线程显然不同，前者的执行线程是thread 1，后者的执行线程是thread 2。</p>
<ul>
<li>dispatch queue和thread并不存在一对一或者一对多的关系</li>
</ul>
<p>通过设置断点等测试手段可以知道可能多个dispatch queue共用一个thread，也可能一个dispatch queue中的tasks在多个不同threads上执行。</p>
<p>总之，根据我的理解，thread和dispatch queue之间没有从属关系。</p>
<h2 id="dispatch-sync和dispatch-async"><a href="#dispatch-sync和dispatch-async" class="headerlink" title="dispatch_sync和dispatch_async"></a>dispatch_sync和dispatch_async</h2><p>在GCD中，<code>dispatch_sync</code>和<code>dispatch_async</code>是两个函数，前者用于派发同步任务，后者用于派发异步任务，二者使用格式如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dispatch task synchronously</span></div><div class="line"><span class="built_in">dispatch_sync</span>(someQueue1, ^&#123;</div><div class="line">    <span class="comment">// do something 1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// do something 2</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dispatch task asynchronously</span></div><div class="line"><span class="built_in">dispatch_async</span>(someQueue2, ^&#123;</div><div class="line">    <span class="comment">// do something 3</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// do something 4</span></div></pre></td></tr></table></figure>
<p><code>do something 2</code>一定会在<code>do something 1</code>完成之后执行，即所谓的<strong>同步</strong>。当执行到<code>dispatch_sync(...)</code>时，其上下文被阻塞，直到<code>dispatch_sync</code>派发的block被执行完毕。</p>
<p>根据我的理解：<strong>dispatch_sync派发的block的执行线程和dispatch_sync上下文线程是同一个线程</strong>。</p>
<p>P.S: 这个说法还没有找到权威的、直接明了的佐证。</p>
<p>而<code>do something 4</code>会立即执行，而不会等到<code>do something 3</code>执行完，即所谓<strong>异步</strong>。当执行到<code>dispatch_async(...)</code>时，其上下文不被阻塞，继续运行。</p>
<p>根据我的理解：<code>do something 3</code>和<code>do something 4</code>的执行线程往往不是同一个，即<strong>dispatch_async派发的block的执行线程和dispatch_async上下文线程不是同一个线程</strong>；</p>
<p>来看一个示例，如下有一段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. create a serial dispatch queue</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> serial_queue=</div><div class="line">dispatch_queue_create(<span class="string">"com.zhangbuhuai.test"</span>, DISPATCH_QUEUE_SERIAL);    <span class="comment">// Thread 1</span></div><div class="line">    </div><div class="line"><span class="comment">// 2. add tasks to serial dispatch queue</span></div><div class="line"><span class="comment">// 1) add a task synchronously</span></div><div class="line"><span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</div><div class="line">    sleep(<span class="number">3</span>);               <span class="comment">// 休眠3秒</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task 1"</span>);       <span class="comment">// Thread 1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 2) add a task synchronously too</span></div><div class="line"><span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task 2"</span>);       <span class="comment">// Thread 1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 3) add a task asynchronously</span></div><div class="line"><span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task 3"</span>);       <span class="comment">// Thread x  (x != 1)</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 4) add a task asynchronously too</span></div><div class="line"><span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task 4"</span>);       <span class="comment">// Thread x  (x != 1)</span></div><div class="line">&#125;);</div><div class="line">    </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"test end"</span>);         <span class="comment">// Thread 1</span></div></pre></td></tr></table></figure>
<p>假设创建<code>serial_queue</code>所在的上下文的执行线程为Thread 1，则测试结果是：<code>NSLog(@&quot;task 1&quot;)</code>和<code>NSLog(@&quot;task 2&quot;)</code>也都在Thread 1中执行，而<code>NSLog(@&quot;task 3&quot;)</code>和<code>NSLog(@&quot;task 4&quot;)</code>在别的Thread中执行。</p>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">task 1</div><div class="line">task 2</div><div class="line">test end</div><div class="line">task 3</div><div class="line">task 4</div></pre></td></tr></table></figure>
<p>结果说明，对于serial dispatch queue中的tasks，无论是同步派发还是异步派发，其执行顺序都遵循FIFO；同样，这个示例也可以直观阐述<code>dispatch_sync</code>和<code>dispatch_async</code>的不同效果。</p>
<p><strong>dispatch_sync和dispatch_async的使用时机</strong></p>
<p>在大多数时候，<code>dispatch_sync</code>和<code>dispatch_async</code>的使用时机非常清晰的：</p>
<ul>
<li>如果派发的task耗时长，不想让上下文线程被阻塞，就用<code>dispatch_async</code></li>
<li>如果要处理的代码比较短，想要实现代码保护（线程安全），选用<code>dispatch_sync</code></li>
</ul>
<p>P.S: 关于<code>dispatch_sync</code>与线程同步（代码保护）之间的关系，<del>以后补充</del>。</p>
<p>但有些时候，使用<code>dispatch_sync</code>或者<code>dispatch_async</code>都可以的情况下（譬如实现setter），就不是那么好选择了。</p>
<p>在《Effective Objective-C 2.0》Item 41（中文版P169）中看到非常重要的一句话：</p>
<blockquote>
<p>…，因为在执行异步派发时，需要拷贝块。</p>
</blockquote>
<p>我对这句话的理解是：</p>
<ul>
<li>执行同步派发（<code>dispatch_sync</code>）时，是不需要拷贝block的，这是因为<code>dispatch_sync</code>中所派发的task往往和当前上下文所处同一个Thread</li>
<li>执行异步派发（<code>dispatch_async</code>）时，需要拷贝block，这是因为<code>dispatch_async</code>中所派发的task往往和当前上下文不同于一个Thread</li>
</ul>
<p>所以，当选择<code>dispatch_sync</code>或者<code>dispatch_async</code>都可以的情况下，站在效率的角度，如果拷贝block的时间成本过高，则使用<code>dispatch_sync</code>；如果拷贝block的时间成本远低于执行block的时间成本，则使用<code>dispatch_async</code>。</p>
<p>如上所引用的「…，因为在执行异步派发时，需要拷贝块」这句话，在某种程度上佐证了上文提到的两个说法：</p>
<ul>
<li><code>dispatch_sync</code>派发的block的执行线程和<code>dispatch_sync</code>上下文线程是同一个线程；</li>
<li><code>dispatch_async</code>派发的block的执行线程和<code>dispatch_async</code>上下文线程不是同一个线程；</li>
</ul>
<p>———————-如下是补充内容———————-</p>
<h2 id="使用串行同步队列保护代码"><a href="#使用串行同步队列保护代码" class="headerlink" title="使用串行同步队列保护代码"></a>使用串行同步队列保护代码</h2><p>先来看一段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                            completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response,</div><div class="line">                                                        <span class="keyword">id</span> responseObject,</div><div class="line">                                                        <span class="built_in">NSError</span> *error))completionHandler</div><div class="line">&#123;</div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), ^&#123;  <span class="comment">// mark 1</span></div><div class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask completionHandler:completionHandler];  <span class="comment">// mark 2</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码是在AFNetworking框架的<code>AFURLSessionManager.m</code>中定义的，用于创建Data Task（<code>NSURLSessionDataTask</code>实例），这短短几行代码的逻辑是：</p>
<ol>
<li><code>mark 1</code>以同步派发的方式提交任务 – 创建一个<code>NSURLSessionDataTask</code>实例；</li>
<li><code>mark 2</code>处被阻塞；</li>
<li><code>NSURLSessionDataTask</code>实例创建完成，继续执行<code>mark 2</code>及后续代码；</li>
</ol>
<p>曾经对这几行代码比较疑惑：为什么使用<code>dispatch_sync</code>派发任务呢？</p>
<p>现在是能够理解了，上述<code>url_session_manager_creation_queue()</code>函数返回的其实是一个serial dispatch queue，这种组合（<code>dispatch_sync</code>+串行队列）即所谓的<strong>串行同步队列</strong>。串行同步队列常被用来保护临界资源，确保临界资源的线程安全，作用类似于同步锁，估摸着<code>dataTaskWithRequest:</code>并不是一个线程安全方法。</p>
<h2 id="使用dispatch-sync的注意事项"><a href="#使用dispatch-sync的注意事项" class="headerlink" title="使用dispatch_sync的注意事项"></a>使用dispatch_sync的注意事项</h2><p><a href="(https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html">Concurrency Programming Guide</a>)有包括关于使用<code>dispatch_sync</code>的提示：</p>
<blockquote>
<p>Important: You should never call the dispatch_sync or dispatch_sync_f function from a task that is executing in the same queue that you are planning to pass to the function. This is particularly important for serial queues, which are guaranteed to deadlock, but should also be avoided for concurrent queues.</p>
</blockquote>
<p>简单来说，在<code>dispatch_sync</code>嵌套使用时要注意：不能在一个嵌套中使用同一个serial dispatch queue，因为会发生死锁；</p>
<p>假设有如下这么一段代码要执行：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)test &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> aSerialDispatchQueue =</div><div class="line">    dispatch_queue_create(<span class="string">"I.am.an.iOS.developer"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">       </div><div class="line">    <span class="built_in">dispatch_sync</span>(aSerialDispatchQueue, ^&#123;</div><div class="line">        <span class="comment">// block 1</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Good Night, Benjamin"</span>);</div><div class="line">        <span class="built_in">dispatch_sync</span>(aSerialDispatchQueue, ^&#123;</div><div class="line">            <span class="comment">// block 2</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Good Night, Daisy"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自己试着执行以下就会发现：「<code>Good Night, Daisy</code>」这一句永远都无法被打印出来，原因很简单，程序产生了死锁。为什么会产生死锁呢？</p>
<p>可以想象<code>aSerialDispatchQueue</code>在底层实现中有一把锁，这把锁确保serial dispatch queue中只有一个block被执行，当执行到<code>block 1</code>代码时，这把锁为<code>block 1</code>所持有，当<code>block 1</code>执行完了，会释放之；然而<code>block 1</code>同步派发了一个任务<code>block 2</code>，同步派发意味着<code>block 1</code>会被阻塞，直到<code>block 2</code>被执行完成；但是这里产生了矛盾，<code>block 2</code>顺利执行的前提是<code>aSerialDispatchQueue</code>的这把锁被<code>block 1</code>释放，但是<code>block 1</code>释放这把锁的前提是<code>block 1</code>执行完成…这就是典型的dead lock。</p>
<p>这一段代码还好，比较容易避免，但是如果对GCD理解不深，更多的时候容易写出如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">// 巴拉巴拉，做了很多事情</span></div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Good Night, Benjamin"</span>);</div><div class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">// refresh UI</span></div><div class="line">    </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Good Night, Daisy"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的问题其实和上一段代码类似，只不过这里的serial dispatch queue恰好是main queue。</p>
<p>上述的死锁问题主要针对<strong>同步串行队列</strong>，对于<strong>同步并发队列</strong>，根据我的理解应该不存在这个deadlock问题，但是《Concurrency Programming Guide》明确说了：</p>
<blockquote>
<p>…This is particularly important for serial queues, which are guaranteed to deadlock, but should also be avoided for concurrent queues.</p>
</blockquote>
<p>P.S: 目前还不理解这个说辞。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">Concurrency Programming Guide</a></li>
<li><a href="https://book.douban.com/subject/21370593/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/01/26/using-gcd-part-1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          GCD实践之（一）使用GCD保护property
        
      </div>
    </a>
  
  
    <a href="/2015/01/19/nserror/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">NSError分析</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>








<section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'Shinemax'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>

</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>