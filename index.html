<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.25px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 13.75px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 16.25px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.25px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 17.5px;">Objective-C</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/ReactiveCocoa/" style="font-size: 12.5px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/SSR/" style="font-size: 10px;">SSR</a> <a href="/tags/Sublime-Text/" style="font-size: 11.25px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 13.75px;">Tools</a> <a href="/tags/Transition/" style="font-size: 12.5px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 18.75px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js/" style="font-size: 11.25px;">js</a> <a href="/tags/js基础/" style="font-size: 20px;">js基础</a> <a href="/tags/node-js/" style="font-size: 11.25px;">node.js</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/事件环/" style="font-size: 10px;">事件环</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/宏任务/" style="font-size: 10px;">宏任务</a> <a href="/tags/微任务/" style="font-size: 10px;">微任务</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/流/" style="font-size: 10px;">流</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/面试/" style="font-size: 11.25px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，全栈开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-ReactSSR" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/20/ReactSSR/" class="article-date">
  	<time datetime="2018-07-20T05:00:40.000Z" itemprop="datePublished">2018-07-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/20/ReactSSR/">React+Redux+socket.io+SSR+express+pm2+mongondb打造你的聊天app</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本文是直接着手SSR部分的，需要大家有一定的React,node和webpack基础能力</strong></p>
<h1 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h1><blockquote>
<p><code>Server Slide Rendering</code>服务端渲染,又简写为<code>SSR</code>，他一般被用在我们的<code>SPA（Single-Page Application）</code>，即单页应用。</p>
</blockquote>
<h2 id="为什么要用SSR？"><a href="#为什么要用SSR？" class="headerlink" title="为什么要用SSR？"></a>为什么要用SSR？</h2><p>首先我们需要知道SSR对于SPA的<code>好处</code>，<code>优势</code>是什么。</p>
<ul>
<li>更好的<code>SEO（Search Engine Optimization）</code>，<code>SEO</code>是搜索引擎优化，简而言之就是针对百度这些搜索引擎，可以让他们搜索到我们的应用。这里可能会有误区，就是我也可以在index.html上写<code>SEO</code>，为什么会不起作用。因为React、Vue的原理是<strong>客户端渲染</strong>，通过浏览器去加载js、css，有一个时间上的<code>延迟</code>，而搜索引擎不会管你的<code>延迟</code>，他就觉得你如果没加载出来就是没有的，所以是搜不到的。</li>
<li>解决一开始的<code>白屏渲染</code>，上面讲了React的渲染原理，而<strong>SSR服务端渲染</strong>是通过服务端请求数据，因为服务端内网的请求快，性能好所以会更快的加载所有的文件，最后把下载渲染后的页面返回给客户端。</li>
</ul>
<h2 id="上面提到了服务端渲染和客户端渲染，那么它们的区别是什么呢？"><a href="#上面提到了服务端渲染和客户端渲染，那么它们的区别是什么呢？" class="headerlink" title="上面提到了服务端渲染和客户端渲染，那么它们的区别是什么呢？"></a>上面提到了服务端渲染和客户端渲染，那么它们的区别是什么呢？</h2><p><strong>客户端渲染路线：</strong></p>
<ol>
<li>请求一个html  </li>
<li>服务端返回一个html  </li>
<li>浏览器下载html里面的js/css文件  </li>
<li>等待js文件下载完成  </li>
<li>等待js加载并初始化完成  </li>
<li>js代码终于可以运行，由js代码向后端请求数据( ajax/fetch )  </li>
<li>等待后端数据返回  </li>
<li>react-dom( 客户端 )从无到完整地，把数据渲染为响应页面</li>
</ol>
<p><strong>服务端渲染路线：</strong></p>
<ol>
<li>请求一个html  </li>
<li>服务端请求数据( 内网请求快 )  </li>
<li>服务器初始渲染（服务端性能好，较快）  </li>
<li>服务端返回已经有正确内容的页面  </li>
<li>客户端请求js/css文件  </li>
<li>等待js文件下载完成  </li>
<li>等待js加载并初始化完成  </li>
<li>react-dom( 客户端 )把剩下一部分渲染完成( 内容小，渲染快 )</li>
</ol>
<blockquote>
<p>其主要区别就在于，客户端从<code>无到有的</code>渲染，服务端是先在服务端<code>渲染一部分</code>，在再客户端<code>渲染一小部分</code>。</p>
</blockquote>
<h3 id="我们怎么去做服务端渲染？"><a href="#我们怎么去做服务端渲染？" class="headerlink" title="我们怎么去做服务端渲染？"></a>我们怎么去做服务端渲染？</h3><p>我们这里是用express框架，node做中间层进行服务端渲染。通过将<code>首页进行同构处理</code>，让服务端，通过调用<code>ReactDOMServer.renderToNodeStream</code>方法把<code>Virtual DOM</code>转换成<code>HTML字符串</code>返回给客户端，从而达到服务端渲染的目的。</p>
<p><strong>这里项目起步是已经做完前端和后端，是把已经写好的React Demo直接拿来用</strong></p>
<h1 id="服务端渲染开始"><a href="#服务端渲染开始" class="headerlink" title="服务端渲染开始"></a>服务端渲染开始</h1><p>既然是首页SSR，首先我们要把首页对应的<code>index.js</code>抽离出来放入我们服务端对应的<code>server.js</code>，那么<code>index.js</code>中组件对应的<code>静态css和js文件</code>我们需要打包出来。</p>
<h2 id="用webpack打包文件到build文件夹"><a href="#用webpack打包文件到build文件夹" class="headerlink" title="用webpack打包文件到build文件夹"></a>用webpack打包文件到build文件夹</h2><p>我们来运行<code>npm run build</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/1644f56948725d9f?w=1148&amp;h=592&amp;f=jpeg&amp;s=129956" alt=""></p>
<p><strong>我们可以看到<code>两个重要的文件夹</code>，一个是js文件夹，一个是css文件夹，他就是我们项目的js和css<code>静态资源文件</code></strong></p>
<h2 id="将打包后的build文件能在服务端server-js中访问到"><a href="#将打包后的build文件能在服务端server-js中访问到" class="headerlink" title="将打包后的build文件能在服务端server.js中访问到"></a>将打包后的<code>build</code>文件能在服务端<code>server.js</code>中访问到</h2><p><strong>因为是服务端，我们需要用到express</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span></div><div class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'../src/reducer'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> userRouter <span class="keyword">from</span> <span class="string">'./routes/user'</span></div><div class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'body-parser'</span></div><div class="line"><span class="keyword">import</span> cookieParser <span class="keyword">from</span> <span class="string">'cookie-parser'</span></div><div class="line"><span class="keyword">import</span> model <span class="keyword">from</span> <span class="string">'./model'</span></div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></div><div class="line"><span class="keyword">import</span> https <span class="keyword">from</span> <span class="string">'http'</span></div><div class="line"><span class="keyword">import</span> socketIo <span class="keyword">from</span> <span class="string">'socket.io'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> Chat = model.getModel(<span class="string">'chat'</span>)</div><div class="line"><span class="comment">//新建app</span></div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"></div><div class="line"><span class="comment">//work with express</span></div><div class="line"><span class="keyword">const</span> server = https.Server(app)</div><div class="line"><span class="keyword">const</span> io = socketIo(server)</div><div class="line">io.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</div><div class="line">  socket.on(<span class="string">'sendmsg'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> &#123;<span class="keyword">from</span>,to,msg&#125; = data</div><div class="line">    <span class="keyword">let</span> chatid = [<span class="keyword">from</span>,to].sort().join(<span class="string">'_'</span>)</div><div class="line">    Chat.create(&#123;chatid,<span class="keyword">from</span>,to,<span class="attr">content</span>:msg&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e,d</span>)</span>&#123;</div><div class="line">      io.emit(<span class="string">'recvmsg'</span>,<span class="built_in">Object</span>.assign(&#123;&#125;,d._doc))</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// console.log(data)</span></div><div class="line">    <span class="comment">// //广播给全局</span></div><div class="line">    <span class="comment">// io.emit('recvmsg',data)</span></div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.use(cookieParser())</div><div class="line">app.use(bodyParser.json())</div><div class="line">app.use(<span class="string">'/user'</span>,userRouter)</div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(req.url.startsWith(<span class="string">'/user/'</span>) || req.url.startsWith(<span class="string">'/static/'</span>))&#123;</div><div class="line">    <span class="keyword">return</span> next()</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果访问url根路径是user或者static就返回打包后的主页面</span></div><div class="line">  <span class="keyword">return</span> res.sendFile(path.resolve(<span class="string">'build/index.html'</span>))</div><div class="line">&#125;)</div><div class="line"><span class="comment">//映射build文件路径，项目上要使用</span></div><div class="line">app.use(<span class="string">'/'</span>,express.static(path.resolve(<span class="string">'build'</span>)))</div><div class="line"></div><div class="line"></div><div class="line">server.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'开启成功'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>主要看上面的<code>app.use(&#39;/&#39;,express.static(path.resolve(&#39;build&#39;)))</code>和<code>res.sendFile(path.resolve(&#39;build/index.html&#39;))</code>这两段代码。</li>
<li>他们把打包后的主页放入服务端代码中返回给客户端。</li>
<li>因为上面我用了<code>import</code>代码，所以我们在开发环境中需要用到<code>babel-cli</code>里的<code>babel-node</code>来编译。</li>
<li>安装<code>npm --registry https://registry.npm.taobao.org</code> i babel-cli -S`，大家如果觉得这样切换源麻烦，可以下个<a href="https://www.npmjs.com/package/nrm" target="_blank" rel="external">nrm</a>，360度无死角切换各种源，好用！</li>
<li>我们需要修改<code>package.json</code>的启动服务器的<code>npm scripts</code>。<code>&quot;server&quot;: &quot;NODE_ENV=test nodemon --exec babel-node server/server.js&quot;</code></li>
<li><code>cross-env</code>跨平台设置node环境变量的插件。</li>
<li>nodemon和supervisor一样是watch服务端文件，只要一改变就会重新运行，相当于<code>热重载</code>。nodemon<code>更轻量</code></li>
<li>最后我们来跑一下<code>npm run server</code>,就能看到服务端跑起来了。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/1644f684849a3656?w=562&amp;h=994&amp;f=jpeg&amp;s=58584" alt=""></p>
<h2 id="ReactDOMServer-renderToString-ReactDOMServer-renderToNodeStream"><a href="#ReactDOMServer-renderToString-ReactDOMServer-renderToNodeStream" class="headerlink" title="ReactDOMServer.renderToString/ReactDOMServer.renderToNodeStream"></a>ReactDOMServer.renderToString/ReactDOMServer.renderToNodeStream</h2><ul>
<li>这里我们先讲一下在<code>浏览器中</code>，<code>React.createElement</code>把React的类进行<code>实例化</code>，实例化后的组件可以进行<code>mount</code>，最后通过R<code>eact.render</code>渲染到我们的客户端浏览器界面。</li>
<li>而在服务器中我们可以通过 <code>renderToString</code>或者<code>renderToNodeStream</code>方法把React实例化的组件，直接渲染生成html标签。那么这俩个有什么区别呢？</li>
<li><code>renderToNodeStream</code>是React 16最新发布的东西，它支持直接渲染到节点流。渲染到流可以减少你的内容的第一个字节<code>（TTFB）</code>的时间，在文档的下一部分生成之前，将文档的开头至结尾发送到浏览器。 当内容从服务器流式传输时，浏览器将开始解析HTML文档。速度是renderToString的三倍，所以我们在这里使用<code>renderToNodeStream</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123;renderToStaticMarkup,renderToNodeStream&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> &#123;StaticRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  createStore,</div><div class="line">  applyMiddleware,</div><div class="line">  <span class="comment">//组合函数用的</span></div><div class="line">  compose</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/App'</span></div><div class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'../src/reducer'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> userRouter <span class="keyword">from</span> <span class="string">'./routes/user'</span></div><div class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'body-parser'</span></div><div class="line"><span class="keyword">import</span> cookieParser <span class="keyword">from</span> <span class="string">'cookie-parser'</span></div><div class="line"><span class="keyword">import</span> model <span class="keyword">from</span> <span class="string">'./model'</span></div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></div><div class="line"><span class="keyword">import</span> https <span class="keyword">from</span> <span class="string">'http'</span></div><div class="line"><span class="keyword">import</span> socketIo <span class="keyword">from</span> <span class="string">'socket.io'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Chat = model.getModel(<span class="string">'chat'</span>)</div><div class="line"><span class="comment">//新建app</span></div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"></div><div class="line"><span class="comment">//work with express</span></div><div class="line"><span class="keyword">const</span> server = https.Server(app)</div><div class="line"><span class="keyword">const</span> io = socketIo(server)</div><div class="line">io.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</div><div class="line">  socket.on(<span class="string">'sendmsg'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> &#123;<span class="keyword">from</span>,to,msg&#125; = data</div><div class="line">    <span class="keyword">let</span> chatid = [<span class="keyword">from</span>,to].sort().join(<span class="string">'_'</span>)</div><div class="line">    Chat.create(&#123;chatid,<span class="keyword">from</span>,to,<span class="attr">content</span>:msg&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e,d</span>)</span>&#123;</div><div class="line">      io.emit(<span class="string">'recvmsg'</span>,<span class="built_in">Object</span>.assign(&#123;&#125;,d._doc))</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// console.log(data)</span></div><div class="line">    <span class="comment">// //广播给全局</span></div><div class="line">    <span class="comment">// io.emit('recvmsg',data)</span></div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">app.use(cookieParser())</div><div class="line">app.use(bodyParser.json())</div><div class="line">app.use(<span class="string">'/user'</span>,userRouter)</div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(req.url.startsWith(<span class="string">'/user/'</span>) || req.url.startsWith(<span class="string">'/static/'</span>))&#123;</div><div class="line">    <span class="keyword">return</span> next()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> store = createStore(reducers,compose(</div><div class="line">    applyMiddleware(thunk)</div><div class="line">  ))</div><div class="line">  <span class="comment">//这个 context 对象包含了渲染的结果</span></div><div class="line">  <span class="keyword">let</span> context = &#123;&#125;</div><div class="line">  <span class="keyword">const</span> root = (&lt;Provider store=&#123;store&#125;&gt;</div><div class="line">                    &lt;StaticRouter</div><div class="line">                      location=&#123;req.url&#125;</div><div class="line">                      context=&#123;context&#125;</div><div class="line">                      &gt;</div><div class="line">                        &lt;App&gt;&lt;/App&gt;</div><div class="line">                    &lt;/StaticRouter&gt;</div><div class="line">                &lt;/Provider&gt;)</div><div class="line">  <span class="keyword">const</span> markupStream = renderToNodeStream(root)</div><div class="line">  markupStream.pipe(res,&#123;<span class="attr">end</span>:<span class="literal">false</span>&#125;)</div><div class="line">  markupStream.on(<span class="string">'end'</span>,()=&gt;&#123;</div><div class="line">    res.end()</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//映射build文件路径，项目上要使用</span></div><div class="line">app.use(<span class="string">'/'</span>,express.static(path.resolve(<span class="string">'build'</span>)))</div><div class="line"></div><div class="line"></div><div class="line">server.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'开启成功'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>此时将服务端renderToNodeStream后的代码返回给前端，但是这个时候还是不行，我们执行一下<code>npm run server</code>，可以看到报错了。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/1644f96e7d492e64?w=1138&amp;h=572&amp;f=jpeg&amp;s=170355" alt=""></p>
<h2 id="css-modules-require-hook-asset-require-hook"><a href="#css-modules-require-hook-asset-require-hook" class="headerlink" title="css-modules-require-hook/asset-require-hook"></a>css-modules-require-hook/asset-require-hook</h2><h3 id="css-modules-require-hook"><a href="#css-modules-require-hook" class="headerlink" title="css-modules-require-hook"></a>css-modules-require-hook</h3><ul>
<li>因为服务端此时<code>不认识</code>我们的css文件，我们需要安装一个包，来让服务端处理css文件。</li>
<li><code>npm i css-modules-require-hook -S</code>安装在生产环境下。</li>
<li>在项目根目录创建一个<code>crmh.conf.js</code>钩子文件进行配置,看下图。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/1644f9c1c32b5e66?w=306&amp;h=886&amp;f=jpeg&amp;s=56016" alt=""></p>
<p><strong>写入代码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// css-modules-require-hook </span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">generateScopedName</span>: <span class="string">'[name]__[local]___[hash:base64:5]'</span>,</div><div class="line">  <span class="comment">//下面的代码在本项目中暂时用不到，但是以下配置在我另一个项目中有用到，我来讲一下他的配置</span></div><div class="line">  <span class="comment">//扩展名</span></div><div class="line">  <span class="comment">//extensions: ['.scss','.css'],</span></div><div class="line">  <span class="comment">//钩子，这里主要做一些预处理的scss或者less文件</span></div><div class="line">  <span class="comment">//preprocessCss: (data, filename) =&gt;</span></div><div class="line">  <span class="comment">//    require('node-sass').renderSync(&#123;</span></div><div class="line">  <span class="comment">//        data,</span></div><div class="line">  <span class="comment">//        file: filename</span></div><div class="line">  <span class="comment">//    &#125;).css,</span></div><div class="line">  <span class="comment">//是否导出css类名，主要用于CSSModule</span></div><div class="line">  <span class="comment">//camelCase: true,</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>修改我们的<code>server.js</code>文件,添加<code>import csshook from &#39;css-modules-require-hook/preset&#39;</code>,<strong>注意⚠️</strong>，<code>一定要把这行代码放在导入App模块之前</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> csshook <span class="keyword">from</span> <span class="string">'css-modules-require-hook/preset'</span></div><div class="line"><span class="comment">//我们的首页入口</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/App'</span></div></pre></td></tr></table></figure>
<p><strong>此时在运行<code>server.js</code>，会发现又报了个错。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/1644fb97d437ed71?w=1130&amp;h=260&amp;f=jpeg&amp;s=46396" alt=""></p>
<h3 id="asset-require-hook"><a href="#asset-require-hook" class="headerlink" title="asset-require-hook"></a>asset-require-hook</h3><ul>
<li>这个错误是因为服务端没有处理前端代码需要的图片</li>
<li>需要安装<code>npm i asset-require-hook -S</code>，这个插件用来让服务端处理图片,<strong>注意⚠️</strong>，<code>前提是客户端代码，引用图片都需要require</code></li>
<li>在<code>server.js</code>写入代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//解决图片问题，客户端代码引用图片都需要require</span></div><div class="line"><span class="keyword">import</span> assethook <span class="keyword">from</span> <span class="string">'asset-require-hook'</span></div><div class="line">assethook(&#123;</div><div class="line">  <span class="attr">extensions</span>:[<span class="string">'png'</span>],</div><div class="line">  <span class="comment">//图片大小下于10000的图片会直接base64编码</span></div><div class="line">  limit: <span class="number">10000</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>运行之后发现又报错了，这个很简单，因为我们只有image的引用名字，却<code>没有地址</code></strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/1644fc3965492fef?w=1952&amp;h=996&amp;f=jpeg&amp;s=200831" alt=""></p>
<ul>
<li>所以此时要在外面加个壳，把之前build之后的<code>静态js、css文件</code>引入进去，添加html、head这些标签。来看完整代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></div><div class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123;renderToString,renderToStaticMarkup,renderToNodeStream&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span></div><div class="line"></div><div class="line"><span class="comment">//引入css文件和js文件</span></div><div class="line"><span class="keyword">import</span> staticPath <span class="keyword">from</span> <span class="string">'../build/asset-manifest.json'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> &#123;StaticRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  createStore,</div><div class="line">  applyMiddleware,</div><div class="line">  <span class="comment">//组合函数用的</span></div><div class="line">  compose</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="comment">//解决服务端渲染的图片问题 必须放在App之前</span></div><div class="line"><span class="keyword">import</span> csshook <span class="keyword">from</span> <span class="string">'css-modules-require-hook/preset'</span></div><div class="line"><span class="comment">//解决图片问题，需要require</span></div><div class="line"><span class="keyword">import</span> assethook <span class="keyword">from</span> <span class="string">'asset-require-hook'</span></div><div class="line">assethook(&#123;</div><div class="line">  <span class="attr">extensions</span>:[<span class="string">'png'</span>],</div><div class="line">  <span class="attr">limit</span>: <span class="number">10000</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/App'</span></div><div class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'../src/reducer'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> userRouter <span class="keyword">from</span> <span class="string">'./routes/user'</span></div><div class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'body-parser'</span></div><div class="line"><span class="keyword">import</span> cookieParser <span class="keyword">from</span> <span class="string">'cookie-parser'</span></div><div class="line"><span class="keyword">import</span> model <span class="keyword">from</span> <span class="string">'./model'</span></div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></div><div class="line"><span class="keyword">import</span> https <span class="keyword">from</span> <span class="string">'http'</span></div><div class="line"><span class="keyword">import</span> socketIo <span class="keyword">from</span> <span class="string">'socket.io'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Chat = model.getModel(<span class="string">'chat'</span>)</div><div class="line"><span class="comment">//新建app</span></div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"></div><div class="line"><span class="comment">//work with express</span></div><div class="line"><span class="keyword">const</span> server = https.Server(app)</div><div class="line"><span class="keyword">const</span> io = socketIo(server)</div><div class="line">io.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</div><div class="line">  socket.on(<span class="string">'sendmsg'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> &#123;<span class="keyword">from</span>,to,msg&#125; = data</div><div class="line">    <span class="keyword">let</span> chatid = [<span class="keyword">from</span>,to].sort().join(<span class="string">'_'</span>)</div><div class="line">    Chat.create(&#123;chatid,<span class="keyword">from</span>,to,<span class="attr">content</span>:msg&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e,d</span>)</span>&#123;</div><div class="line">      io.emit(<span class="string">'recvmsg'</span>,<span class="built_in">Object</span>.assign(&#123;&#125;,d._doc))</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// console.log(data)</span></div><div class="line">    <span class="comment">// //广播给全局</span></div><div class="line">    <span class="comment">// io.emit('recvmsg',data)</span></div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">app.use(cookieParser())</div><div class="line">app.use(bodyParser.json())</div><div class="line">app.use(<span class="string">'/user'</span>,userRouter)</div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(req.url.startsWith(<span class="string">'/user/'</span>) || req.url.startsWith(<span class="string">'/static/'</span>))&#123;</div><div class="line">    <span class="keyword">return</span> next()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> store = createStore(reducers,compose(</div><div class="line">    applyMiddleware(thunk)</div><div class="line">  ))</div><div class="line">  <span class="keyword">const</span> obj = &#123;</div><div class="line">    <span class="string">'/msg'</span>:<span class="string">'聊天消息列表'</span>,</div><div class="line">    <span class="string">'/me'</span>:<span class="string">'个人中心列表'</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//这个 context 对象包含了渲染的结果</span></div><div class="line">  <span class="keyword">let</span> context = &#123;&#125;</div><div class="line">  res.write(<span class="string">`&lt;!DOCTYPE html&gt;</span></div><div class="line">  &lt;html lang="en"&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">      &lt;meta charset="utf-8"&gt;</div><div class="line">      &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt;</div><div class="line">      &lt;meta name="theme-color" content="#000000"&gt;</div><div class="line">      &lt;meta name="description" content="<span class="subst">$&#123;obj[req.url]&#125;</span>"/&gt;</div><div class="line">      &lt;meta name="keywords" content="SSR"&gt;</div><div class="line">      &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json"&gt;</div><div class="line">      &lt;link rel="stylesheet" href="/<span class="subst">$&#123;staticPath[<span class="string">'main.css'</span>]&#125;</span>"&gt;</div><div class="line">      &lt;title&gt;React App&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">      &lt;noscript&gt;</div><div class="line">        You need to enable JavaScript to run this app.</div><div class="line">      &lt;/noscript&gt;</div><div class="line">      &lt;div id="root"&gt;`)</div><div class="line">  <span class="keyword">const</span> root = (&lt;Provider store=&#123;store&#125;&gt;</div><div class="line">                    &lt;StaticRouter</div><div class="line">                      location=&#123;req.url&#125;</div><div class="line">                      context=&#123;context&#125;</div><div class="line">                      &gt;</div><div class="line">                        &lt;App&gt;&lt;/App&gt;</div><div class="line">                    &lt;/StaticRouter&gt;</div><div class="line">                &lt;/Provider&gt;)</div><div class="line">  <span class="keyword">const</span> markupStream = renderToNodeStream(root)</div><div class="line">  markupStream.pipe(res,&#123;<span class="attr">end</span>:<span class="literal">false</span>&#125;)</div><div class="line">  markupStream.on(<span class="string">'end'</span>,()=&gt;&#123;</div><div class="line">    res.write(<span class="string">`&lt;/div&gt;</span></div><div class="line">          &lt;script src="/<span class="subst">$&#123;staticPath[<span class="string">'main.js'</span>]&#125;</span>"&gt;&lt;/script&gt;</div><div class="line">        &lt;/body&gt;</div><div class="line">      &lt;/html&gt;`)</div><div class="line">    res.end()</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//映射build文件路径，项目上要使用</span></div><div class="line">app.use(<span class="string">'/'</span>,express.static(path.resolve(<span class="string">'build'</span>)))</div><div class="line"></div><div class="line"></div><div class="line">server.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'开启成功'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>这个时候我们可以在html标签里加上SEO的meta<code>&lt;meta name=&quot;keywords&quot; content=&quot;SSR&quot;&gt;</code></li>
<li>最后还要把客户端的<code>index.js</code>文件中的渲染机制改成<code>hydrate</code>，不用<code>render</code>，他们之间的区别可以看这个（传送门☞<a href="https://www.colabug.com/2385573.html" target="_blank" rel="external">render !== hydrate</a>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ReactDOM.hydrate(</div><div class="line">    (&lt;Provider store=&#123;store&#125;&gt;</div><div class="line">        &lt;BrowserRouter&gt;</div><div class="line">            &lt;App&gt;&lt;/App&gt;</div><div class="line">        &lt;/BrowserRouter&gt;</div><div class="line">    &lt;/Provider&gt;),</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<p><strong>到此为止我们开发模式下的SSR搭建完毕，接下来生产模式的坑我来讲一下。</strong></p>
<h1 id="生产环境SSR准备"><a href="#生产环境SSR准备" class="headerlink" title="生产环境SSR准备"></a>生产环境SSR准备</h1><blockquote>
<p>我们上面所讲的只是<strong>开发模式下的SSR</strong>，因为我们是通过<code>babel-node</code>编译<code>jsx和es6代码</code>的，只要一脱离<code>babel-node</code>就会全错,所以我们需要webpack打包服务端代码</p>
</blockquote>
<p><strong>我们需要创建一个<code>webserver.config.js</code>，用来打包server的代码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>),</div><div class="line">    fs = <span class="built_in">require</span>(<span class="string">'fs'</span>),</div><div class="line">    webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>),</div><div class="line">    autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>),</div><div class="line">    HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>),</div><div class="line">    ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</div><div class="line">    cssFilename = <span class="string">'static/css/[name].[contenthash:8].css'</span>;</div><div class="line">    CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</div><div class="line">    nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>);</div><div class="line"></div><div class="line">serverConfig = &#123;</div><div class="line">  <span class="attr">context</span>: path.resolve(__dirname, <span class="string">'..'</span>),</div><div class="line">  <span class="attr">entry</span>: &#123;<span class="attr">server</span>: <span class="string">'./server/server'</span>&#125;,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">      <span class="attr">libraryTarget</span>: <span class="string">'commonjs2'</span>,</div><div class="line">      <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'../build/server'</span>),</div><div class="line">      <span class="attr">filename</span>: <span class="string">'static/js/[name].js'</span>,</div><div class="line">      <span class="attr">chunkFilename</span>: <span class="string">'static/js/chunk.[name].js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// target: 'node' 指明构建出的代码是要运行在node环境里.</span></div><div class="line">  <span class="comment">// 不把 Node.js 内置的模块打包进输出文件中，例如 fs net 模块等</span></div><div class="line">  target: <span class="string">'node'</span>,</div><div class="line">  <span class="comment">//指定在node环境中是否要这些模块 </span></div><div class="line">  node: &#123;</div><div class="line">      <span class="attr">__filename</span>: <span class="literal">true</span>,</div><div class="line">      <span class="attr">__dirname</span>: <span class="literal">true</span>,</div><div class="line">      <span class="comment">// module:true</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">      <span class="attr">loaders</span>: [&#123;</div><div class="line">          <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">          <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</div><div class="line">          <span class="attr">loader</span>: <span class="string">'babel-loader?cacheDirectory=true'</span>,</div><div class="line">          <span class="attr">options</span>: &#123;</div><div class="line">              <span class="attr">presets</span>: [<span class="string">'es2015'</span>, <span class="string">'react-app'</span>, <span class="string">'stage-0'</span>],</div><div class="line">              <span class="attr">plugins</span>: [<span class="string">'add-module-exports'</span>,</div><div class="line">              [</div><div class="line">                <span class="string">"import"</span>,</div><div class="line">                &#123;</div><div class="line">                  <span class="string">"libraryName"</span>: <span class="string">"antd-mobile"</span>,</div><div class="line">                  <span class="string">"style"</span>: <span class="string">"css"</span></div><div class="line">                &#125;</div><div class="line">              ],<span class="string">"transform-decorators-legacy"</span>]</div><div class="line">          &#125;,</div><div class="line">      &#125;,&#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</div><div class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules|antd-mobile\.css/</span>,            </div><div class="line">        <span class="attr">loader</span>: ExtractTextPlugin.extract(</div><div class="line">          <span class="built_in">Object</span>.assign(</div><div class="line">            &#123;</div><div class="line">              <span class="attr">fallback</span>: &#123;</div><div class="line">                <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'style-loader'</span>),</div><div class="line">                <span class="attr">options</span>: &#123;</div><div class="line">                  <span class="attr">hmr</span>: <span class="literal">false</span>,</div><div class="line">                &#125;,</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">use</span>: [</div><div class="line">                &#123;</div><div class="line">                  <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'css-loader'</span>),</div><div class="line">                  <span class="attr">options</span>: &#123;</div><div class="line">                    <span class="attr">importLoaders</span>: <span class="number">1</span>,</div><div class="line">                    <span class="attr">minimize</span>: <span class="literal">true</span>,</div><div class="line">                    <span class="attr">modules</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">localIdentName</span>:<span class="string">"[name]-[local]-[hash:base64:8]"</span>,</div><div class="line">                    <span class="comment">// sourceMap: shouldUseSourceMap,</span></div><div class="line">                  &#125;,</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                  <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'postcss-loader'</span>),</div><div class="line">                  <span class="attr">options</span>: &#123;</div><div class="line">                    <span class="attr">ident</span>: <span class="string">'postcss'</span>,</div><div class="line">                    <span class="attr">plugins</span>: <span class="function"><span class="params">()</span> =&gt;</span> [</div><div class="line">                      <span class="built_in">require</span>(<span class="string">'postcss-flexbugs-fixes'</span>),</div><div class="line">                      autoprefixer(&#123;</div><div class="line">                        <span class="attr">browsers</span>: [</div><div class="line">                          <span class="string">'&gt;1%'</span>,</div><div class="line">                          <span class="string">'last 4 versions'</span>,</div><div class="line">                          <span class="string">'Firefox ESR'</span>,</div><div class="line">                          <span class="string">'not ie &lt; 9'</span>, <span class="comment">// React doesn't support IE8 anyway</span></div><div class="line">                        ],</div><div class="line">                        <span class="attr">flexbox</span>: <span class="string">'no-2009'</span>,</div><div class="line">                      &#125;),</div><div class="line">                    ],</div><div class="line">                  &#125;,</div><div class="line">                &#125;,</div><div class="line">              ],</div><div class="line">            &#125;,</div><div class="line">          )</div><div class="line">        ),</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</div><div class="line">        <span class="attr">include</span>: <span class="regexp">/node_modules|antd-mobile\.css/</span>,</div><div class="line">        <span class="attr">use</span>: ExtractTextPlugin.extract(&#123;</div><div class="line">          <span class="attr">fallback</span>: <span class="built_in">require</span>.resolve(<span class="string">'style-loader'</span>),</div><div class="line">          <span class="attr">use</span>: [&#123;</div><div class="line">            <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'css-loader'</span>),</div><div class="line">            <span class="attr">options</span>: &#123;</div><div class="line">              <span class="attr">modules</span>:<span class="literal">false</span></div><div class="line">            &#125;,</div><div class="line">          &#125;]</div><div class="line">        &#125;)</div><div class="line">      &#125;, &#123;</div><div class="line">          <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif|webp)$/</span>,</div><div class="line">          <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'url-loader'</span>),</div><div class="line">            <span class="attr">options</span>: &#123;</div><div class="line">              <span class="attr">limit</span>: <span class="number">10000</span>,</div><div class="line">              <span class="attr">name</span>: <span class="string">'static/media/[name].[hash:8].[ext]'</span>,</div><div class="line">            &#125;,</div><div class="line">      &#125;, &#123;</div><div class="line">          <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,</div><div class="line">          <span class="attr">loader</span>: <span class="string">'json-loader'</span>,</div><div class="line">      &#125;]</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 不把 node_modules 目录下的第三方模块打包进输出文件中,</span></div><div class="line">  externals: [nodeExternals()],</div><div class="line">  <span class="attr">resolve</span>: &#123;<span class="attr">extensions</span>: [<span class="string">'*'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.scss'</span>]&#125;,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">      <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'../build/server'</span>]),</div><div class="line">      <span class="keyword">new</span> webpack.optimize.OccurrenceOrderPlugin(),</div><div class="line">      <span class="comment">//把第三方库从js文件中分离出来</span></div><div class="line">      <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">        <span class="comment">//抽离相应chunk的共同node_module</span></div><div class="line">        minChunks(<span class="built_in">module</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="regexp">/node_modules/</span>.test(<span class="built_in">module</span>.context);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//从要抽离的chunk中的子chunk抽离相同的模块</span></div><div class="line">        children: <span class="literal">true</span>,</div><div class="line">        <span class="comment">//是否异步抽离公共模块，参数boolean||string</span></div><div class="line">        <span class="keyword">async</span>: <span class="literal">false</span>,</div><div class="line">      &#125;),</div><div class="line">      <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">        <span class="attr">children</span>:<span class="literal">true</span>,</div><div class="line">        <span class="comment">//若参数是string即为抽离出来后的文件名</span></div><div class="line">        <span class="keyword">async</span>: <span class="string">'shine'</span>,</div><div class="line">        <span class="comment">//最小打包的文件模块数，即要抽离的公共模块中的公共数，比如三个chunk只有1个用到就不算公共的            </span></div><div class="line">        <span class="comment">//若为Infinity，则会把webpack runtime的代码放入其中（webpack 不再自动抽离公共模块）</span></div><div class="line">        minChunks:<span class="number">2</span></div><div class="line">      &#125;),</div><div class="line">      <span class="comment">//压缩</span></div><div class="line">      <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</div><div class="line">      <span class="comment">//分离css文件</span></div><div class="line">      <span class="keyword">new</span> ExtractTextPlugin(&#123;</div><div class="line">        <span class="attr">filename</span>: cssFilename,</div><div class="line">      &#125;),</div><div class="line">      <span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/^\.\/locale$/</span>, /moment$/),</div><div class="line">  ],</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports =  serverConfig</div></pre></td></tr></table></figure>
<p><strong>重点⚠️</strong></p>
<ul>
<li>指定target，打包出来的代码运行在哪里</li>
<li>指定externals不要把<code>node_modules</code>包打包，因为此项目运行在服务端，直接用外面的<code>node_modules</code>就行。不然打包后会很大。</li>
<li>loader中用babel对js的处理</li>
</ul>
<blockquote>
<p>ok，现在来我们改一下package.json的<code>npm scripts</code>，添加一个<code>packServer</code>,顺便改一下<code>build</code>的scripts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"clean"</span>: <span class="string">"rm -rf build/"</span>,</div><div class="line">  <span class="string">"dev"</span>: <span class="string">"node scripts/start.js"</span>,</div><div class="line">  <span class="string">"start"</span>: <span class="string">"cross-env NODE_ENV=development npm run server &amp; npm run dev"</span>,</div><div class="line">  <span class="string">"build"</span>: <span class="string">"npm run clean &amp;&amp; node scripts/build.js &amp;&amp; npm run packServer"</span>,</div><div class="line">  <span class="string">"test"</span>: <span class="string">"nodemon scripts/test.js --env=jsdom"</span>,</div><div class="line">  <span class="string">"server"</span>: <span class="string">"cross-env NODE_ENV=test nodemon --exec babel-node server/server.js"</span>,</div><div class="line">  <span class="string">"gulp"</span>: <span class="string">"cross-env NODE_ENV=production gulp"</span>,</div><div class="line">  <span class="string">"packServer"</span>: <span class="string">"cross-env NODE_ENV=production webpack --config ./config/webserver.config.js"</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<ul>
<li><code>packServer</code>指定了生产环境，这在之后会用到。</li>
<li><code>build</code>是先clean掉build文件夹，在去打包<code>客户端的代码</code>，打包完之后再去打包<code>服务端的代码</code></li>
</ul>
<p><strong>那么到这里为止我们差不多可以自己试试了</strong></p>
<ul>
<li>先<code>npm run build</code>,会生成打包后的build文件夹，里面包含了我们的<code>服务端和客户端代码</code></li>
<li>找到打包后的node文件运行它，在<code>build/server/static/js</code>目录下，可直接node文件启动。这就解决了我们生产环境下的问题。</li>
</ul>
<h1 id="pm2，服务器自动部署"><a href="#pm2，服务器自动部署" class="headerlink" title="pm2，服务器自动部署"></a>pm2，服务器自动部署</h1><p><strong>现在我们要把我们的项目部署到服务器上，并用pm2守护进程。</strong></p>
<ul>
<li>我们得有一台云服务器，这里我是在<a href="https://www.aliyun.com/?spm=5176.11034346.765261.1.smqqWK" target="_blank" rel="external">阿里云</a>买的一台<code>ubuntu 14.04</code></li>
<li>需要一个已经备案后的域名，域名也可以在<a href="https://www.aliyun.com/?spm=5176.11034346.765261.1.smqqWK" target="_blank" rel="external">阿里云</a>买。当然也可以不用，可以直接服务器地址访问。</li>
<li>ok让我们开始吧。</li>
</ul>
<h2 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h2><ul>
<li>在部署到服务器之前我们代码中还有些东西需要修改,修改mongod的连接地址.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> env = process.env.NODE_ENV || <span class="string">'development'</span></div><div class="line"><span class="comment">//当生产环境时，需要改变mongodb的连接端口，根据你服务器的mongodb端口来，我这里是19999</span></div><div class="line"><span class="keyword">const</span> BASE_URL = env == <span class="string">'development'</span>?<span class="string">"mongodb://localhost:27017/chat"</span>:<span class="string">"mongodb://127.0.0.1:19999/chat"</span>;</div></pre></td></tr></table></figure>
<ul>
<li>修改客户端<code>scoket.io</code>的链接地址<code>const socket = io(&#39;ws://host:port&#39;)</code>，改成你自己的服务器地址和端口号</li>
<li>我们需要将自己的项目上传至<a href="https://gitee.com/" target="_blank" rel="external">码云</a>。这里我使用<a href="https://gitee.com/" target="_blank" rel="external">码云</a>，主要是因为<a href="https://gitee.com/" target="_blank" rel="external">码云</a>的私仓是免费的。</li>
<li>我们需要进入服务器的<code>ssh目录</code>下复制<code>id_rsa.pub</code>里的公钥放在码云的<code>ssh公钥</code>中,可进入<code>设置</code>,具体看图</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/164500836f1ab210?w=904&amp;h=1232&amp;f=jpeg&amp;s=85014" alt=""></p>
<ul>
<li>我们也要把自己电脑上的<code>ssh公钥</code>在码云中设置，我这里是mac，在自己的用户目录下，可以按<code>cmd+shift+.</code>看隐藏文件（如果你设置过了，这一步就不要了）。</li>
<li>服务器安装git,mongodb,pm2<code>（如果服务器已经安装过了，就不需要了）</code></li>
<li>需要开启mongodb</li>
<li>我们在项目根目录新建一个<code>ecosystem.json</code>文件，这个文件是pm2的配置文件，具体的我就不说了，大家如果感兴趣可以去官网看看，（传送门☞<a href="http://pm2.keymetrics.io/" target="_blank" rel="external">pm2官网</a>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"apps"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="comment">//应用名称</span></div><div class="line">      <span class="string">"name"</span>: <span class="string">"chat"</span>,</div><div class="line">      <span class="comment">//执行文件的路径</span></div><div class="line">      <span class="string">"script"</span>: <span class="string">"./build/server/static/js/server.js"</span>,</div><div class="line">      <span class="string">"env"</span>: &#123;</div><div class="line">        <span class="string">"COMMON_VARIABLE"</span>: <span class="string">"true"</span></div><div class="line">      &#125;,</div><div class="line">      <span class="string">"env_production"</span>: &#123;</div><div class="line">        <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  <span class="string">"deploy"</span>: &#123;</div><div class="line">    <span class="string">"production"</span>: &#123;</div><div class="line">      <span class="comment">//服务器用户</span></div><div class="line">      <span class="string">"user"</span>: <span class="string">"xxx"</span>,</div><div class="line">      <span class="comment">//服务器地址</span></div><div class="line">      <span class="string">"host"</span>: [<span class="string">"xxx"</span>],</div><div class="line">      <span class="comment">//服务器端口</span></div><div class="line">      <span class="string">"port"</span>: <span class="string">"xxx"</span>,</div><div class="line">      <span class="string">"ref"</span>: <span class="string">"origin/master"</span>,</div><div class="line">      <span class="comment">//这里填你的项目git ssh</span></div><div class="line">      <span class="string">"repo"</span>: <span class="string">"xxx"</span>,</div><div class="line">      <span class="comment">//服务器的存放项目路径</span></div><div class="line">      <span class="string">"path"</span>: <span class="string">"/www/chat/production"</span>,</div><div class="line">      <span class="string">"ssh_options"</span>: <span class="string">"StrictHostKeyChecking=no"</span>,</div><div class="line">      <span class="comment">//钩子</span></div><div class="line">      <span class="string">"post-deploy"</span>: <span class="string">"npm --registry https://registry.npm.taobao.org install &amp;&amp; npm run build &amp;&amp; pm2 startOrRestart ecosystem.json --env production"</span>,</div><div class="line">      <span class="string">"env"</span>: &#123;</div><div class="line">        <span class="comment">//环境</span></div><div class="line">        <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在服务器新建项目目录新建<code>/www/chat/</code>文件夹。</li>
<li>在本地电脑执行 <code>pm2 deploy ecosystem.json production setup</code></li>
<li>这里大家肯定会报错，这是我故意埋的坑，因为<code>chat</code>文件夹的权限不够，需要进入服务器的<code>www</code>文件夹，执行<code>sudo chmod 777 chat</code>。</li>
<li>进入服务器的.bashrc文件，注视掉上面的几行代码</li>
<li><code>source .bashrc</code>重新载入一下<code>.bashrc</code>文件</li>
<li>开启pm2服务 pm2 deploy ecosystem.json production</li>
<li>这里可能有的人会报错，主要原因是本地电脑的pm2的权限问题，需要找到pm2文件夹，<code>chmod 666 pm2</code></li>
<li>如果上述问题都解决了最后会如图所示</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/164504fa410ade72?w=1124&amp;h=824&amp;f=jpeg&amp;s=203875" alt=""></p>
<ul>
<li>最后我们可以进入服务器，<code>pm2 list</code>,看到成功跑起来了</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/164505303ec8211b?w=848&amp;h=210&amp;f=jpeg&amp;s=42625" alt=""></p>
<ul>
<li>如果应用在不断的<code>重启</code>，说明开启<code>失败</code>了，需要<code>pm2 logs</code>看看日志</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/16450529b006f32f?w=798&amp;h=544&amp;f=jpeg&amp;s=51991" alt=""></p>
<ul>
<li>我们可以访问<code>服务器地址:8088</code>,并看到应用跑起来了</li>
<li></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SSR/">SSR</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-promise" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/14/promise/" class="article-date">
  	<time datetime="2018-07-14T04:00:40.000Z" itemprop="datePublished">2018-07-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/14/promise/">Promise之你看得懂的Promise</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Promise源码详解"><a href="#Promise源码详解" class="headerlink" title="Promise源码详解"></a>Promise源码详解</h1><blockquote>
<p>学习知识要善于思考，思考，再思考。 —— 爱因斯坦</p>
</blockquote>
<h2 id="1-回调地狱"><a href="#1-回调地狱" class="headerlink" title="1.回调地狱"></a>1.回调地狱</h2><p>曾几何时，我们的代码是这样的，为了拿到回调的结果，不得不<code>callback hell</code>，这种环环相扣的代码可以说是相当恶心了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line">fs.readFile(<span class="string">'./a.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</div><div class="line">  fs.readFile(data,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</div><div class="line">    fs.readFile(data,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(data)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>终于，我们的<code>盖世英雄</code>出现了，他身披金甲圣衣、驾着七彩祥云。好吧打岔儿了，没错他就是我们的<code>Promise</code>，那让我们来看看用了<code>Promise</code>之后，上面的代码会变成什么样吧</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">    fs.readFile(url,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,data</span>)</span>&#123;</div><div class="line">      error &amp;&amp; reject(error)</div><div class="line">      resolve(data)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">read(<span class="string">'./a.txt'</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</div><div class="line">  <span class="keyword">return</span> read(data) </div><div class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</div><div class="line">  <span class="keyword">return</span> read(data)  </div><div class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如上所示</p>
<p>真的是很方便，有木有？意中人可以说是<code>Swag</code>到变形了。那么言归正传，我们怎么才能自己写一个这么<code>Swag</code>的解决异步神器呢？</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f594d31f1a03?w=600&amp;h=456&amp;f=jpeg&amp;s=21554" alt=""></p>
<h2 id="2-重点开始，小眼睛都看过来"><a href="#2-重点开始，小眼睛都看过来" class="headerlink" title="2.重点开始，小眼睛都看过来"></a>2.重点开始，小眼睛都看过来</h2><h3 id="2-1-Promise-A"><a href="#2-1-Promise-A" class="headerlink" title="2.1 Promise/A+"></a>2.1 Promise/A+</h3><p>首先我们要知道自己手写一个<code>Promise</code>，应该怎么去写，谁来告诉我们怎么写，需要遵循什么样的规则。当然这些你都不用担心，其实业界都是通过一个规则指标来生产<code>Promise</code>的。让我们来看看是什么东西。传送门☞<a href="https://promisesaplus.com/" target="_blank" rel="external">Promise/A+</a></p>
<h3 id="2-2-constructor"><a href="#2-2-constructor" class="headerlink" title="2.2 constructor"></a>2.2 constructor</h3><p>我们先声明一个类，叫做<code>Promise</code>，里面是构造函数。如果es6还有问题的可以去阮大大的博客上学习一下（传送门☞<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">es6</a>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(executor)&#123;</div><div class="line">    <span class="comment">//控制状态，使用了一次之后，接下来的都不被使用</span></div><div class="line">    <span class="keyword">this</span>.status = <span class="string">'pendding'</span></div><div class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span></div><div class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span></div><div class="line">    </div><div class="line">    <span class="comment">//定义resolve函数</span></div><div class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</div><div class="line">      <span class="comment">//这里pendding，主要是为了防止executor中调用了两次resovle或reject方法，而我们只调用一次</span></div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'pendding'</span>)&#123;</div><div class="line">        <span class="keyword">this</span>.status = <span class="string">'resolve'</span></div><div class="line">        <span class="keyword">this</span>.value = data</div><div class="line">      &#125; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//定义reject函数</span></div><div class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'pendding'</span>)&#123;</div><div class="line">        <span class="keyword">this</span>.status = <span class="string">'reject'</span>        </div><div class="line">        <span class="keyword">this</span>.reason = data</div><div class="line">      &#125; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//executor方法可能会抛出异常，需要捕获</span></div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">      <span class="comment">//将resolve和reject函数给使用者      </span></div><div class="line">      executor(resolve,reject)      </div><div class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">      <span class="comment">//如果在函数中抛出异常则将它注入reject中</span></div><div class="line">      reject(e)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么接下来我会分析上面代码的作用，原理</p>
<ul>
<li><code>executor：</code>这是实例<code>Promise</code>对象时在构造器中传入的参数，一般是一个<code>function(resolve,reject){}</code></li>
<li><code>status：``Promise</code>的状态，一开始是默认的pendding状态，每当调用道resolve和reject方法时，就会改变其值，在后面的then方法中会用到</li>
<li><code>value：</code>resolve回调成功后，调用resolve方法里面的参数值</li>
<li><code>reason：</code>reject回调成功后，调用reject方法里面的参数值</li>
<li><code>resolve：</code>声明resolve方法在构造器内，通过传入的executor方法传入其中，用以给使用者回调</li>
<li><code>reject：</code>声明reject方法在构造器内，通过传入的executor方法传入其中，用以给使用者回调</li>
</ul>
<h3 id="2-3-then"><a href="#2-3-then" class="headerlink" title="2.3 then"></a>2.3 then</h3><p>then方法是<code>Promise</code>中最为重要的方法，他的用法大家都应该已经知道，就是将<code>Promise</code>中的resolve或者reject的结果拿到，那么我们就能知道这里的then方法需要两个参数，成功回调和失败回调，上代码！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">then(onFufilled,onRejected)&#123;  </div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'resolve'</span>)&#123;</div><div class="line">    onFufilled(<span class="keyword">this</span>.value)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'reject'</span>)&#123;</div><div class="line">    onRejected(<span class="keyword">this</span>.reason)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要做了将构造器中resolve和reject的结果传入<code>onFufilled</code>和<code>onRejected</code>中，注意这两个是使用者传入的参数，是个方法。所以你以为这么简单就完了？要想更<code>Swag</code>的应对各种场景，我们必须得再完善。继续往下走！</p>
<h2 id="3-异步的Promise"><a href="#3-异步的Promise" class="headerlink" title="3.异步的Promise"></a>3.异步的Promise</h2><p>之前我们只是处理了同步情况下的Promise，简而言之所有操作都没有异步的成分在内。那么如果是异步该怎么办？</p>
<h3 id="3-1-callback！！！！"><a href="#3-1-callback！！！！" class="headerlink" title="3.1 callback！！！！"></a>3.1 callback！！！！</h3><blockquote>
<p>最早处理异步的方法就是callback，就相当于我让你帮我扫地，我会在给你发起任务时给你一个手机，之后我做自己的事情去，不用等你，等你扫完地就会打手机给我，诶，我就知道了地扫完了。这个手机就是callback，回调函数。</p>
</blockquote>
<p>首先我们需要改一下构造器里的代码，分别添加两个回调函数的数组，分别对应成功回调和失败回调。他们的作用是当成功执行resolve或reject时，执行callback。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//存放成功回调的函数</span></div><div class="line"><span class="keyword">this</span>.onResolvedCallbacks = []</div><div class="line"><span class="comment">//存放失败回调的函数</span></div><div class="line"><span class="keyword">this</span>.onRejectedCallbacks = []</div><div class="line"></div><div class="line"><span class="keyword">let</span> resolve = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'pendding'</span>)&#123;</div><div class="line">    <span class="keyword">this</span>.status = <span class="string">'resolve'</span></div><div class="line">    <span class="keyword">this</span>.value = data</div><div class="line">    <span class="comment">//监听回调函数</span></div><div class="line">    <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn())</div><div class="line">  &#125; </div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> reject = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'pendding'</span>)&#123;</div><div class="line">    <span class="keyword">this</span>.status = <span class="string">'reject'</span>        </div><div class="line">    <span class="keyword">this</span>.reason = data</div><div class="line">    <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn())</div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是then需要多加一个状态判断，当Promise中是异步操作时，需要在我们之前定义的回调函数数组中添加一个回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pendding'</span>)&#123;</div><div class="line">  <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="comment">// to do....</span></div><div class="line">    <span class="keyword">let</span> x = onFufilled(<span class="keyword">this</span>.value)</div><div class="line">    resolvePromise(promise2,x,resolve,reject)</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</div><div class="line">    resolvePromise(promise2,x,resolve,reject)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ok！大功告成，异步已经解决了</p>
<h3 id="3-2-resolvePromise"><a href="#3-2-resolvePromise" class="headerlink" title="3.2 resolvePromise"></a>3.2 resolvePromise</h3><blockquote>
<p>这也是<code>Promise</code>中的重头戏，我来介绍一下，我们在用Promise的时候可能会发现，当then函数中return了一个值，我们可以继续then下去，不过是什么值，都能在下一个then中获取，还有，当我们不在then中放入参数，例：<code>promise.then().then()</code>，那么其后面的then依旧可以得到之前then返回的值，可能你现在想很迷惑。让我来解开你心中的忧愁，<strong>follow me</strong>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">then(onFufilled,onRejected)&#123; </div><div class="line">    <span class="comment">//解决onFufilled,onRejected没有传值的问题</span></div><div class="line">    onFufilled = <span class="keyword">typeof</span> onFufilled === <span class="string">'function'</span>?onFufilled:<span class="function"><span class="params">y</span>=&gt;</span>y</div><div class="line">    <span class="comment">//因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后then的resolve中捕获</span></div><div class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span>?onRejected:<span class="function"><span class="params">err</span>=&gt;</span>&#123; <span class="keyword">throw</span> err ;&#125;</div><div class="line">    <span class="comment">//声明一个promise对象</span></div><div class="line">    <span class="keyword">let</span> promise2</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'resolve'</span>)&#123;</div><div class="line">      <span class="comment">//因为在.then之后又是一个promise对象，所以这里肯定要返回一个promise对象</span></div><div class="line">      promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">          <span class="comment">//因为穿透值的缘故，在默认的跑出一个error后，不能再用下一个的reject来接受，只能通过try，catch        </span></div><div class="line">          <span class="keyword">try</span>&#123;</div><div class="line">            <span class="comment">//因为有的时候需要判断then中的方法是否返回一个promise对象，所以需要判断</span></div><div class="line">            <span class="comment">//如果返回值为promise对象，则需要取出结果当作promise2的resolve结果</span></div><div class="line">            <span class="comment">//如果不是，直接作为promise2的resolve结果</span></div><div class="line">            <span class="keyword">let</span> x = onFufilled(<span class="keyword">this</span>.value)</div><div class="line">            <span class="comment">//抽离出一个公共方法来判断他们是否为promise对象</span></div><div class="line">            resolvePromise(promise2,x,resolve,reject)</div><div class="line">          &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">            reject(e)</div><div class="line">          &#125;</div><div class="line">        &#125;,<span class="number">0</span>)</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'reject'</span>)&#123;</div><div class="line">      promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">          <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</div><div class="line">            resolvePromise(promise2,x,resolve,reject)</div><div class="line">          &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">            reject(e)</div><div class="line">          &#125;</div><div class="line">        &#125;,<span class="number">0</span>)</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pendding'</span>)&#123;</div><div class="line">      promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">        <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">          <span class="comment">// to do....</span></div><div class="line">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">              <span class="keyword">let</span> x = onFufilled(<span class="keyword">this</span>.value)</div><div class="line">              resolvePromise(promise2,x,resolve,reject)</div><div class="line">            &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">              reject(e)</div><div class="line">            &#125;</div><div class="line">          &#125;,<span class="number">0</span>)</div><div class="line">        &#125;)</div><div class="line">        <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">              <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</div><div class="line">              resolvePromise(promise2,x,resolve,reject)</div><div class="line">            &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">              reject(e)</div><div class="line">            &#125;</div><div class="line">          &#125;)</div><div class="line">        &#125;)</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> promise2</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>一下子多了很多方法，不用怕，我会一一解释</p>
<ol>
<li>返回<code>Promise</code>？：首先我们要注意的一点是，then有返回值，then了之后还能在then，那就说明之前的then返回的必然是个<code>Promise</code>。</li>
<li>为什么外面要包一层<code>setTimeout</code>？：因为Promise本身是一个异步方法，属于微任务一列，必须得在执行栈执行完了在去取他的值，所以所有的返回值都得包一层异步setTimeout。</li>
<li>为什么开头有两个判断？：这就是之前想要解决的如果then函数中的参数不是函数，那么我们需要做处理。如果onFufilled不是函数，就需要自定义个函数用来返回之前resolve的值，如果onRejected不是函数，自定义个函数抛出异常。这里会有个小坑，如果这里不抛出异常，会在下一个then的onFufilled中拿到值。又因为这里抛出了异常所以所有的onFufilled或者onRejected都需要try/catch，这也是<a href="https://promisesaplus.com/" target="_blank" rel="external">Promise/A+</a>的规范。当然本人觉得成功的回调不需要抛出异常也可以，大家可以仔细想想。</li>
<li><code>resolvePromise</code>是什么？：这其实是官方<a href="https://promisesaplus.com/" target="_blank" rel="external">Promise/A+</a>的需求。因为你的then可以返回任何职，当然包括<code>Promise</code>对象，而如果是<code>Promise</code>对象，我们就需要将他拆解，直到它不是一个<code>Promise</code>对象，取其中的值。</li>
</ol>
<blockquote>
<p>那就让我们来看看这个<code>resolvePromise</code>到底长啥样。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2,x,resolve,reject</span>)</span>&#123;</div><div class="line">  <span class="comment">//判断x和promise2之间的关系</span></div><div class="line">  <span class="comment">//因为promise2是上一个promise.then后的返回结果，所以如果相同，会导致下面的.then会是同一个promise2，一直都是，没有尽头</span></div><div class="line">  <span class="keyword">if</span>(x === promise2)&#123;<span class="comment">//相当于promise.then之后return了自己，因为then会等待return后的promise，导致自己等待自己，一直处于等待</span></div><div class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>))</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果x不是null，是对象或者方法</span></div><div class="line">  <span class="keyword">if</span>(x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>))&#123;</div><div class="line">    <span class="comment">//为了判断resolve过的就不用再reject了，（比如有reject和resolve的时候）</span></div><div class="line">    <span class="keyword">let</span> called</div><div class="line">    <span class="keyword">try</span>&#123;<span class="comment">//防止then出现异常，Object.defineProperty</span></div><div class="line">      <span class="keyword">let</span> then = x.then<span class="comment">//取x的then方法可能会取到&#123;then:&#123;&#125;&#125;,并没有执行</span></div><div class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">'function'</span>)&#123;</div><div class="line">        <span class="comment">//我们就认为他是promise,call他,因为then方法中的this来自自己的promise对象</span></div><div class="line">        then.call(x,y=&gt;&#123;<span class="comment">//第一个参数是将x这个promise方法作为this指向，后两个参数分别为成功失败回调</span></div><div class="line">          <span class="keyword">if</span>(called) <span class="keyword">return</span>;</div><div class="line">          called = <span class="literal">true</span></div><div class="line">          <span class="comment">//因为可能promise中还有promise，所以需要递归</span></div><div class="line">          resolvePromise(promise2,y,resolve,reject)</div><div class="line">        &#125;,err=&gt;&#123;</div><div class="line">          <span class="keyword">if</span>(called) <span class="keyword">return</span>;</div><div class="line">          called = <span class="literal">true</span></div><div class="line">          <span class="comment">//一次错误就直接返回</span></div><div class="line">          reject(err)</div><div class="line">        &#125;)</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//如果是个普通对象就直接返回resolve作为结果</span></div><div class="line">        resolve(x)</div><div class="line">      &#125;</div><div class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">      <span class="keyword">if</span>(called) <span class="keyword">return</span>;</div><div class="line">      called = <span class="literal">true</span></div><div class="line">      reject(e)</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//这里返回的是非函数，非对象的值,就直接放在promise2的resolve中作为结果</span></div><div class="line">    resolve(x)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>它的作用是用来将onFufilled的返回值进行判断取值处理，把最后获得的值放入最外面那层的<code>Promise</code>的resolve函数中。</p>
</blockquote>
<ol>
<li>参数<code>promise2</code>（then函数返回的Promise对象），<code>x</code>（onFufilled函数的返回值），<code>resolve、reject</code>（最外层的Promise上的resolve和reject）。</li>
<li>为什么要在一开始判断<code>promise2</code>和<code>x</code>？：首先在<a href="https://promisesaplus.com/" target="_blank" rel="external">Promise/A+</a>中写了需要判断这两者如果相等，需要抛出异常，我就来解释一下为什么，如果这两者相等，我们可以看下下面的例子，第一次p2是p1.then出来的结果是个<code>Promise</code>对象，这个<code>Promise</code>对象在被创建的时候调用了resolvePromise(promise2,x,resolve,reject)函数，又因为x等于其本身，是个<code>Promise</code>，就需要then方法递归它，直到他不是<code>Promise</code>对象，但是x（p2）的结果还在等待，他却想执行自己的then方法，就会导致等待。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">  resolve()</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">d</span>=&gt;</span>&#123;</div><div class="line">    <span class="keyword">return</span> p2</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ol>
<li>called是用来干嘛的？：called变量主要是用来判断如果<code>resolvePromise</code>函数已经resolve或者reject了，那就不需要在执行下面的resolce或者reject。</li>
<li>为什么取then这个属性？：因为我们需要去判断x是否为Promise，then属性如果为普通值，就直接resolve掉，如果是个function，就是Promise对象，之后我们就需要将这个x的then方法进行执行，用call的原因是因为then方法里面this指向的问题。</li>
<li>为什么要递归去调用<code>resolvePromise</code>函数？：相信细心的人已经发现了，我这里使用了递归调用法，首先这是<a href="https://promisesaplus.com/" target="_blank" rel="external">Promise/A+</a>中要求的，其次是业务场景的需求，当我们碰到那种Promise的resolve里的Promise的resolve里又包了一个Promise的话，就需要递归取值，直到x不是Promise对象。</li>
</ol>
<h2 id="4-完善Promise"><a href="#4-完善Promise" class="headerlink" title="4.完善Promise"></a>4.完善Promise</h2><blockquote>
<p>我们现在已经基本完成了Promise的then方法，那么现在我们需要看看他的其他方法。</p>
</blockquote>
<h3 id="4-1-catch"><a href="#4-1-catch" class="headerlink" title="4.1 catch"></a>4.1 catch</h3><p>相信大家都知道catch这个方法是用来捕获Promise中的reject的值，也就是相当于then方法中的onRejected回调函数，那么问题就解决了。我们来看代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//catch方法</span></div><div class="line"><span class="keyword">catch</span>(onRejected)&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>,onRejected)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>该方法是挂在Promise原型上的方法。当我们调用catch传callback的时候，就相当于是调用了then方法。</p>
</blockquote>
<h3 id="4-2-resolve-reject"><a href="#4-2-resolve-reject" class="headerlink" title="4.2 resolve/reject"></a>4.2 resolve/reject</h3><p>大家一定都看到过<code>Promise.resolve()、Promise.reject()</code>这两种用法，它们的作用其实就是返回一个Promise对象，我们来实现一下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//resolve方法</span></div><div class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">    resolve(val)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">//reject方法</span></div><div class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">    reject(val)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这两个方法是直接可以通过class调用的，原理就是返回一个内部是resolve或reject的Promise对象。</p>
</blockquote>
<h3 id="4-3-all"><a href="#4-3-all" class="headerlink" title="4.3 all"></a>4.3 all</h3><p>all方法可以说是Promise中很常用的方法了，它的作用就是将一个数组的Promise对象放在其中，当全部resolve的时候就会执行then方法，当有一个reject的时候就会执行catch，并且他们的结果也是按着数组中的顺序来排放的，那么我们来实现一下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)</span></div><div class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> arr = []</div><div class="line">  <span class="keyword">let</span> i = <span class="number">0</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params">index,data</span>)</span>&#123;</div><div class="line">    arr[index] = data</div><div class="line">    i++</div><div class="line">    <span class="keyword">if</span>(i == promises.length)&#123;</div><div class="line">      resolve(arr)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;promises.length;i++)&#123;</div><div class="line">      promises[i].then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</div><div class="line">        processData(i,data)</div><div class="line">      &#125;,reject)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>其原理就是将参数中的数组取出遍历，每当执行成功都会执行<code>processData</code>方法，<code>processData</code>方法就是用来记录每个Promise的值和它对应的下标，当执行的次数等于数组长度时就会执行resolve，把arr的值给then。这里会有一个坑，如果你是通过arr数组的长度来判断他是否应该resolve的话就会出错，为什么呢？因为js数组的特性，导致如果先出来的是1位置上的值进arr，那么0位置上也会多一个空的值，所以不合理。</p>
</blockquote>
<h3 id="4-4-race"><a href="#4-4-race" class="headerlink" title="4.4 race"></a>4.4 race</h3><p>race方法虽然不常用，但是在Promise方法中也是一个能用得上的方法，它的作用是将一个<code>Promise</code>数组放入race中，哪个先执行完，race就直接执行完，并从then中取值。我们来实现一下吧。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//race方法</span></div><div class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;promises.length;i++)&#123;</div><div class="line">      promises[i].then(resolve,reject)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>原理大家应该看懂了，很简单，就是遍历数组执行Promise，如果有一个<code>Promise</code>执行成功就resolve。</p>
</blockquote>
<h3 id="Promise语法糖-deferred"><a href="#Promise语法糖-deferred" class="headerlink" title="Promise语法糖 deferred"></a>Promise语法糖 deferred</h3><p>语法糖这三个字大家一定很熟悉，作为一个很Swag的前端工程师，对async/await这对兄弟肯定很熟悉，没错他们就是generator的语法糖。而我们这里要讲的语法糖是Promise的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//promise语法糖 也用来测试</span></div><div class="line"><span class="built_in">Promise</span>.deferred = <span class="built_in">Promise</span>.defer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> dfd = &#123;&#125;</div><div class="line">  dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">    dfd.resolve = resolve</div><div class="line">    dfd.reject = reject</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">return</span> dfd</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>什么作用呢？看下面代码你就知道了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'./promises'</span>)</div><div class="line"><span class="comment">//Promise上的语法糖，为了防止嵌套，方便调用</span></div><div class="line"><span class="comment">//坏处 错误处理不方便</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> defer = <span class="built_in">Promise</span>.defer()</div><div class="line">  fs.readFile(<span class="string">'./1.txt'</span>,<span class="string">'utf8'</span>,(err,data)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)defer.reject(err)</div><div class="line">    defer.resolve(data)</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">return</span> defer.Promise</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>没错，我们可以方便的去调用他语法糖defer中的<code>Promise</code>对象。那么它还有没有另外的方法呢？答案是有的。我们需要在全局上安装promises-aplus-tests插件<code>npm i promises-aplus-tests -g</code>，再输入promises-aplus-tests [js文件名] 即可验证你的Promise的规范。</p>
</blockquote>
<h2 id="5-结尾"><a href="#5-结尾" class="headerlink" title="5.结尾"></a>5.结尾</h2><p>今天我们就做了一个属于自己的<code>Promise</code>项目，理解里面的源码，方法原理，希望大家都有收获。当然有什么意见大家都可以在评论区评论，peace and love。</p>
<ul>
<li>git地址：<a href="https://github.com/Shinemax1/Promise" target="_blank" rel="external">https://github.com/Shinemax1/Promise</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js基础/">js基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/promise/">promise</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-node事件环" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/14/node事件环/" class="article-date">
  	<time datetime="2018-07-14T04:00:40.000Z" itemprop="datePublished">2018-07-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/14/node事件环/">node基础面试事件环？微任务、宏任务？一篇带你飞</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-gold-cdn.xitu.io/2018/6/29/16449b3ca264a461?w=228&amp;h=221&amp;f=png&amp;s=8299" alt=""></p>
<blockquote>
<p>培育能力的事必须继续不断地去做，又必须随时改善学习方法，提高学习效率，才会成功。 —— 叶圣陶</p>
</blockquote>
<h1 id="一、我们为什么要使用node，它的好处是什么？"><a href="#一、我们为什么要使用node，它的好处是什么？" class="headerlink" title="一、我们为什么要使用node，它的好处是什么？"></a>一、我们为什么要使用node，它的好处是什么？</h1><blockquote>
<p>Node的首要目标是提供一种简单的，用于创建高性能服务器的开发工具。还要解决web服务器高并发的用户请求。</p>
</blockquote>
<h2 id="解决高并发？"><a href="#解决高并发？" class="headerlink" title="解决高并发？"></a>解决高并发？</h2><p>我们这里来举个例子，我们node和java相比，在同样的请求下谁更占优一点。看图</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644973520f8be20?w=2288&amp;h=1222&amp;f=jpeg&amp;s=224747" alt=""></p>
<ul>
<li>当用户请求量增高时，node相对于java有更好的处理<code>并发</code>性能，它可以快速通过主线程绑定事件。java每次都要创建一个线程，虽然java现在有个<code>线程池</code>的概念，可以控制线程的复用和数量。</li>
<li>异步i/o操作，node可以更快的操作数据库。java访问数据库会遇到一个并行的问题，需要添加一个锁的概念。我们这里可以打个比方，下课去饮水机接水喝，java是一下子有喝多人去接水喝，需要等待，node是每次都只去一个人接水喝。</li>
<li>密集型CPU运算指的是逻辑处理运算、压缩、解压、加密、解密，node遇到CPU密集型运算时会阻塞主线程<code>(单线程)</code>，导致其下面的时间无法快速绑定，所以<code>node不适用于大型密集型CPU运算案例</code>，而java却很适合。</li>
</ul>
<h2 id="node在web端场景？"><a href="#node在web端场景？" class="headerlink" title="node在web端场景？"></a>node在web端场景？</h2><p>web端场景主要是<code>用户的请求</code>或者<code>读取静态资源</code>什么的，很适合node开发。应用场景主要有<code>聊天服务器</code>，<code>电子商务网站</code>等等这些高并发的应用。</p>
<h1 id="二、node是什么？"><a href="#二、node是什么？" class="headerlink" title="二、node是什么？"></a>二、node是什么？</h1><p><strong>Node.js是一个基于 Chrome V8 引擎的JavaScript<code>运行环境(runtime)</code>,Node不是一门语言，是让js运行在后端的<code>运行时</code>,并且不包括javascript全集,因为在服务端中不包含<code>DOM</code>和<code>BOM</code>,Node也提供了一些新的模块例如<code>http,fs</code>模块等。Node.js 使用了<code>事件驱动、非阻塞式 I/O</code>的模型，使其轻量又高效并且Node.js 的包管理器 <code>npm</code>，是全球最大的开源库生态系统。</strong></p>
<blockquote>
<p>总而言之，言而总之，它只是一个运行时，一个运行环境。</p>
</blockquote>
<h2 id="node特性"><a href="#node特性" class="headerlink" title="node特性"></a>node特性</h2><ul>
<li>主线程是单线程（异步），将后续的逻辑写成函数，传入到当前执行的函数中，当执行的函数得到了结果后，执行传入的函数<code>（回调函数）</code>。</li>
<li>五个人同时吃一碗饭（异步）。</li>
<li>阻塞不能异步（现在假定数据库是厨师，服务员是node，顾客是请求，一般是厨师做菜让一个服务员递给多个用户，如果厨师邀请服务员聊天，就会导致阻塞，并且是针对内核说的）。</li>
<li>i/o操作，读写操作，异步读写（能用异步绝不用同步） <code>非阻塞式i/o</code>，即可以异步读写。</li>
<li>event-driven<code>事件驱动</code>（发布订阅）。</li>
</ul>
<h2 id="node的进程与线程"><a href="#node的进程与线程" class="headerlink" title="node的进程与线程"></a>node的进程与线程</h2><blockquote>
<p><code>进程</code>是操作系统分配资源和调度任务的基本单位,<code>线程</code>是建立在进程上的一次程序运行单位，一个进程上可以有多个线程。</p>
</blockquote>
<p><strong>在此之前我们先来看看浏览器的进程机制</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/16449b3ca248f42b?w=2880&amp;h=1800&amp;f=png&amp;s=194399" alt=""></p>
<p>自上而下，分别是：</p>
<ul>
<li><strong>用户界面</strong>–包括地址栏、书签菜单等</li>
<li><strong>浏览器引擎</strong>–用户界面和渲染引擎之间的传送指令（浏览器的主进程）</li>
<li><strong>渲染引擎</strong>–浏览器的内核，如（webkit，Gecko）</li>
<li><strong>其他</strong>–网络请求，js线程和ui线程</li>
</ul>
<blockquote>
<p>从我们的角度来看，我们更关心的是浏览器的<code>渲染引擎</code>，让我们往下看。</p>
</blockquote>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><ul>
<li>渲染引擎是<code>多线程</code>的，包含ui线程和js线程。ui线程和js线程会<strong>互斥</strong>，因为js线程的运行结果会影响ui线程，ui更新会被保存在队列，直到js线程空闲，则被取出来更新。</li>
<li>js单线程是单线程的，为什么呢？假如js是多线程的，那么操作DOM就是多线程操作，那样的话就会很<strong>混乱</strong>，DOM不知道该听谁的，而这里的单线程指得是主线程是单线程的，他同样可以有异步线程，通过队列存放这些线程，而主线程依旧是单线程，这个我们后面再讲。所以在node中js也是单线程的。</li>
<li>单线程的好处就是节约内存，不需要再切换的时候执行上下文，也不用管锁的概念，因为我们每次都通过一个。</li>
</ul>
<h1 id="三、浏览器中的Event-Loop"><a href="#三、浏览器中的Event-Loop" class="headerlink" title="三、浏览器中的Event Loop"></a>三、浏览器中的Event Loop</h1><p>这里我先要说一下浏览器的事件环，可能有人会说，你这篇文章明明是讲node的怎么会扯到浏览器。首先他们都是以js为底层语言的不同运行时，有其相似之处，再者多学一点也不怕面试官多问。好了我废话不多说，开始。</p>
<h2 id="首先我们需要知道堆，栈和队列的关系和意义。"><a href="#首先我们需要知道堆，栈和队列的关系和意义。" class="headerlink" title="首先我们需要知道堆，栈和队列的关系和意义。"></a>首先我们需要知道堆，栈和队列的关系和意义。</h2><ul>
<li>堆（heap）：堆是存放对象的一个空间（Object、function）</li>
<li>队列（loop）：是指存放所有异步请求操作的结果，直到有一个异步操作完成它的使命，就会在loop中添加一个事件，<code>队列是先进先出的</code>，比如下面的图，最先进队列的会先被打出去</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644a173bb4f6bd4?w=400&amp;h=225&amp;f=gif&amp;s=3690752" alt="隔山打牛！"></p>
<ul>
<li>栈（stack）：栈本身是存储基础的变量，比如1，2，3，还有引用的变量，这里可能有人会问你上面的堆不是存放引用类型的对象吗，怎么变栈里去了。这里我要解释一下，因为栈里面的存放的<code>引用变量</code>是指向堆里的引用对象的<strong>地址</strong>，<strong>只是一串地址</strong>。这里栈代表的是执行栈，我们js的主线程。<code>栈是先进后出的</code>，先进后出就是相当于喝水的水杯，我们倒水进去，理论上喝到的水是最后进水杯的。我们可以看代码，<strong>follow me</strong>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>)</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>)    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'c'</span>)</div><div class="line">    &#125;</div><div class="line">    c()</div><div class="line">  &#125;</div><div class="line">  b()</div><div class="line">&#125;</div><div class="line">a()</div><div class="line"></div><div class="line"><span class="comment">//这段代码是输出a,b,c,执行栈中的顺序的c，b，a，如果是遵循先进先出，就是输出c，b，a。所以栈先进后出这个特性大家要牢记。</span></div></pre></td></tr></table></figure>
<p>OK,现在大家已经知道堆，栈和队列的关系，现在我们来看一张图。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644a2d1744a0431?w=500&amp;h=438&amp;f=jpeg&amp;s=26999" alt=""></p>
<p>我分析一下这张图</p>
<ul>
<li>我们的同步任务在主线程上运行会形成一个执行栈</li>
<li>如果碰到异步任务，比如<code>setTimeout、onClick</code>等等的一些操作，我们会将他的执行结果放入队列，此期间主线程不阻塞</li>
<li>等到主线程中的所有同步任务执行完毕，就会通过<code>event loop</code>在队列里面从头开始取，在执行栈中执行</li>
<li><code>event loop</code>永远不会断</li>
<li>以上的这一整个流程就是<code>Event Loop</code>（事件循环机制）</li>
</ul>
<h2 id="微任务、宏任务？"><a href="#微任务、宏任务？" class="headerlink" title="微任务、宏任务？"></a>微任务、宏任务？</h2><blockquote>
<p>macro-task(宏任务): setTimeout，setImmediate，MessageChannel<br>micro-task(微任务): 原生Promise(有些实现的promise将then方法放到了宏任务中),Object.observe(已废弃), MutationObserver</p>
</blockquote>
<p><strong>微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。那么他们之间到底有什么区别呢</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644a8518a955796?w=1406&amp;h=1230&amp;f=jpeg&amp;s=576887" alt=""></p>
<p><strong>每次执行栈的同步任务执行完毕，就会去任务队列中取出完成的异步任务，队列中又分为<code>microtasks queues和宏任务队列</code>等到把<code>microtasks queues所有的microtasks</code>都执行完毕,注意是<code>所有的</code>,他才会从<code>宏任务队列</code>中取事件。等到把队列中的事件取出<code>一个</code>，放入执行栈执行完成，就算一次循环结束，之后<code>event loop</code>还会继续循环，他会再去<code>microtasks queues</code>执行所有的任务，然后再从<code>宏任务队列</code>里面取<code>一个</code>，如此反复循环。</strong></p>
<ul>
<li>同步任务执行完</li>
<li>去执行<code>microtasks</code>，把所有<code>microtasks queues</code>清空</li>
<li>取出一个<code>macrotasks queues</code>的完成事件，在执行栈执行</li>
<li>再去执行<code>microtasks</code></li>
<li>…</li>
<li>…</li>
<li>…</li>
</ul>
<p>我这么说可能大家会有点懵，不慌，我们来看一道题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</div><div class="line">&#125;,<span class="number">0</span>)</div><div class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</div><div class="line">  resolve()</div><div class="line">&#125;)</div><div class="line">p.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>最后输出结果是Promise1，Promise2，setTimeout1</strong></p>
<ul>
<li>Promise参数中的Promise1是同步执行的，Promise还不是很了解的可以看看我另外一篇文章<a href="https://juejin.im/post/5b32f552f265da59991155f0" target="_blank" rel="external">Promise之你看得懂的Promise</a>,</li>
<li>其次是因为Promise是<code>microtasks</code>，会在同步任务执行完后会去<strong>清空<code>microtasks queues</code></strong>，</li>
<li>最后清空完微任务再去<strong>宏任务队列取值</strong>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)  </div><div class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</div><div class="line">  &#125;,<span class="number">0</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</div><div class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </div><div class="line">  &#125;)</div><div class="line">&#125;,<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><strong>这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2</strong></p>
<ul>
<li>一开始执行栈的同步任务执行完毕，会去<code>microtasks queues</code>找</li>
<li>清空<code>microtasks queues</code>，输出<strong>Promise1</strong>，同时会生成一个异步任务setTimeout1</li>
<li>去<code>宏任务队列</code>查看此时队列是setTimeout1在setTimeout2之前，因为setTimeout1执行栈一开始的时候就开始异步执行,所以输出<strong>setTimeout1</strong>，在执行setTimeout1时会生成Promise2的一个microtasks，放入<code>microtasks queues</code>中</li>
<li>接着又是一个循环，去清空<code>microtasks queues</code>，输出<strong>Promise2</strong></li>
<li>清空完<code>microtasks queues</code>，就又会去宏任务队列取一个，这回取的是<strong>setTimeout2</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644bc7e669cd8b6?w=2020&amp;h=1292&amp;f=png&amp;s=395321" alt=""></p>
<h1 id="四、node中的事件环"><a href="#四、node中的事件环" class="headerlink" title="四、node中的事件环"></a>四、node中的事件环</h1><p>node的事件环相比浏览器就不一样了，我们先来看一张图，他的工作流程</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644ad464210b649?w=800&amp;h=316&amp;f=webp&amp;s=20310" alt=""></p>
<ul>
<li>首先我们能看到我们的js代码<code>（APPLICATION）</code>会先进入v8引擎,v8引擎中主要是一些<code>setTimeout</code>之类的方法。</li>
<li>其次如果我们的代码中执行了nodeApi，比如<code>require(&#39;fs&#39;).read()</code>，node就会交给<code>libuv</code>库处理，这个<code>libuv</code>库是别人写的，他就是node的事件环。</li>
<li><code>libuv</code>库是通过单线程异步的方式来处理事件，我们可以看到<code>work threads</code>是个多线程的队列，通过外面<code>event loop</code>阻塞的方式来进行异步调用。</li>
<li>等到<code>work threads</code>队列中有执行完成的事件，就会通过<code>EXECUTE CALLBACK</code>回调给<code>EVENT QUEUE</code>队列，把它放入队列中。</li>
<li>最后通过事件驱动的方式，取出<code>EVENT QUEUE</code>队列的事件，交给我们的应用</li>
</ul>
<h2 id="node中的event-loop"><a href="#node中的event-loop" class="headerlink" title="node中的event loop"></a>node中的event loop</h2><blockquote>
<p>node中的event loop是在libuv里面的，libuv里面有个事件环机制，他会在启动node时，初始化事件环</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644b17495b10980?w=838&amp;h=992&amp;f=jpeg&amp;s=153226" alt=""></p>
<ul>
<li>这里的每一个阶段都对应着一个<strong>事件队列</strong></li>
<li>每当<code>event loop</code>执行到某个阶段时，都会执行对应的<strong>事件队列</strong>中的事件，依次执行</li>
<li>当该队列执行完毕或者执行数量超过上限，<code>event loop</code>就会执行下一个阶段</li>
<li>每当<code>event loop</code>切换一个执行队列时，就会去清空<code>microtasks queues</code>，然后再切换到下个队列去执行，如此反复</li>
</ul>
<p><strong>这里我们要注意<code>setImmediate</code>是属于check队列的，还有poll队列主要是异步的I/O操作，比如node中的fs.readFile()</strong></p>
<blockquote>
<p>我们来具体看一下他的用法吧</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate1'</span>)</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)    </div><div class="line">  &#125;,<span class="number">0</span>)</div><div class="line">&#125;)</div><div class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>) </div><div class="line">  process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'nextTick1'</span>)&#125;)</div><div class="line">  setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate2'</span>)</div><div class="line">  &#125;)   </div><div class="line">&#125;,<span class="number">0</span>)</div></pre></td></tr></table></figure>
<ul>
<li>首先我们可以看到上面的代码先执行的是<code>setImmediate1</code>,此时<code>event loop</code>在<strong>check队列</strong></li>
<li>然后<code>setImmediate1</code>从队列取出之后，输出<code>setImmediate1</code>，然后会将<code>setTimeout1</code>执行</li>
<li>此时<code>event loop</code>执行完<strong>check队列</strong>之后，开始往下移动，接下来执行的是<strong>timers队列</strong></li>
<li>这里会有问题，我们都知道<code>setTimeout1</code>设置延迟为0的话，其实还是有<strong>4ms</strong>的延迟，那么这里就会有两种情况。先说第一种，此时<code>setTimeout1</code>已经执行完毕<ul>
<li>根据node事件环的规则，我们会执行完所有的事件，即取出<strong>timers队列</strong>中的<code>setTimeout2,setTimeout1</code></li>
<li>此时根据队列先进先出规则，输出顺序为<code>setTimeout2,setTimeout1</code>，在取出<code>setTimeout2</code>时，会将一个<code>process.nextTick</code>执行（执行完了就会被放入<strong>微任务队列</strong>），再将一个<code>setImmediate</code>执行（执行完了就会被放入<strong>check队列</strong>）</li>
<li>到这一步，<code>event loop</code>会再去寻找下个事件队列，此时<code>event loop</code>会发现<strong>微任务队列</strong>有事件<code>process.nextTick</code>，就会去清空它，输出<code>nextTick1</code></li>
<li>最后<code>event loop</code>找到下个有事件的队列<strong>check队列</strong>，执行<code>setImmediate</code>，输出<code>setImmediate2</code></li>
</ul>
</li>
<li>假如这里<code>setTimeout1</code>还未执行完毕（4ms耽误了它的终身大事？）<ul>
<li>此时<code>event loop</code>找到<strong>timers队列</strong>，取出<em>timers队列*</em>中的<code>setTimeout2</code>，输出<code>setTimeout2</code>，把<code>process.nextTick</code>执行，再把<code>setImmediate</code>执行</li>
<li>然后<code>event loop</code>需要去找下一个事件队列，<strong>这里大家要注意一下</strong>，这里会发生2步操作，<strong>1、<code>setTimeout1</code>执行完了，放入timers队列。2、找到微任务队列清空。</strong>，所以此时会先输出<code>nextTick1</code></li>
<li>接下来<code>event loop</code>会找到<strong>check队列</strong>，取出里面已经执行完的<code>setImmediate2</code></li>
<li>最后<code>event loop</code>找到<strong>timers队列</strong>，取出执行完的<code>setTimeout1</code>。<strong>这种情况下<code>event loop</code>比上面要多切换一次</strong></li>
</ul>
</li>
</ul>
<p>所以有两种答案</p>
<ol>
<li><code>setImmediate1,setTimeout2,setTimeout1,nextTick1,setImmediate2</code></li>
<li><code>setImmediate1,setTimeout2,nextTick1,setImmediate2,setTimeout1</code></li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644b640567422fe?w=2880&amp;h=1800&amp;f=png&amp;s=527100" alt=""></p>
<p>这里的图只参考了第一种情况，另一种情况也类似</p>
<h1 id="五、node的同步、异步，阻塞、非阻塞"><a href="#五、node的同步、异步，阻塞、非阻塞" class="headerlink" title="五、node的同步、异步，阻塞、非阻塞"></a>五、node的同步、异步，阻塞、非阻塞</h1><ul>
<li>同步：即为调用者等待被调用者这个过程，如果被调用者一直不反回结果，调用者就会一直等待，这就是同步，<strong>同步有返回值</strong></li>
<li>异步：即为调用者不等待被调用者是否返回，被调用者执行完了就会通过状态、通知或者回调函数给调用者，<strong>异步没有返回值</strong></li>
<li>阻塞：指代当前线程在结果返回之前会被挂起，不会继续执行下去</li>
<li>非阻塞： 即当前线程不管你返回什么，都会继续往下执行</li>
</ul>
<p><strong>有些人可能会搞乱他们之间的关系，<code>同步、异步</code>是被调用者的状态，<code>阻塞、非阻塞</code>是调用者的状态、消息</strong></p>
<p>接下来我们来看看他们的组合会是怎么样的</p>
<table>
<thead>
<tr>
<th>组合</th>
<th style="text-align:left">意义 </th>
</tr>
</thead>
<tbody>
<tr>
<td>同步阻塞</td>
<td style="text-align:left">这就相当于我去饭店吃饭，我需要在厨房等待菜烧好了，才能吃。我是调用者我需要等待上菜于是被阻塞，菜是被调用者做好直接给我是同步</td>
</tr>
<tr>
<td>异步阻塞</td>
<td style="text-align:left">我去饭店吃饭，我需要等待菜烧好了才能吃，但是厨师有事，希望之后处理完事能做好之后通知我去拿，我作为调用者等待就是阻塞的，而菜作为被调用者是做完之后通知我的，所以是异步的，这种方式一般没用。</td>
</tr>
<tr>
<td>同步非阻塞</td>
<td style="text-align:left">我去饭店吃饭，先叫了碗热菜，在厨房等厨师做菜，但我很饿，就开始吃厨房冷菜，我是调用者我没等热菜好就开始吃冷菜，是非阻塞的，菜作为被调用者做好直接给我是同步的，这种方式一般也没人用</td>
</tr>
<tr>
<td>异步非阻塞</td>
<td style="text-align:left">我去饭店吃饭。叫了碗热菜，厨师在做菜，但我很饿，先吃冷菜，厨师做好了通知我去拿，我是调用者我不会等热菜烧好了再吃冷菜，是非阻塞的，菜作为被调用者通知我拿是异步的</td>
</tr>
</tbody>
</table>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>希望大家看了本篇文章都有收获，这样出去面试的时候就不会这样<img src="https://user-gold-cdn.xitu.io/2018/6/29/1644be1f30719d81?w=444&amp;h=250&amp;f=gif&amp;s=4719128" alt=""><br>而是这样。好了，最后希望大家世界杯都能够<strong>逢赌必赢</strong>，自己喜欢的球队也能够<strong>杀进决赛</strong>。<br><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644be34b6bb9dd0?w=367&amp;h=217&amp;f=gif&amp;s=3997305" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/">node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事件环/">事件环</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/宏任务/">宏任务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微任务/">微任务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-stream" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/14/stream/" class="article-date">
  	<time datetime="2018-07-14T04:00:40.000Z" itemprop="datePublished">2018-07-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/14/stream/">渴望力量吗？少年！流的原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="流-stream-，看一个人流不流逼，就看你对流的理解了"><a href="#流-stream-，看一个人流不流逼，就看你对流的理解了" class="headerlink" title="流(stream)，看一个人流不流逼，就看你对流的理解了"></a>流(stream)，看一个人流不流逼，就看你对流的理解了</h2><blockquote>
<p>学习本无底，前进莫徬徨</p>
</blockquote>
<p>今天跟大家分享的是node.js中的流(<code>stream</code>)。它的作用大家应该都在平常使用node的时候看到过，比如：</p>
<ul>
<li><code>gulp</code>中的pipe就是流的一种方法，通过可写流和可读流的配合，达到不占用多余缓存的一种读写方式。</li>
<li>express和koa中的res和req也是流，res是<code>可写流</code>，req是<code>可读流</code>，他们都是通过封装node中的net模块的socket(<code>双工流</code>，即可写、可读流)而来的。</li>
<li>。。。</li>
</ul>
<p>可能很多时候大家都知道怎么用，但不了解它的原理，很尴尬，就像这样</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16491e3c412fbd6f?w=300&amp;h=217&amp;f=gif&amp;s=471574" alt=""></p>
<h2 id="何谓流？"><a href="#何谓流？" class="headerlink" title="何谓流？"></a>何谓流？</h2><ul>
<li>流是一组有序的，有起点和终点的字节数据传输手段。</li>
<li>它不关心文件的整体内容，只关注是否从文件中读到了数据，以及读到数据之后的处理。</li>
<li>流是一个抽象接口，被 Node 中的很多对象所实现。比如HTTP 服务器request和response对象都是流。</li>
<li>流被分为<code>Readable</code>(可读流)、<code>Writable</code>(可写流)、<code>Duplex</code>(双工流)、<code>Transform</code>(转换流)</li>
</ul>
<h2 id="流中的是什么？"><a href="#流中的是什么？" class="headerlink" title="流中的是什么？"></a>流中的是什么？</h2><ul>
<li><code>二进制模式</code>:每个分块都是buffer、string对象。</li>
<li><code>对象模式</code>:流内部处理的是一系列普通对象。</li>
</ul>
<h2 id="可读流"><a href="#可读流" class="headerlink" title="可读流"></a>可读流</h2><blockquote>
<p>可读流分为<code>flowing</code>和<code>paused</code>两种模式</p>
</blockquote>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>path</code>:读取的文件的路径</li>
<li><code>option</code>:<ul>
<li><code>highWaterMark</code>:水位线，一次可读的字节，一般默认是<code>64k</code></li>
<li><code>flags</code>:标识，打开文件要做的操作，默认是<code>r</code></li>
<li><code>encoding</code>:编码，默认为buffer</li>
<li><code>start</code>:开始读取的索引位置</li>
<li><code>end</code>:结束读取的索引位置(包括结束位置)</li>
<li><code>autoClose</code>:读取完毕是否关闭，默认为true</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>)</div><div class="line"><span class="comment">//读取的时候默认读64k </span></div><div class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(<span class="string">'./a.txt'</span>,&#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">2</span>,<span class="comment">//一次读的字节 默认64k</span></div><div class="line">  flags: <span class="string">'r'</span>,      <span class="comment">//标示 r为读 w为写</span></div><div class="line">  autoClose: <span class="literal">true</span>, <span class="comment">//默认读取完毕后自动关闭</span></div><div class="line">  start: <span class="number">0</span>,</div><div class="line">  <span class="attr">end</span>: <span class="number">5</span>,          <span class="comment">//流是闭合区间包start，也包end 默认是读完</span></div><div class="line">  encoding: <span class="string">'utf8'</span> <span class="comment">//默认编码是buffer</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="data-切换到流动模式，可以流出数据"><a href="#data-切换到流动模式，可以流出数据" class="headerlink" title="data:切换到流动模式，可以流出数据"></a><code>data</code>:切换到流动模式，可以流出数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="open-流打开文件的时候会触发此监听"><a href="#open-流打开文件的时候会触发此监听" class="headerlink" title="open:流打开文件的时候会触发此监听"></a><code>open</code>:流打开文件的时候会触发此监听</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'文件被打开'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="error-流出错的时候，监听错误信息"><a href="#error-流出错的时候，监听错误信息" class="headerlink" title="error:流出错的时候，监听错误信息"></a><code>error</code>:流出错的时候，监听错误信息</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="end-流读取完成，触发end"><a href="#end-流读取完成，触发end" class="headerlink" title="end:流读取完成，触发end"></a><code>end</code>:流读取完成，触发end</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'读取完成'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="close-关闭流，触发"><a href="#close-关闭流，触发" class="headerlink" title="close:关闭流，触发"></a><code>close</code>:关闭流，触发</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'关闭'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="pause-暂停流-改变流的flowing，不读取数据了-；resume-恢复流-改变流的flowing-继续读取数据"><a href="#pause-暂停流-改变流的flowing，不读取数据了-；resume-恢复流-改变流的flowing-继续读取数据" class="headerlink" title="pause:暂停流(改变流的flowing，不读取数据了)；resume:恢复流(改变流的flowing,继续读取数据)"></a><code>pause</code>:暂停流(改变流的flowing，不读取数据了)；<code>resume</code>:恢复流(改变流的flowing,继续读取数据)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//流通过一次后，停止流动，过了2s后再动</span></div><div class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    rs.pause();</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    rs.resume();</div><div class="line">&#125;,<span class="number">2000</span>);</div></pre></td></tr></table></figure>
<h4 id="fs-read-可读流底层调用的就是这个方法，最原生的读方法"><a href="#fs-read-可读流底层调用的就是这个方法，最原生的读方法" class="headerlink" title="fs.read():可读流底层调用的就是这个方法，最原生的读方法"></a><code>fs.read()</code>:可读流底层调用的就是这个方法，最原生的读方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//fd文件描述符，一般通过fs.open中获取</span></div><div class="line"><span class="comment">//buffer是读取后的数据放入的缓存目标</span></div><div class="line"><span class="comment">//0，从buffer的0位置开始放入</span></div><div class="line"><span class="comment">//BUFFER_SIZE，每次放BUFFER_SIZE这么长的长度</span></div><div class="line"><span class="comment">//index，每次从文件的index的位置开始读</span></div><div class="line"><span class="comment">//bytesRead，真实读到的个数</span></div><div class="line">fs.read(fd,buffer,<span class="number">0</span>,BUFFER_SIZE,index,<span class="function"><span class="keyword">function</span>(<span class="params">err,bytesRead</span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="那让我们自己来实现一个可爱的读流吧！"><a href="#那让我们自己来实现一个可爱的读流吧！" class="headerlink" title="那让我们自己来实现一个可爱的读流吧！"></a>那让我们自己来实现一个<code>可爱</code>的读流吧！</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/164920492aaecdf9?w=419&amp;h=233&amp;f=gif&amp;s=1680530" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(path,options = &#123;&#125;)&#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.path = path</div><div class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span>*<span class="number">1024</span></div><div class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span></div><div class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span></div><div class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start     <span class="comment">//会随着读取的位置改变</span></div><div class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.end = options.end || <span class="literal">null</span></div><div class="line">    <span class="comment">//默认null就是buffer</span></div><div class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">//参数的问题</span></div><div class="line">    <span class="keyword">this</span>.flowing = <span class="literal">null</span> <span class="comment">//非流动模式</span></div><div class="line">    <span class="comment">//创建个buffer用来存储每次读出来的数据</span></div><div class="line">    <span class="keyword">this</span>.buffer = Buffer.alloc(<span class="keyword">this</span>.highWaterMark)</div><div class="line">    <span class="comment">//打开这个文件</span></div><div class="line">    <span class="keyword">this</span>.open()</div><div class="line">    <span class="comment">//此方法默认同步调用 每次设置on监听事件时都会调用之前所有的newListener事件</span></div><div class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>,(type)=&gt;&#123;<span class="comment">// 等待着他监听data事件</span></div><div class="line">      <span class="keyword">if</span>(type === <span class="string">'data'</span>)&#123;</div><div class="line">        <span class="keyword">this</span>.flowing = <span class="literal">true</span></div><div class="line">        <span class="comment">//开始读取 客户已经监听的data事件</span></div><div class="line">        <span class="keyword">this</span>.read()</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//默认第一次调用read方法时fd还没获取 所以不能直接读</span></div><div class="line">  read()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="comment">//等待着触发open事件后fd肯定拿到了 再去执行read方法</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>,()=&gt;&#123;<span class="keyword">this</span>.read()&#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//每次读的时候都要判断一下下次读几个 如果没有end就根据highWaterMark来(读所有的) 如果有且大于highWaterMark就根据highWaterMark来 如果小于highWaterMark就根据end来</span></div><div class="line">    <span class="keyword">let</span> howMuchToRead = <span class="keyword">this</span>.end?<span class="built_in">Math</span>.min(<span class="keyword">this</span>.end - <span class="keyword">this</span>.pos + <span class="number">1</span>,<span class="keyword">this</span>.highWaterMark):<span class="keyword">this</span>.highWaterMark</div><div class="line">    fs.read(<span class="keyword">this</span>.fd,<span class="keyword">this</span>.buffer,<span class="number">0</span>,howMuchToRead,<span class="keyword">this</span>.pos,(err,byteRead)=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.pos += byteRead</div><div class="line">      <span class="keyword">let</span> b = <span class="keyword">this</span>.encoding?<span class="keyword">this</span>.buffer.slice(<span class="number">0</span>,byteRead).toString(<span class="keyword">this</span>.encoding):<span class="keyword">this</span>.buffer.slice(<span class="number">0</span>,byteRead)</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'data'</span>,b)</div><div class="line">      <span class="comment">//如果读取到的数量和highWaterMark一样 说明还得继续读</span></div><div class="line">      <span class="keyword">if</span>((byteRead === <span class="keyword">this</span>.highWaterMark)&amp;&amp;<span class="keyword">this</span>.flowing)&#123;</div><div class="line">        <span class="keyword">this</span>.read()</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(byteRead &lt; <span class="keyword">this</span>.highWaterMark)&#123;</div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'end'</span>)</div><div class="line">        <span class="keyword">this</span>.destory()</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  destory()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果文件被打开过 就关闭文件并且触发close事件</span></div><div class="line">    fs.close(<span class="keyword">this</span>.fd,()=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  pause()&#123;</div><div class="line">    <span class="keyword">this</span>.flowing = <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  resume()&#123;</div><div class="line">    <span class="keyword">this</span>.flowing = <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.read()</div><div class="line">  &#125;</div><div class="line">  open()&#123;</div><div class="line">    <span class="comment">//fd表示的就是当前this.path的这个文件，从3开始(number类型)</span></div><div class="line">    fs.open(<span class="keyword">this</span>.path,<span class="keyword">this</span>.flags,(err,fd)=&gt;&#123;</div><div class="line">      <span class="comment">//有可能fd这个文件不存在 需要做处理</span></div><div class="line">      <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="comment">//如果有自动关闭 则帮他销毁</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autoClose)&#123;</div><div class="line">          <span class="comment">//销毁（关闭文件，触发关闭文件事件）</span></div><div class="line">          <span class="keyword">this</span>.destory()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有错误 就会触发error事件</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'error'</span>,err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//保存文件描述符</span></div><div class="line">      <span class="keyword">this</span>.fd = fd</div><div class="line">      <span class="comment">//当文件打开成功时触发open事件</span></div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Readable"><a href="#Readable" class="headerlink" title="Readable"></a>Readable</h3><blockquote>
<p>这个方法是可读流的一种<code>暂停模式</code>，他的模式可以参考为读<code>流是往水杯倒水的人，Readable是喝水的人，他们之间存在着一种联系，只要Readable喝掉一点水，读流就会继续往里倒</code>。</p>
</blockquote>
<h4 id="Readable是什么？"><a href="#Readable是什么？" class="headerlink" title="Readable是什么？"></a>Readable是什么？</h4><ul>
<li>他会在刚开始监听Readable的时候就触发流的，此时流就会读取一次数据，之后<code>流会监听,如果有人读过流(喝过水)，并且减少，就会再去读一次(倒点水)</code></li>
<li>主要可以用来做<code>行读取器(LineReader)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> read = <span class="built_in">require</span>(<span class="string">'./ReadableStream'</span>)</div><div class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./a.txt'</span>, &#123;</div><div class="line">  <span class="comment">//每次读7个</span></div><div class="line">  highWaterMark: <span class="number">7</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">//如果读流第一次全部读下来并且小于highWaterMark，就会再读一次(再触发一次readable事件)</span></div><div class="line"><span class="comment">//如果rs.read()不加参数，一次性读完，会从缓存区再读一次，为null</span></div><div class="line"><span class="comment">//如果readable每次都刚好读完(即rs.read()的参数刚好和highWaterMark相等)，就会一直触发readable事件，如果最后不足他想喝的数，他就会先触发一次null，最后把剩下的喝完</span></div><div class="line"><span class="comment">//一开始缓存区为0的时候也会默认调一次readable事件</span></div><div class="line">rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> result = rs.read(<span class="number">2</span>)</div><div class="line">  <span class="built_in">console</span>.log(result)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>实战：行读取器(平常我们的文件可能有回车、换行，此时如果要每次想读一行的数据，就得用到<code>readable</code>)</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="comment">//如果要将内容全部读出就用on('data')，精确读取就用on('readable')</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineReader</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(path) &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.rs = fs.createReadStream(path)</div><div class="line">    <span class="comment">//回车符的十六进制</span></div><div class="line">    <span class="keyword">let</span> RETURN = <span class="number">0x0d</span></div><div class="line">    <span class="comment">//换行符的十六进制</span></div><div class="line">    <span class="keyword">let</span> LINE = <span class="number">0x0a</span></div><div class="line">    <span class="keyword">let</span> arr = []</div><div class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, (type) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (type === <span class="string">'newLine'</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</div><div class="line">          <span class="keyword">let</span> char</div><div class="line">          <span class="comment">//每次读一个，当读完的时候会返回null，终止循环</span></div><div class="line">          <span class="keyword">while</span> (char = <span class="keyword">this</span>.rs.read(<span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">switch</span> (char[<span class="number">0</span>]) &#123;</div><div class="line">              <span class="keyword">case</span> RETURN:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">              <span class="comment">//Mac下只有换行符，windows下是回车符和换行符，需要根据不同的转换。因为我这里是Mac</span></div><div class="line">              <span class="keyword">case</span> LINE:</div><div class="line">                <span class="comment">//如果是换行符就把数组转换为字符串</span></div><div class="line">                <span class="keyword">let</span> r = Buffer.from(arr).toString(<span class="string">'utf8'</span>)</div><div class="line">                <span class="comment">//把数组清空</span></div><div class="line">                arr.length = <span class="number">0</span></div><div class="line">                <span class="comment">//触发newLine事件，把得到的一行数据输出</span></div><div class="line">                <span class="keyword">this</span>.emit(<span class="string">'newLine'</span>, r)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">              <span class="keyword">default</span>:</div><div class="line">                <span class="comment">//如果不是换行符，就放入数组中</span></div><div class="line">                arr.push(char[<span class="number">0</span>])</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">//以上只能取出之前的换行符前的代码，最后一行的后面没有换行符，所以需要特殊处理。当读流读完需要触发end事件时</span></div><div class="line">    <span class="keyword">this</span>.rs.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">      <span class="comment">//取出最后一行数据，转成字符串</span></div><div class="line">      <span class="keyword">let</span> r = Buffer.from(arr).toString(<span class="string">'utf8'</span>)</div><div class="line">      arr.length = <span class="number">0</span></div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'newLine'</span>, r)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> lineReader = <span class="keyword">new</span> LineReader(<span class="string">'./a.txt'</span>)</div><div class="line">lineReader.on(<span class="string">'newLine'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>那么Readable到底是怎样的存在呢？我们接下来实现他的源码，看看内部到底怎么回事</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(path,options = &#123;&#125;)&#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.path = path</div><div class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span>*<span class="number">1024</span></div><div class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span></div><div class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span></div><div class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start     <span class="comment">//会随着读取的位置改变</span></div><div class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.end = options.end || <span class="literal">null</span></div><div class="line">    <span class="comment">//默认null就是buffer</span></div><div class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">//参数的问题</span></div><div class="line">    <span class="keyword">this</span>.reading = <span class="literal">false</span> <span class="comment">//非流动模式</span></div><div class="line">    <span class="comment">//创建个buffer用来存储每次读出来的数据</span></div><div class="line">    <span class="keyword">this</span>.buffers = []</div><div class="line">    <span class="comment">//缓存区长度</span></div><div class="line">    <span class="keyword">this</span>.len = <span class="number">0</span></div><div class="line">    <span class="comment">//是否要触发readable事件</span></div><div class="line">    <span class="keyword">this</span>.emittedReadable = <span class="literal">false</span></div><div class="line">    <span class="comment">//触发open获取文件的fd标识符</span></div><div class="line">    <span class="keyword">this</span>.open()</div><div class="line">    <span class="comment">//此方法默认同步调用 每次设置on监听事件时都会调用之前所有的newListener事件</span></div><div class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>,(type)=&gt;&#123;<span class="comment">// 等待着他监听data事件</span></div><div class="line">      <span class="keyword">if</span>(type === <span class="string">'readable'</span>)&#123;</div><div class="line">        <span class="comment">//开始读取 客户已经监听的data事件</span></div><div class="line">        <span class="keyword">this</span>.read()</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//readable真正的源码中的方法，计算出和n最接近的2的幂次数</span></div><div class="line">  computeNewHighWaterMark(n) &#123;</div><div class="line">    n--;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    n++;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">  &#125;</div><div class="line">  read(n)&#123;</div><div class="line">    <span class="comment">//当读的数量大于水平线，会通过取2的幂次取比他大和最接近的数</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.len &lt; n)&#123;</div><div class="line">      <span class="keyword">this</span>.highWaterMark = <span class="keyword">this</span>.computeNewHighWaterMark(n)</div><div class="line">      <span class="comment">//重新触发readbale的callback，所以第一次会触发null</span></div><div class="line">      <span class="keyword">this</span>.emittedReadable = <span class="literal">true</span></div><div class="line">      <span class="comment">//重新读新的水位线</span></div><div class="line">      <span class="keyword">this</span>._read()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//真正读取到的</span></div><div class="line">    <span class="keyword">let</span> buffer = <span class="literal">null</span></div><div class="line">    <span class="comment">//说明缓存里有这么多，取出来</span></div><div class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span> &amp;&amp; n&lt;=<span class="keyword">this</span>.len)&#123;</div><div class="line">      <span class="comment">//定义一个buffer</span></div><div class="line">      buffer = Buffer.alloc(n)</div><div class="line">      <span class="keyword">let</span> buf</div><div class="line">      <span class="keyword">let</span> flag = <span class="literal">true</span></div><div class="line">      <span class="keyword">let</span> index = <span class="number">0</span></div><div class="line">      <span class="comment">//[buffer&lt;1,2,3,4&gt;,buffer&lt;1,2,3,4&gt;,buffer&lt;1,2,3,4&gt;]</span></div><div class="line">      <span class="comment">//每次取出缓存前的第一个buffer</span></div><div class="line">      <span class="keyword">while</span>(flag &amp;&amp; (buf = <span class="keyword">this</span>.buffers.shift()))&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;buf.length;i++)&#123;</div><div class="line">          <span class="comment">//把取出的一个buffer中的数据放入新定义的buffer中</span></div><div class="line">          buffer[index++] = buf[i]</div><div class="line">          <span class="comment">//当buffer的长度和n(参数)长度一样时，停止循环</span></div><div class="line">          <span class="keyword">if</span>(index === n)&#123;</div><div class="line">            flag = <span class="literal">false</span></div><div class="line">            <span class="comment">//维护缓存，因为可能缓存中的buffer长度大于n，当取出n的长度时，还会剩下其余的buffer，我们需要切割buf并且放到缓存数组之前</span></div><div class="line">            <span class="keyword">this</span>.len -= n</div><div class="line">            <span class="keyword">let</span> r = buf.slice(i+<span class="number">1</span>)</div><div class="line">            <span class="keyword">if</span>(r.length)&#123;</div><div class="line">              <span class="keyword">this</span>.buffers.unshift(r)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果缓存区没有东西，等会读完需要触发readable事件</span></div><div class="line">    <span class="comment">//这里会有一种状况，就是如果每次Readable读取的数量正好等于highWaterMark(流读取到缓存的长度)，就会每次都等于0，每次都触发Readable事件，就会每次读，读到没有为止，最后还会触发一下null</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.len === <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">this</span>.emittedReadable = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.len &lt; <span class="keyword">this</span>.highWaterMark)&#123;</div><div class="line">      <span class="comment">//默认，一开始的时候开始读取</span></div><div class="line">      <span class="keyword">if</span>(!<span class="keyword">this</span>.reading)&#123;</div><div class="line">        <span class="keyword">this</span>.reading = <span class="literal">true</span></div><div class="line">        <span class="comment">//真正多读取操作</span></div><div class="line">        <span class="keyword">this</span>._read()</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> buffer&amp;&amp;buffer.toString()</div><div class="line">  &#125;</div><div class="line">  _read()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="comment">//等待着触发open事件后fd肯定拿到了 再去执行read方法</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>,()=&gt;&#123;<span class="keyword">this</span>._read()&#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//先读这么多buffer</span></div><div class="line">    <span class="keyword">let</span> buffer = Buffer.alloc(<span class="keyword">this</span>.highWaterMark)</div><div class="line">    fs.read(<span class="keyword">this</span>.fd,buffer,<span class="number">0</span>,buffer.length,<span class="keyword">this</span>.pos,(err,byteRead)=&gt;&#123;</div><div class="line">      <span class="keyword">if</span>(byteRead &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="comment">//当第一次读到数据后，改变reading的状态，如果触发read事件，可能还会在触发第二次_read</span></div><div class="line">        <span class="keyword">this</span>.reading = <span class="literal">false</span></div><div class="line">        <span class="comment">//每次读到数据增加缓存取得长度</span></div><div class="line">        <span class="keyword">this</span>.len += byteRead</div><div class="line">        <span class="comment">//每次读取之后，会增加读取的文件的读取开始位置</span></div><div class="line">        <span class="keyword">this</span>.pos += byteRead</div><div class="line">        <span class="comment">//将读到的buffer放入缓存区buffers中</span></div><div class="line">        <span class="keyword">this</span>.buffers.push(buffer.slice(<span class="number">0</span>,byteRead))</div><div class="line">        <span class="comment">//触发readable</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.emittedReadable)&#123;</div><div class="line">          <span class="keyword">this</span>.emittedReadable = <span class="literal">false</span></div><div class="line">          <span class="comment">//可以读取了，默认开始的时候杯子填满了</span></div><div class="line">          <span class="keyword">this</span>.emit(<span class="string">'readable'</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//没读到就出发end事件</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'end'</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  destory()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果文件被打开过 就关闭文件并且触发close事件</span></div><div class="line">    fs.close(<span class="keyword">this</span>.fd,()=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  open()&#123;</div><div class="line">    <span class="comment">//fd表示的就是当前this.path的这个文件，从3开始(number类型)</span></div><div class="line">    fs.open(<span class="keyword">this</span>.path,<span class="keyword">this</span>.flags,(err,fd)=&gt;&#123;</div><div class="line">      <span class="comment">//有可能fd这个文件不存在 需要做处理</span></div><div class="line">      <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="comment">//如果有自动关闭 则帮他销毁</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autoClose)&#123;</div><div class="line">          <span class="comment">//销毁（关闭文件，触发关闭文件事件）</span></div><div class="line">          <span class="keyword">this</span>.destory()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有错误 就会触发error事件</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'error'</span>,err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//保存文件描述符</span></div><div class="line">      <span class="keyword">this</span>.fd = fd</div><div class="line">      <span class="comment">//当文件打开成功时触发open事件</span></div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Readable和读流的data的区别就是，Readable可以控制自己从缓存区读多少和控制读的次数，而data是每次读取都清空缓存，读多少输出多少</li>
<li>我们可以看一下下面这个例子</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./a.txt'</span>)</div><div class="line">rs.on(<span class="string">'data'</span>,(data)=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(data)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//因为上面的data事件把数据读了，清空缓存区。所以导致下面的readable读出为null</span></div><div class="line">rs.on(<span class="string">'readable'</span>,()=&gt;&#123;</div><div class="line">  <span class="keyword">let</span> result = r.read(<span class="number">1</span>)</div><div class="line">  <span class="built_in">console</span>.log(result)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="自定义可读流"><a href="#自定义可读流" class="headerlink" title="自定义可读流"></a>自定义可读流</h3><p><strong>因为<code>createReadStream</code>内部调用了<code>ReadStream</code>类，<code>ReadStream</code>又实现了<code>Readable</code>接口,<code>ReadStream</code>实现了<code>_read()</code>方法,所以我们通过自定义一个类继承<code>stream</code>模块的<code>Readable</code>，并在<code>原型</code>上自定义一个<code>_read()</code>就可以自定义自己的可读流</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; Readable &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRead</span> <span class="keyword">extends</span> <span class="title">Readable</span></span>&#123;</div><div class="line">  <span class="comment">//流需要一个_read方法，方法中push什么，外面就接收什么</span></div><div class="line">  _read()&#123;</div><div class="line">    <span class="comment">//push方法就是上面_read方法中的push一样，把数据放入缓存区中</span></div><div class="line">    <span class="keyword">this</span>.push(<span class="string">'100'</span>)</div><div class="line">    <span class="comment">//如果push了null就表示没有东西可读了，停止(如果不写，就会一直push上面的值，死循环)</span></div><div class="line">    <span class="keyword">this</span>.push(<span class="literal">null</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="可写流"><a href="#可写流" class="headerlink" title="可写流"></a>可写流</h2><ul>
<li>如果文件不存在会创建，如果有内容会被清空</li>
<li>读取到highWaterMark的时候就会输出</li>
<li>第一次是真的写到文件 后面就是写入缓存区 再从缓存区里面去取</li>
</ul>
<h3 id="参数-和可读流的类似"><a href="#参数-和可读流的类似" class="headerlink" title="参数(和可读流的类似)"></a>参数(和可读流的类似)</h3><ul>
<li><code>path</code>:写入的文件的路径</li>
<li><code>option</code>:<ul>
<li><code>highWaterMark</code>:水位线，一次可写入缓存中的字节，一般默认是<code>64k</code></li>
<li><code>flags</code>:标识，写入文件要做的操作，默认是<code>w</code></li>
<li><code>encoding</code>:编码，默认为buffer</li>
<li><code>start</code>:开始写入的索引位置</li>
<li><code>end</code>:结束写入的索引位置(包括结束位置)</li>
<li><code>autoClose</code>:写入完毕是否关闭，默认为true</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>)</div><div class="line"><span class="comment">//读取的时候默认读64k </span></div><div class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(<span class="string">'./a.txt'</span>,&#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">2</span>,<span class="comment">//一次读的字节 默认64k</span></div><div class="line">  flags: <span class="string">'r'</span>,      <span class="comment">//标示 r为读 w为写</span></div><div class="line">  autoClose: <span class="literal">true</span>, <span class="comment">//默认读取完毕后自动关闭</span></div><div class="line">  start: <span class="number">0</span>,</div><div class="line">  <span class="attr">end</span>: <span class="number">5</span>,          <span class="comment">//流是闭合区间包start，也包end 默认是读完</span></div><div class="line">  encoding: <span class="string">'utf8'</span> <span class="comment">//默认编码是buffer</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="write"><a href="#write" class="headerlink" title="write"></a><code>write</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> ws = fs.createWriteStream(<span class="string">'./d.txt'</span>,&#123;</div><div class="line">  <span class="attr">flags</span>: <span class="string">'w'</span>,</div><div class="line">  <span class="attr">encoding</span>: <span class="string">'utf8'</span>,</div><div class="line">  <span class="attr">start</span>: <span class="number">0</span>,</div><div class="line">  <span class="comment">//write的highWaterMark只是用来触发是不是干了</span></div><div class="line">  highWaterMark: <span class="number">3</span> <span class="comment">//写是默认16k</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">//返回boolean 每当write一次都会在ws中吃下一个馒头 当吃下的馒头数量达到highWaterMark时 就会返回false 吃不下了会把其余放入缓存 其余状态返回true</span></div><div class="line"><span class="comment">//write只能放string或者buffer</span></div><div class="line">flag = ws.write(<span class="string">'1'</span>,<span class="string">'utf8'</span>,()=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(i)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="drain"><a href="#drain" class="headerlink" title="drain"></a><code>drain</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//drain只有嘴塞满了 吃完（包括内存中的，就是地下的）才会触发 这里是两个条件 一个是必须是吃下highWaterMark个馒头 并且在吃完的时候才会callback</span></div><div class="line">ws.on(<span class="string">'drain'</span>,()=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'干了'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16491a2ce2f22b41?w=1976&amp;h=1128&amp;f=jpeg&amp;s=170261" alt=""></p>
<h4 id="fs-write-可读流底层调用的就是这个方法，最原生的读方法"><a href="#fs-write-可读流底层调用的就是这个方法，最原生的读方法" class="headerlink" title="fs.write():可读流底层调用的就是这个方法，最原生的读方法"></a><code>fs.write()</code>:可读流底层调用的就是这个方法，最原生的读方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//wfd文件描述符，一般通过fs.open中获取</span></div><div class="line"><span class="comment">//buffer，要取数据的缓存源</span></div><div class="line"><span class="comment">//0，从buffer的0位置开始取</span></div><div class="line"><span class="comment">//BUFFER_SIZE，每次取BUFFER_SIZE这么长的长度</span></div><div class="line"><span class="comment">//index，每次写入文件的index的位置</span></div><div class="line"><span class="comment">//bytesRead，真实写入的个数</span></div><div class="line">fs.write(wfd,buffer,<span class="number">0</span>,bytesRead,index,<span class="function"><span class="keyword">function</span>(<span class="params">err,bytesWrite</span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="通过代码实现"><a href="#通过代码实现" class="headerlink" title="通过代码实现"></a>通过代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="comment">//只有第一次write的时候直接用_write写入文件 其余都是放到cache中 但是len超过了highWaterMark就会返回false告知需要drain 很占缓存</span></div><div class="line"><span class="comment">//从第一次的_write开始 回去一直通过clearBuffer递归_write写入文件 如果cache中没有了要写入的东西 会根据needDrain来判断是否触发干点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(path,options = &#123;&#125;)&#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.path = path</div><div class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span>*<span class="number">1024</span></div><div class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span></div><div class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span></div><div class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start</div><div class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="number">0o666</span></div><div class="line">    <span class="comment">//默认null就是buffer</span></div><div class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">//打开这个文件</span></div><div class="line">    <span class="keyword">this</span>.open()</div><div class="line"></div><div class="line">    <span class="comment">//写文件的时候需要哪些参数</span></div><div class="line">    <span class="comment">//第一次写入的时候 是给highWaterMark个馒头 他会硬着头皮写到文件中 之后才会把多余吃不下的放到缓存中</span></div><div class="line">    <span class="keyword">this</span>.writing = <span class="literal">false</span></div><div class="line">    <span class="comment">//缓存数组</span></div><div class="line">    <span class="keyword">this</span>.cache = []</div><div class="line">    <span class="keyword">this</span>.callbackList = []</div><div class="line">    <span class="comment">//数组长度</span></div><div class="line">    <span class="keyword">this</span>.len = <span class="number">0</span></div><div class="line">    <span class="comment">//是否触发drain事件</span></div><div class="line">    <span class="keyword">this</span>.needDrain = <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  clearBuffer()&#123;</div><div class="line">    <span class="comment">//取缓存中最上面的一个</span></div><div class="line">    <span class="keyword">let</span> buffer = <span class="keyword">this</span>.cache.shift()</div><div class="line">    <span class="keyword">if</span>(buffer)&#123;</div><div class="line">      <span class="comment">//有buffer的情况下</span></div><div class="line">      <span class="keyword">this</span>._write(buffer.chunk,buffer.encoding,()=&gt;<span class="keyword">this</span>.clearBuffer(),buffer.callback)</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">//没有的话 先看看需不需要drain</span></div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.needDrain)&#123;</div><div class="line">        <span class="comment">//触发drain 并初始化所有状态</span></div><div class="line">        <span class="keyword">this</span>.writing = <span class="literal">false</span></div><div class="line">        <span class="keyword">this</span>.needDrain = <span class="literal">false</span></div><div class="line">        <span class="keyword">this</span>.callbackList.shift()()</div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'drain'</span>)</div><div class="line">        </div><div class="line">      &#125;</div><div class="line">      <span class="keyword">this</span>.callbackList.map(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</div><div class="line">        v()</div><div class="line">      &#125;)</div><div class="line">      <span class="keyword">this</span>.callbackList.length = <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  _write(chunk,encoding,clearBuffer,callback)&#123;</div><div class="line">    <span class="comment">//因为write方法是同步调用的 所以可能还没获取到fd</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="comment">//直接在open的时间对象上注册一个一次性事件 当open被emit的时候会被调用</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>,()=&gt;<span class="keyword">this</span>._write(chunk,encoding,clearBuffer,callback))</div><div class="line">    &#125;</div><div class="line">    fs.write(<span class="keyword">this</span>.fd,chunk,<span class="number">0</span>,chunk.length,<span class="keyword">this</span>.pos,(err,byteWrite)=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.pos += byteWrite</div><div class="line">      <span class="comment">//每次写完 相应减少内存中的数量</span></div><div class="line">      <span class="keyword">this</span>.len -= byteWrite</div><div class="line">      <span class="keyword">if</span>(callback) <span class="keyword">this</span>.callbackList.push(callback)</div><div class="line">      <span class="comment">//第一次写完</span></div><div class="line">      clearBuffer()</div><div class="line">      </div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//写入方法</span></div><div class="line">  write(chunk,encoding=<span class="keyword">this</span>.encoding,callback)&#123;</div><div class="line">    <span class="comment">//判断chunk必须是字符串或者buffer 为了统一都变成buffer</span></div><div class="line">    chunk = Buffer.isBuffer(chunk)?chunk:Buffer.from(chunk,encoding)</div><div class="line">    <span class="comment">//维护缓存的长度 3</span></div><div class="line">    <span class="keyword">this</span>.len += chunk.length</div><div class="line">    <span class="keyword">let</span> ret = <span class="keyword">this</span>.len &lt; <span class="keyword">this</span>.highWaterMark</div><div class="line">    <span class="keyword">if</span>(!ret)&#123;</div><div class="line">      <span class="comment">//表示要触发drain事件</span></div><div class="line">      <span class="keyword">this</span>.needDrain = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//正在写入的应该放到内存中</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.writing)&#123;</div><div class="line">      <span class="keyword">this</span>.cache.push(&#123;</div><div class="line">        chunk,</div><div class="line">        encoding,</div><div class="line">        callback</div><div class="line">      &#125;)</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">//这里是第一次写的时候</span></div><div class="line">      <span class="keyword">this</span>.writing = <span class="literal">true</span></div><div class="line">      <span class="comment">//专门实现写的方法</span></div><div class="line">      <span class="keyword">this</span>._write(chunk,encoding,()=&gt;<span class="keyword">this</span>.clearBuffer(),callback)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// console.log(ret)</span></div><div class="line">    <span class="comment">//能不能继续写了 false代表下次写的时候更占内存</span></div><div class="line">    <span class="keyword">return</span> ret</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  destory()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果文件被打开过 就关闭文件并且触发close事件</span></div><div class="line">    fs.close(<span class="keyword">this</span>.fd,()=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  open()&#123;</div><div class="line">    <span class="comment">//fd表示的就是当前this.path的这个文件，从3开始(number类型)</span></div><div class="line">    fs.open(<span class="keyword">this</span>.path,<span class="keyword">this</span>.flags,(err,fd)=&gt;&#123;</div><div class="line">      <span class="comment">//有可能fd这个文件不存在 需要做处理</span></div><div class="line">      <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="comment">//如果有自动关闭 则帮他销毁</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autoClose)&#123;</div><div class="line">          <span class="comment">//销毁（关闭文件，出发关闭文件事件）</span></div><div class="line">          <span class="keyword">this</span>.destory()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有错误 就会触发error事件</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'error'</span>,err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//保存文件描述符</span></div><div class="line">      <span class="keyword">this</span>.fd = fd</div><div class="line">      <span class="comment">//当文件打开成功时触发open事件</span></div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自定义可写流"><a href="#自定义可写流" class="headerlink" title="自定义可写流"></a>自定义可写流</h3><p><strong>因为<code>createWriteStream</code>内部调用了<code>WriteStream</code>类，<code>WriteStream</code>又实现了<code>Writable</code>接口,<code>WriteStream</code>实现了<code>_write()</code>方法,所以我们通过自定义一个类继承<code>stream</code>模块的<code>Writable</code>，并在<code>原型</code>上自定义一个<code>_write()</code>就可以自定义自己的可写流</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; Writable &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWrite</span> <span class="keyword">extends</span> <span class="title">Writable</span></span>&#123;</div><div class="line">  _write(chunk,encoding,callback)&#123;</div><div class="line">    <span class="comment">//write()的第一个参数，写入的数据</span></div><div class="line">    <span class="built_in">console</span>.log(chunk)</div><div class="line">    <span class="comment">//这个callback，就相当于我们上面的clearBuffer方法，如果不执行callback就不会继续从缓存中取出写</span></div><div class="line">    callback()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> write = <span class="keyword">new</span> MyWrite()</div><div class="line">write.write(<span class="string">'1'</span>,<span class="string">'utf8'</span>,()=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><blockquote>
<p>管道流，是可读流上的方法，至于为什么放到这里，主要是因为需要2个流的基础知识，是可读流配合可写流的一种<code>传输方式</code>。如果用原来的读写，因为写比较<code>耗时</code>，所以会<code>多读少写</code>，<code>耗内存</code>，但用了<code>pipe</code>就不会了，始终用<code>规定</code>的内存。</p>
</blockquote>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="comment">//pipe方法叫管道 可以控制速率</span></div><div class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./d.txt'</span>,&#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">4</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">let</span> ws = fs.createWriteStream(<span class="string">'./e,txt'</span>,&#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">1</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">//会监听rs的on('data')将读取到的数据,通过ws.write的方法写入文件</span></div><div class="line"><span class="comment">//调用写的一个方法 返回boolean类型</span></div><div class="line"><span class="comment">//如果返回false就调用rs的pause方法 暂停读取</span></div><div class="line"><span class="comment">//等待可写流 写入完毕在监听drain resume rs</span></div><div class="line">rs.pipe(ws) <span class="comment">//会控制速率 防止淹没可用内存</span></div></pre></td></tr></table></figure>
<h3 id="自己实现一下"><a href="#自己实现一下" class="headerlink" title="自己实现一下"></a>自己实现一下</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="comment">//这两个是上面自己写的ReadStream和WriteStream</span></div><div class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>)</div><div class="line"><span class="keyword">let</span> WriteStream = <span class="built_in">require</span>(<span class="string">'./WriteStream'</span>)</div><div class="line"></div><div class="line"><span class="comment">//如果用原来的读写，因为写比较耗时，所以会多读少写，耗内存</span></div><div class="line">ReadStream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">'data'</span>,(data)=&gt;&#123;</div><div class="line">    <span class="keyword">let</span> flag = dest.write(data)</div><div class="line">    <span class="comment">//如果写入的时候嘴巴吃满了就不继续读了，暂停</span></div><div class="line">    <span class="keyword">if</span>(!flag)&#123;</div><div class="line">      <span class="keyword">this</span>.pause()</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="comment">//如果写的时候嘴巴里的吃完了，就会继续读</span></div><div class="line">  dest.on(<span class="string">'drain'</span>,()=&gt;&#123;</div><div class="line">    <span class="keyword">this</span>.resume()</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">'end'</span>,()=&gt;&#123;</div><div class="line">    <span class="keyword">this</span>.destory()</div><div class="line">    <span class="comment">//清空缓存中的数据</span></div><div class="line">    fs.fsync(dest.fd,()=&gt;&#123;</div><div class="line">      dest.destory()</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="双工流"><a href="#双工流" class="headerlink" title="双工流"></a>双工流</h2><blockquote>
<p>有了双工流，我们可以在同一个对象上<code>同时实现可读和可写</code>，就好像同时继承这两个接口。 重要的是双工流的可读性和可写性操作<code>完全独立</code>于彼此。这仅仅是将两个特性组合成一个对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; Duplex &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>)</div><div class="line"><span class="comment">//双工流，可读可写</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDuplex</span> <span class="keyword">extends</span> <span class="title">Duplex</span></span>&#123;</div><div class="line">  _read()&#123;</div><div class="line">    <span class="keyword">this</span>.push(<span class="string">'hello'</span>)</div><div class="line">    <span class="keyword">this</span>.push(<span class="literal">null</span>)</div><div class="line">  &#125;</div><div class="line">  _write(chunk,encoding,clearBuffer)&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk)</div><div class="line">    clearBuffer()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myDuplex = <span class="keyword">new</span> MyDuplex()</div><div class="line"><span class="comment">//process.stdin是node自带的process进程中的可读流，会监听命令行的输入</span></div><div class="line"><span class="comment">//process.stdout是node自带的process进程中的可写流，会监听并输出在命令行中</span></div><div class="line"><span class="comment">//所以这里的意思就是在命令行先输出hello，然后我们输入什么他就出来对应的buffer(先作为可读流出来)</span></div><div class="line">process.stdin.pipe(myDuplex).pipe(process.stdout)</div></pre></td></tr></table></figure>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><blockquote>
<p>转换流的输出是从输入中<code>计算</code>出来的。对于转换流，我们不必实现<code>read</code>或<code>write</code>的方法，我们只需要实现一个<code>transform</code>方法，将两者结合起来。它有<code>write</code>方法的意思，我们也可以用它来<code>push</code>数据。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; Transform &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span></span>&#123;</div><div class="line">  _transform(chunk,encoding,callback)&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk.toString().toUpperCase())</div><div class="line">    callback()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> myTransform = <span class="keyword">new</span> MyTransform()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform2</span> <span class="keyword">extends</span> <span class="title">Transform</span></span>&#123;</div><div class="line">  _transform(chunk,encoding,callback)&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk.toString().toUpperCase())</div><div class="line">    <span class="keyword">this</span>.push(<span class="string">'1'</span>)</div><div class="line">    <span class="comment">// this.push(null)</span></div><div class="line">    callback()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> myTransform2 = <span class="keyword">new</span> MyTransform2()</div><div class="line"></div><div class="line"><span class="comment">//此时myTransform2被作为可写流触发_transform，输出输入的大写字符后，会通过可读流push字符到下一个转换流中</span></div><div class="line"><span class="comment">//当写入的时候才会触发transform的值，此时才会push，所以后面的pipe拿到的chunk是前面的push的值</span></div><div class="line">process.stdin.pipe(myTransform2).pipe(myTransform)</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="可读流-1"><a href="#可读流-1" class="headerlink" title="可读流"></a>可读流</h3><ul>
<li>在 flowing 模式下， 可读流自动从系统底层读取数据，并通过 EventEmitter 接口的事件尽快将数据提供给应用。</li>
<li>在 paused 模式下，必须显式调用 stream.read() 方法来从流中读取数据片段。</li>
<li>所有初始工作模式为 paused 的 Readable 流，可以通过下面三种途径切换到 flowing 模式：<ul>
<li>监听 ‘data’ 事件</li>
<li>调用 stream.resume() 方法</li>
<li>调用 stream.pipe() 方法将数据发送到 Writable</li>
</ul>
</li>
<li>可读流可以通过下面途径切换到 paused 模式：<ul>
<li>如果不存在管道目标（pipe destination），可以通过调用 stream.pause() 方法实现。</li>
<li>如果存在管道目标，可以通过取消 ‘data’ 事件监听，并调用 stream.unpipe() 方法移除所有管道目标来实现。</li>
</ul>
</li>
</ul>
<h3 id="可写流-1"><a href="#可写流-1" class="headerlink" title="可写流"></a>可写流</h3><ul>
<li>需要知道只有在<code>嘴</code>真正的吃满了，并且等到把嘴里的和地上的馒头(缓存中的)都吃下了才会触发<code>drain</code>事件</li>
<li>第一次写入会直接写入文件中，后面会从缓存中一个个取</li>
</ul>
<h3 id="双工流-1"><a href="#双工流-1" class="headerlink" title="双工流"></a>双工流</h3><ul>
<li>只是对可写可读流的一种应用，既可作为可读流，也能作为可写流，并且作为可读或者可写时时<code>隔离</code>的</li>
</ul>
<h3 id="转换流-1"><a href="#转换流-1" class="headerlink" title="转换流"></a>转换流</h3><ul>
<li>一般转换流是边输入边输出的，而且一般只有触发了写入操作时才会进入<code>_transform</code>方法中。跟双工流的区别就是，他的可读可写是在<code>一起</code>的。</li>
</ul>
<p><strong>OK,讲完收工，从此你就是<code>流</code>魔王</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/13/164920c158bb431a?w=198&amp;h=130&amp;f=jpeg&amp;s=7736" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/">node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stream/">stream</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/流/">流</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数组的扩展" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/21/数组的扩展/" class="article-date">
  	<time datetime="2018-03-21T07:42:40.000Z" itemprop="datePublished">2018-03-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/21/数组的扩展/">数组的扩展</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>扩展运算符<br>    扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。<br>替代函数的 apply 方法<br>    由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。<br>扩展运算符的应用<br>    （1）复制数组<br>        数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。<br>        const a1 = [1, 2];<br>        // 写法一<br>        const a2 = […a1];<br>        // 写法二<br>        const […a2] = a1;<br>    （2）合并数组<br>    （3）与解构赋值结合（如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。）<br>        const [first, …rest] = [1, 2, 3, 4, 5];<br>        first // 1<br>        rest  // [2, 3, 4, 5]</p>
<pre><code>    const [first, ...rest] = [];
    first // undefined
    rest  // []

    const [first, ...rest] = [&quot;foo&quot;];
    first  // &quot;foo&quot;
    rest   // []
（4）字符串
    扩展运算符还可以将字符串转为真正的数组。
    [...&apos;hello&apos;]
（5）实现了 Iterator 接口的对象
    任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。
（6）Map 和 Set 结构，Generator 函数
    扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。
</code></pre><p>Array.from<br>    Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）<br>    Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。<br>        Array.from(arrayLike, x =&gt; x <em> x);<br>        // 等同于<br>        Array.from(arrayLike).map(x =&gt; x </em> x);</p>
<pre><code>    Array.from([1, 2, 3], (x) =&gt; x * x)
    // [1, 4, 9]
如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。
</code></pre><p>Array.of<br>    Array.of方法用于将一组值，转换为数组。<br>数组实例的 copyWithin()<br>    数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。<br>    target（必需）：从该位置开始替换数据。如果为负值，表示倒数。<br>    start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。<br>    end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br>数组实例的 find() 和 findIndex()<br>    数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。<br>    find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。<br>    数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。<br>数组实例的 fill()<br>    fill方法使用给定值，填充一个数组。<br>    fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。<br>    注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。<br>    let arr = new Array(3).fill({name: “Mike”});<br>    arr[0].name = “Ben”;<br>    arr<br>    // [{name: “Ben”}, {name: “Ben”}, {name: “Ben”}]</p>
<pre><code>let arr = new Array(3).fill([]);
arr[0].push(5);
arr
// [[5], [5], [5]]
</code></pre><p>数组实例的 entries()，keys() 和 values()<br>    ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。<br>数组实例的 includes()<br>    Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。<br>数组的空位<br>    ES6会处理空位</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js基础/">js基础</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>