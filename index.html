<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.25px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 13.75px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 16.25px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.25px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 18.75px;">Objective-C</a> <a href="/tags/ReactiveCocoa/" style="font-size: 12.5px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/Sublime-Text/" style="font-size: 11.25px;">Sublime Text</a> <a href="/tags/Tools/" style="font-size: 13.75px;">Tools</a> <a href="/tags/Transition/" style="font-size: 12.5px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 17.5px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js基础/" style="font-size: 20px;">js基础</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，Android开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-对象的扩展" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/12/对象的扩展/" class="article-date">
  	<time datetime="2018-03-12T15:21:40.000Z" itemprop="datePublished">2018-03-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/12/对象的扩展/">对象的扩展</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>属性的简洁表示法<br>属性名表达式<br>方法的 name 属性<br>Object.is()<br>    ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。<br>    不同之处只有两个：一是+0不等于-0，二是NaN等于自身。<br>Object.assign()<br>    Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。<br>    注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。<br>    1.浅拷贝<br>        Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。<br>    2.同名属性的处理<br>    3.数组处理<br>    4.取值函数get的处理<br>属性的可枚举性和遍历<br>    对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。<br>    属性的遍历<br>    ES6 一共有 5 种方法可以遍历对象的属性。</p>
<pre><code>（1）for...in

for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

（2）Object.keys(obj)

Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

（3）Object.getOwnPropertyNames(obj)

Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。

（4）Object.getOwnPropertySymbols(obj)

Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。

（5）Reflect.ownKeys(obj)

Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

首先遍历所有数值键，按照数值升序排列。
其次遍历所有字符串键，按照加入时间升序排列。
最后遍历所有 Symbol 键，按照加入时间升序排列。
</code></pre><p>Object.getOwnPropertyDescriptors()<br>    前面说过，Object.getOwnPropertyDescriptor方法会返回某个对象属性的描述对象（descriptor），参数分别是要查找的对象和要检索的属性名。ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。<br><strong>proto</strong>属性，Object.setPrototypeOf()，Object.getPrototypeOf()<br>super 关键字<br>    我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。<br>Object.keys()，Object.values()，Object.entries()<br>    let {keys, values, entries} = Object;<br>    let obj = { a: 1, b: 2, c: 3 };</p>
<pre><code>for (let key of keys(obj)) {
console.log(key); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;
}

for (let value of values(obj)) {
console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
console.log([key, value]); // [&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]
}
Object.values会过滤属性名为 Symbol 值的属性。
</code></pre><p>对象的扩展运算符<br>    拷贝<br>        // 写法一<br>    const clone1 = {<br>    <strong>proto</strong>: Object.getPrototypeOf(obj),<br>    …obj<br>    };</p>
<pre><code>// 写法二
const clone2 = Object.assign(
Object.create(Object.getPrototypeOf(obj)),
obj
);

// 写法三
const clone3 = Object.create(
Object.getPrototypeOf(obj),
Object.getOwnPropertyDescriptors(obj)
)
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js基础/">js基础</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-class" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/12/class/" class="article-date">
  	<time datetime="2018-03-12T15:21:40.000Z" itemprop="datePublished">2018-03-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/12/class/">class</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>简介<br>    由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。<br>    另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。<br>严格模式<br>    类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。<br>constructor 方法<br>    constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。<br>    constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。<br>类的实例对象<br>    必须new<br>    与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。<br>    可以通过实例的<strong>proto</strong>属性为“类”添加方法。但是所添加的所有方法都会给所有被实例对象使用<br>Class 表达式<br>    与函数一样，类也可以写成表达式<br>        const MyClass = class Me {<br>            getClassName() {<br>                return Me.name;<br>            }<br>        };<br>        上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。<br>    如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。<br>        const MyClass = class { /<em> … </em>/ };<br>    用Class表达式，可以写出立即执行的class<br>        let person = new class {<br>            constructor(name) {<br>                this.name = name;<br>            }</p>
<pre><code>    sayName() {
        console.log(this.name);
    }
}(&apos;张三&apos;);

person.sayName(); // &quot;张三&quot;
</code></pre><p>不存在变量提升<br>私有方法和私有属性<br>    一种是通过把私有方法写在类外面，通过call(this)调用。<br>    另一种是通过symbol来私有化变量，在通过变量来调用方法和属性变量<br>        const bar = Symbol(‘bar’);<br>        const snaf = Symbol(‘snaf’);</p>
<pre><code>    export default class myClass{

        // 公有方法
        foo(baz) {
            this[bar](baz);
        }

        // 私有方法
        [bar](baz) {
            return this[snaf] = baz;
        }

        // ...
    };
私有属性和私有方法在前面家#
</code></pre><p>this 的指向<br>    class test {<br>        constructor(){<br>            //为了printName被分离出去后也能被调用，this指向还是test<br>            this.printName = this.printName.bind(this);<br>        }<br>    }<br>    如果是箭头函数的话，this就是指向声明时的this<br>    还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。<br>name 属性<br>    由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。<br>Class 的取值函数（getter）和存值函数（setter）<br>    都是被默认添加到了描述对象prototypedescription上<br>Class 的 Generator 方法<br>    前面加个*<br>Class 的静态方法<br>    类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。<br>    注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。静态方法可以和普通方法重名<br>    父类的静态方法可以被继承<br>Class 的静态属性和实例属性<br>    可在类里直接定义实例属性<br>    静态属性直接在前面加个static<br>new.target 属性<br>    new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。<br>    class类中调用new.target返回当前class，在子类中调用则父类也返回子类的class<br>    利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。<br>        class Shape {<br>            constructor() {<br>                if (new.target === Shape) {<br>                throw new Error(‘本类不能实例化’);<br>                }<br>            }<br>        }</p>
<pre><code>class Rectangle extends Shape {
    constructor(length, width) {
        super();
        // ...
    }
}

var x = new Shape();  // 报错
var y = new Rectangle(3, 4);  // 正确
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js基础/">js基础</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-函数的扩展" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/10/函数的扩展/" class="article-date">
  	<time datetime="2018-03-10T15:27:40.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/函数的扩展/">函数的扩展</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><ul>
<li><p>1.函数参数的默认值</p>
<blockquote>
<ul>
<li>参数变量是默认声明的，所以不能用let或const再次声明。</li>
<li>使用参数默认值时，函数不能有同名参数。</li>
<li>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</li>
</ul>
</blockquote>
</li>
<li><p>2.函数参数默认值的位置</p>
<blockquote>
<ul>
<li>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</li>
</ul>
</blockquote>
</li>
<li><p>3.函数的 length 属性</p>
<blockquote>
<ul>
<li>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</li>
<li>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</li>
</ul>
</blockquote>
</li>
<li><p>4.作用域</p>
<blockquote>
<ul>
<li>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</li>
</ul>
</blockquote>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(y);</div><div class="line">&#125;</div><div class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>  <strong>上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。</strong></p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</div><div class="line">            <span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line">            y();</div><div class="line">            <span class="built_in">console</span>.log(x);</div><div class="line">        &#125;</div><div class="line">        foo() <span class="comment">// 3</span></div><div class="line">        x <span class="comment">// 1 </span></div><div class="line">    <span class="string">``</span><span class="string">`  </span></div><div class="line"></div><div class="line">    **上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。**</div><div class="line"></div><div class="line">* 5.使用</div><div class="line">    &gt;* 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</div><div class="line"></div><div class="line">    `<span class="string">``</span>js</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing(</span>)) </span>&#123;</div><div class="line">            <span class="keyword">return</span> mustBeProvided;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        foo()</div><div class="line">        <span class="comment">// Error: Missing parameter</span></div></pre></td></tr></table></figure>
</li>
<li><p>6.rest 参数</p>
<blockquote>
<ul>
<li>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</li>
<li>函数的length属性，不包括 rest 参数。</li>
</ul>
</blockquote>
</li>
<li>7.严格模式<blockquote>
<ul>
<li>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</li>
</ul>
</blockquote>
</li>
<li>8.name 属性<blockquote>
<ul>
<li>函数的name属性，返回该函数的函数名。</li>
<li>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。</li>
<li>Function构造函数返回的函数实例，name属性的值为anonymous。</li>
<li>bind返回的函数，name属性值会加上bound前缀。</li>
</ul>
</blockquote>
</li>
<li>9.箭头函数<blockquote>
<ul>
<li>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</li>
<li>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。<br>双冒号运算符</li>
<li>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</li>
</ul>
</blockquote>
</li>
<li><p>10.尾调用优化</p>
<blockquote>
<ul>
<li>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</li>
<li>优化,我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</li>
<li>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</li>
<li>尾递归</li>
<li>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。<pre><code>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span> (<span class="params">n , ac1 = <span class="number">1</span> , ac2 = <span class="number">1</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> ac2&#125;;</div><div class="line">    <span class="keyword">return</span> Fibonacci2 (n - <span class="number">1</span>, ac2, ac1 + ac2);</div><div class="line">&#125;</div><div class="line">Fibonacci2(<span class="number">100</span>) <span class="comment">// 573147844013817200000</span></div><div class="line">Fibonacci2(<span class="number">1000</span>) <span class="comment">// 7.0330367711422765e+208</span></div><div class="line">Fibonacci2(<span class="number">10000</span>) <span class="comment">// Infinity</span></div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
<li><p>10.函数参数的尾逗号</p>
<blockquote>
<ul>
<li>ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。</li>
</ul>
</blockquote>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js基础/">js基础</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数值的扩展" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/10/数值的扩展/" class="article-date">
  	<time datetime="2018-03-10T15:15:40.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/数值的扩展/">数值的扩展</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><ul>
<li>1.二进制和八进制表示法<blockquote>
<ul>
<li>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</li>
</ul>
</blockquote>
</li>
<li>2.Number.isFinite(), Number.isNaN()<blockquote>
<ul>
<li>Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。注意，如果参数类型不是数值，Number.isFinite一律返回false。</li>
<li>Number.isNaN()用来检查一个值是否为NaN。注意，如果参数类型不是数值，Number.isNaN一律返回false。</li>
<li>Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。</li>
</ul>
</blockquote>
</li>
<li>3.Number.parseInt(), Number.parseFloat()<blockquote>
<ul>
<li>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</li>
</ul>
</blockquote>
</li>
<li>4.Number.isInteger()<blockquote>
<ul>
<li>Number.isInteger()用来判断一个数值是否为整数。</li>
</ul>
</blockquote>
</li>
<li><p>5.Number.EPSILON</p>
<blockquote>
<ul>
<li>Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">withinErrorMargin</span> (<span class="params">left, right</span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left - right) &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
<li><p>6.安全整数和 Number.isSafeInteger()</p>
<blockquote>
<ul>
<li>JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。</li>
<li>ES6 引入了Number.MAX_SAFE_INTEGER和* 7.Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</li>
</ul>
</blockquote>
</li>
<li><p>8.Math 对象的扩展</p>
<blockquote>
<ul>
<li>Math.trunc()返回去除小数点后的数</li>
<li>Math.sign()判断正数还是负数</li>
<li>Math.cbrt()立方根</li>
<li>Math.clz32()JavaScript 的整数使用 32 位二进制形式表示，Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0。</li>
<li>Math.imul()方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</li>
<li>Math.fround()方法返回一个数的32位单精度浮点数形式。</li>
<li>Math.hypot()方法返回所有参数的平方和的平方根</li>
</ul>
</blockquote>
</li>
<li><p>9.指数运算符</p>
<blockquote>
<p>** </p>
</blockquote>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js基础/">js基础</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-字符串扩展" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/09/字符串扩展/" class="article-date">
  	<time datetime="2018-03-09T14:51:40.000Z" itemprop="datePublished">2018-03-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/09/字符串扩展/">字符串扩展</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h2><ul>
<li>1.字符的 Unicode 表示法<blockquote>
<ul>
<li>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</li>
</ul>
</blockquote>
</li>
<li>2.codePointAt()<blockquote>
<ul>
<li>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。</li>
<li>ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</li>
</ul>
</blockquote>
</li>
<li>3.String.fromCodePoint()<blockquote>
<ul>
<li>ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）</li>
<li>ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。<br>字符串的遍历器接口</li>
<li>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for…of循环遍历。</li>
<li>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</li>
</ul>
</blockquote>
</li>
<li>4.at()<blockquote>
<ul>
<li>ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。</li>
<li>目前，有一个提案，提出字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符。</li>
</ul>
</blockquote>
</li>
<li>5.normalize()<blockquote>
<ul>
<li>ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</li>
</ul>
</blockquote>
</li>
<li>6.includes(), startsWith(), endsWith()（2个参数，第一个字符串，第二个第几位开始）<blockquote>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
</blockquote>
</li>
<li>7.repeat()（参数是数字）<blockquote>
<ul>
<li>repeat方法返回一个新字符串，表示将原字符串重复n次。<br>padStart()，padEnd()（第一个参数是字符串长度，第二个参数是要循环的字符串）</li>
<li>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</li>
</ul>
</blockquote>
</li>
<li>8.matchAll()<blockquote>
<ul>
<li>matchAll方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。<br>模板字符串（可以保留标签或者变量值）</li>
<li>` 会保留空格 ${(放入变量，甚至js代码)}</li>
</ul>
</blockquote>
</li>
<li>9.实例：模板编译</li>
<li>10.标签模板</li>
<li>11.String.raw()<blockquote>
<ul>
<li>String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。<br>模板字符串的限制</li>
</ul>
</blockquote>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js基础/">js基础</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>