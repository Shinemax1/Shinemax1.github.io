<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Robot Dog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SSS">
<meta property="og:type" content="website">
<meta property="og:title" content="Robot Dog">
<meta property="og:url" content="http://shinemax1.github.io/index.html">
<meta property="og:site_name" content="Robot Dog">
<meta property="og:description" content="SSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robot Dog">
<meta name="twitter:description" content="SSS">
  
    <link rel="alternative" href="/atom.xml" title="Robot Dog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/favicon.jpg" class="js-avatar">
			
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">陈旭锋</a></h1>
		</hgroup>

		
		<p class="header-subtitle">shinemax</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/Android/">Android相关</a></li>
				        
							<li><a href="/categories/iOS/">iOS相关</a></li>
				        
							<li><a href="/categories/web/">前端相关</a></li>
				        
							<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
				        
							<li><a href="/categories/Others/">其它相关</a></li>
				        
							<li><a href="/categories/blog/">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AFNetworking/" style="font-size: 11.25px;">AFNetworking</a> <a href="/tags/Animation/" style="font-size: 13.75px;">Animation</a> <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/CommonJS/" style="font-size: 10px;">CommonJS</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/GCD/" style="font-size: 16.25px;">GCD</a> <a href="/tags/Git/" style="font-size: 11.25px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/IP/" style="font-size: 10px;">IP</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/OSI/" style="font-size: 10px;">OSI</a> <a href="/tags/Objective-C/" style="font-size: 17.5px;">Objective-C</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/ReactiveCocoa/" style="font-size: 12.5px;">ReactiveCocoa</a> <a href="/tags/Resources/" style="font-size: 10px;">Resources</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/SSR/" style="font-size: 10px;">SSR</a> <a href="/tags/Sublime-Text/" style="font-size: 11.25px;">Sublime Text</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Tools/" style="font-size: 13.75px;">Tools</a> <a href="/tags/Transition/" style="font-size: 12.5px;">Transition</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/UIWebView/" style="font-size: 10px;">UIWebView</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/es6/" style="font-size: 18.75px;">es6</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/js/" style="font-size: 11.25px;">js</a> <a href="/tags/js基础/" style="font-size: 20px;">js基础</a> <a href="/tags/node-js/" style="font-size: 11.25px;">node.js</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/事件环/" style="font-size: 10px;">事件环</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/前端日记/" style="font-size: 10px;">前端日记</a> <a href="/tags/千字文/" style="font-size: 10px;">千字文</a> <a href="/tags/宏任务/" style="font-size: 10px;">宏任务</a> <a href="/tags/微任务/" style="font-size: 10px;">微任务</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/模块化/" style="font-size: 11.25px;">模块化</a> <a href="/tags/流/" style="font-size: 10px;">流</a> <a href="/tags/知识管理/" style="font-size: 10px;">知识管理</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/面试/" style="font-size: 11.25px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">男，95年生人，全栈开发工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈旭锋</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">陈旭锋</h1>
			</hgroup>
			
			<p class="header-subtitle">shinemax</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/Android/">Android相关</a></li>
		        
					<li><a href="/categories/iOS/">iOS相关</a></li>
		        
					<li><a href="/categories/web/">前端相关</a></li>
		        
					<li><a href="/categories/Objective-C/">Objective-C相关</a></li>
		        
					<li><a href="/categories/Others/">其它相关</a></li>
		        
					<li><a href="/categories/blog/">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shinemax1" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Themas" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:510360345@qq.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-TCP:IP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/15/TCP:IP/" class="article-date">
  	<time datetime="2018-08-15T03:25:40.000Z" itemprop="datePublished">2018-08-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/15/TCP:IP/">前端进阶必须懂得TCP/IP</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="TCP-IP四层协议"><a href="#TCP-IP四层协议" class="headerlink" title="TCP/IP四层协议"></a>TCP/IP四层协议</h1><blockquote>
<p>一往无前虎山行，拨开云雾见光明。梦里花落牡丹亭，幻想成真歌舞升平。 —— Gai</p>
</blockquote>
<h2 id="计算机网络的结构分层"><a href="#计算机网络的结构分层" class="headerlink" title="计算机网络的结构分层"></a>计算机网络的结构分层</h2><table style="text-align:center"><br>    <tr><br>        <td>OSI七层模型</td><br>        <td>TCP/IP协议族层次 </td><br>        <td>功能</td><br>        <td>TCP/IP协议族 </td><br>   </tr><br>    <tr><br>        <td>应用层</td><br>        <td rowspan="3">应用层</td><br>        <td>电子邮件、远程传输、文件传输</td><br>        <td>TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</td><br>    </tr><br>    <tr><br>        <td>表示层</td><br>        <td>数据格式化、代码转换、数据加密</td><br>        <td>没有协议</td><br>    </tr><br>    <tr><br>        <td>会话层</td><br>        <td>解除或建立别的节点的联系</td><br>        <td>没有协议</td><br>    </tr><br>    <tr><br>        <td>传输层</td><br>        <td>传输层</td><br>        <td>提供端对端的接口，处理端到端的通信细节</td><br>        <td>TCP，UDP</td><br>    </tr><br>    <tr><br>        <td>网络层</td><br>        <td>网络层</td><br>        <td>数据在网络中分组传输，网络层处理分组在网络中的活动</td><br>        <td>IP，ICMP，RIP，OSPF，BGP，IGMP</td><br>    </tr><br>    <tr><br>        <td>数据链路层</td><br>        <td rowspan="2">链路层</td><br>        <td>传输有地址的帧和错误检测功能</td><br>        <td>SLIP，CSLIP，PPP，ARP，RARP，MTU</td><br>    </tr><br>    <tr><br>        <td>物理层</td><br>        <td>以二进制数据形式在物理媒体上传输数据</td><br>        <td>ISO2110，IEEE802，IEEE802.2</td><br>    </tr><br></table>

<ul>
<li>物理层，相当于是那些物流公司里的<code>送货汽车</code>。</li>
<li>数据链路层，可以看作是物流公司的<code>司机</code>，他们驾驶着汽车，将打包好的货物（数据帧）从一个城市（物理节点）运输到另一个城市。</li>
<li>网络层，这好比是物流公司的路线规划者。物流公司有很多集散中心，根据集散中心的情况（是否拥堵），找出一条经过n个集散中心的路径将货物（数据）沿路运过去。</li>
<li>传输层，可以将其看作是物流公司的<code>跟单员</code>。负责任的跟单员<code>（使用 TCP 协议）</code>会保证<code>数据</code>送到客户手上，如果送不到<code>（需要三次握手，四次挥手）</code>就让公司再发一次。不负责任的跟单员<code>（使用 UDP 协议）</code>层只管将快递送到客户指定的地方，不管快递是否送到客户手上。</li>
<li>会话层，可看作是物流公司的<code>调度员</code>。他管理着这次物流的相关的信息。例如这次客户要发很多数据，发到哪，到底是一车一车发、还是用轮船一次运过去。这些都是他的职责。而运完之后，相关信息（连接）也可以被销毁了，这也是调度员的职责。</li>
<li>表示层，相当于物流公司的<code>打包员</code>。如果快递（数据）太臃肿，他会在不破坏快递的情况下压扁（压缩）它。如果客户注重安全线，全能的快递公司还能用密码箱（ SSL/TLS）打包快递再快送。当然，打包员会确定，目的地快递站的拆包员，能无损地拆开包裹，将快递交给用户。</li>
<li>应用层，可以想象成物流公司的<code>收件员</code>，当客户（应用）打电话（发起请求）给收件员（应用层）时，收件员可以根据用户的不同需求提供不同的服务（不同协议），比如隔天送达、指定时间送达等等。</li>
</ul>
<h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><ul>
<li>用<code>TCP/IP</code>从上往下走的时候，会分层的传输进行通讯。</li>
<li>发送端是从<code>应用层</code>到<code>链路层</code>，接收端是从<code>链路层</code>往上到<code>应用层</code>取数据。</li>
<li>其中通过各种首部的包装来让相应的层进行<code>识别</code>。</li>
<li>这里我拿了网上copy的一张通用的图来看一下。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/8/1651879f7424b01b?w=639&amp;h=581&amp;f=png&amp;s=264685" alt=""></p>
<ul>
<li><strong>每层协议需要实现的功能：</strong><ul>
<li>将上层协议传递的<code>数据包</code>包装为满足该层协议的<code>数据包</code></li>
<li>将下层协议传递的<code>数据包</code>解析为满足上层协议的<code>数据包</code></li>
<li>处理其他层的交互</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/8/16519c25300e4263?w=940&amp;h=944&amp;f=jpeg&amp;s=93646" alt=""></p>
<ul>
<li><strong>这和上图要表达的意思差不多，需要注意的是</strong><ul>
<li>从底往上传的<code>二进制包</code>，只要该层能处理就<code>不需要</code>按照严格意义上的分层解析</li>
<li>比如说，网络层往上传<code>二进制包</code>的时候，你可以在传输层包一层<code>tcp头</code>，也可以不包，直接交给应用层解析</li>
</ul>
</li>
</ul>
<h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><h3 id="帧、数据包、段、消息（传输数据单位）"><a href="#帧、数据包、段、消息（传输数据单位）" class="headerlink" title="帧、数据包、段、消息（传输数据单位）"></a>帧、数据包、段、消息（传输数据单位）</h3><ul>
<li>帧：用于表示数据链路层中包的单位；</li>
<li>数据包： IP 和 UDP 等网络层以上的分层中包的单位；</li>
<li>段：表示 TCP 数据流中的信息；</li>
<li>消息：指应用协议中数据的单位。</li>
</ul>
<h3 id="数据在每个分层中的体现"><a href="#数据在每个分层中的体现" class="headerlink" title="数据在每个分层中的体现"></a>数据在每个分层中的体现</h3><ul>
<li>每个分层中，都会对所发送的数据附加一个<code>首部</code>。</li>
<li>在这个<code>首部</code>中包含了该层必要的信息，如发送的目标地址以及协议相关信息。</li>
<li>通常，为协议提供的信息为包<code>首部</code>，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/8/16519ce6e380a5a8?w=560&amp;h=503&amp;f=png&amp;s=18872" alt=""></p>
<p><strong>在上面我们就能直观地看到，每一层的数据之外，其实包了很多层协议的首部</strong></p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="探究：数据链路层到底干了什么？"><a href="#探究：数据链路层到底干了什么？" class="headerlink" title="探究：数据链路层到底干了什么？"></a>探究：数据链路层到底干了什么？</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/8/16519d7d1dcd5de7?w=533&amp;h=427&amp;f=jpeg&amp;s=31970" alt=""></p>
<ul>
<li><strong>主要是做了接受IP数据报，并发送IP数据报至IP模块</strong></li>
<li><strong>与ARP及RARP模块交互</strong></li>
<li><strong>它的结构可以分为如下</strong><ul>
<li>业务区：最底下的那些物理机构成的区域，是物理层流出的起点。</li>
<li>接入层：业务区往上的千兆交换机，这里的物流机如果想互相通信，就必须通过这个交换机。</li>
<li>核心交换机：由一组千兆交换机组成。</li>
<li>IDC路由骨干：路由器组成。</li>
</ul>
</li>
</ul>
<h3 id="Wireshark抓包，看看数据链路层在传输时变成了什么？"><a href="#Wireshark抓包，看看数据链路层在传输时变成了什么？" class="headerlink" title="Wireshark抓包，看看数据链路层在传输时变成了什么？"></a>Wireshark抓包，看看数据链路层在传输时变成了什么？</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/8/1651a307aa520dfe?w=2066&amp;h=728&amp;f=jpeg&amp;s=509288" alt=""></p>
<ul>
<li>首先这个是<code>Wireshark</code>给我们解析出来的TCP/IP协议族的四层。</li>
<li>从上至下，分别是<code>链路</code>、<code>网络</code>、<code>传输</code>、<code>应用</code></li>
<li>我们着重看链路层，因为链路层在网络层之下，此时的地址都为硬件地址。</li>
<li>只有通过<code>硬件地址</code>，物理层才能将数据包通过路由传至目标地址。</li>
<li>这里就会有一个问题：<code>怎么通过IP地址去获取硬件地址呢？</code></li>
</ul>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ul>
<li>将32bit的IP地址，转换为48bit的以太网地址。</li>
<li>发送ARP广播，获得目的端的IP地址和硬件地址。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/9/1651d81d0c55eff9?w=772&amp;h=544&amp;f=jpeg&amp;s=61278" alt=""></p>
<h4 id="要注意的问题"><a href="#要注意的问题" class="headerlink" title="要注意的问题"></a>要注意的问题</h4><ul>
<li>访问不存在的主机地址超过时间一般为<code>75s</code>，这个时间其实一般就是<code>TCP连接</code>请求的超时时间。</li>
<li>如果<code>ARP</code>回答未返回，那么任何<code>TCP</code>报文段都不会发送。</li>
</ul>
<h4 id="如何捕获ARP数据？"><a href="#如何捕获ARP数据？" class="headerlink" title="如何捕获ARP数据？"></a>如何捕获ARP数据？</h4><ul>
<li><strong>telnet</strong></li>
<li><strong>tcpdump（相当于无界面的Wireshark）</strong></li>
<li><strong>命令：</strong><ul>
<li>arp -a：查看arp<code>高速缓存</code>。（每个已经找到的mac地址都会在arp中<code>缓存</code>）</li>
<li>tcpdump -i 网络接口arp：监听网络接口的<code>ARP</code>。</li>
<li>tcpdump -D：查看可监听的网络接口。</li>
</ul>
</li>
</ul>
<h4 id="MTU是什么？"><a href="#MTU是什么？" class="headerlink" title="MTU是什么？"></a>MTU是什么？</h4><p><strong>最大传输单元。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/9/1651da99df92d2b8?w=531&amp;h=167&amp;f=png&amp;s=35130" alt=""></p>
<ul>
<li>IPMTU就是最大的<code>传输单元</code>。</li>
<li>每个路由都会有一个规定的<code>MTU大小</code>。</li>
<li>如果我们传送的IP数据包大于这个<code>MTU</code>，就会<code>漏传</code>。</li>
<li>需要遵循<code>短板原理</code>,根据最小的<code>MTU</code>来设置IP数据包大小。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>主要就是通过发送端的<code>IP地址</code>，在内网（局域网）中通过<code>广播</code>的方式，去询问对应IP的<code>以太网地址</code>。</li>
<li>如果访问不到，超过<code>75s</code>，就不会继续<code>广播</code>。</li>
<li><code>MTU</code>控制我们传输的大小。</li>
<li>如果我们访问的不是<code>局域网</code>，属于<code>公网</code>，那么我们还通过ARP来寻找<code>mac地址</code>吗？如果是这样，那么我们将会给每个<code>公网</code>发送一个<code>广播</code>，那得有多<code>恐怖</code>，所以ARP只存在<code>局域网</code>。</li>
<li>上面这种情况，我们先通过<code>DNS解析</code>得到对应的<code>网络IP地址</code>，再通过找上层的<code>路由</code>去寻找，此时路由发现不是<code>局域网</code>，将会在往上寻找<code>ISP(Internet Service Provider)</code>，最后找到对应的<code>mac地址</code>。</li>
</ul>
<h2 id="网络层（IP协议）"><a href="#网络层（IP协议）" class="headerlink" title="网络层（IP协议）"></a>网络层（IP协议）</h2><blockquote>
<p>上面说到的路由，和它息息相关的就是我们的网络层，最为<code>核心</code>的一层。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/9/1651df4d7bbd6c69?w=640&amp;h=416&amp;f=png&amp;s=55583" alt=""></p>
<h3 id="协议组成（必须严格遵守顺序）"><a href="#协议组成（必须严格遵守顺序）" class="headerlink" title="协议组成（必须严格遵守顺序）"></a>协议组成（必须严格遵守顺序）</h3><ul>
<li>版本：4位</li>
<li>首部长度：4位，⚠️注意，这里的每1位表示<code>10进制x4个字节的数目</code>。因为4位最大的个数为1111，即15，所以首部最长为15x4,<code>60字节</code>。</li>
<li>服务类型：8位，大部分实现不支持，<code>无需关注</code>。</li>
<li>总长度：16位，所以最大的IP包为<code>65536</code>。</li>
<li>标识：16位，唯一标识主机发送的每一份<code>数据报</code>。</li>
<li>3位标志+13位片偏移：<code>暂时不关注</code>。</li>
<li>生存时间：8位，数据报最多可经过的<code>路由数</code>（如果不设置这个，就会无限回传）。</li>
<li>上层协议：8位，表明该IP数据报对应的<code>上层协议</code>是什么。</li>
<li>首部校验和：16位，保证IP数据报传输正确。</li>
<li>源IP地址：32位。</li>
<li>目的IP地址：32位。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/9/1651e01317d3de42?w=2034&amp;h=632&amp;f=jpeg&amp;s=295378" alt=""></p>
<ul>
<li><strong>上面是Wireshark抓的包的IP层，可以清楚看到每个协议的组成。</strong></li>
<li><strong>需要注意⚠️</strong><ul>
<li>假如我们发的是<code>公网IP</code>，此时我们无法用<code>ARP</code>找到远端<code>mac地址</code>。</li>
<li>需要通过发送给路由，所以我们需要路由的<code>mac地址</code>。</li>
<li>本来<code>数据链路层</code>的<code>以太网首部</code>放的是本机<code>mac地址</code>和目标<code>mac地址</code>。</li>
<li>现在放的是本机<code>mac地址</code>和路由<code>mac地址</code>。</li>
<li>而我们的目标<code>IP地址</code>和<code>源IP地址</code>则是包在IP首部之中，最后交给路由，让路由处理。</li>
</ul>
</li>
</ul>
<h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><ul>
<li><strong>每一个IP数据报在网络中进行<code>传输</code>的目的，要找到目的IP的<code>主机地址</code>，并最终到达该主机。所以IP数据报经过的每一个<code>节点</code>都相当于是一个<code>中转站</code>，也就是<code>路由</code>。</strong></li>
<li><strong>IP数据报被路由节点的操作称为<code>路由选择</code>。</strong><ul>
<li><code>动态选路</code>：根据当前<code>网络状况</code>，<code>权值</code>，选出一条最佳路径。</li>
<li><code>静态选路</code>：以<code>手工方式</code>为每台路由器的路由选择表添加路由。</li>
</ul>
</li>
<li><strong>常规的路由机制</strong><ul>
<li>目的主机与源主机直接相连，或处于共享网络，<code>直接送达</code>目标主机（相同内网下）。</li>
<li>默认<code>转发</code>至该网络存在的路由器上，再由其统一处理。</li>
</ul>
</li>
<li><strong>路由匹配算法</strong><ul>
<li>路由表中存在与目的IP地址完全相同的条目，直接发送至下一跳。</li>
<li>路由表中存在与目的IP地址网络号相同的条目，发送至该条目指定的下一跳。</li>
<li>以上条件均不成立，寻找默认条目，发送至该条目指定的下一跳。</li>
<li>均不成立，返回主机或网路不可达。</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/12/1652dbf6944fd611?w=1700&amp;h=800&amp;f=jpeg&amp;s=307838" alt=""></p>
<ul>
<li><strong>假如我们此时的目标IP地址为<code>192.168.0.100</code></strong>，此时会匹配<code>第一条</code>，他的<code>Gateway</code>就是目标的<code>mac地址</code>，en0是<code>网卡</code>，我们可以通过<code>ifconfig</code>查看(windows用ipconfig)</li>
<li><strong>假如我们此时目标IP地址为<code>192.168.0.103</code></strong>，此时路由表没有对应IP地址，则会去寻找相同<code>网络号</code>，此时找到第二条，他的<code>Gateway</code>是<code>link#8</code>相当于<code>广播</code>出去。</li>
<li><strong>假如我们此时目标IP地址为<code>192.168.1.2</code></strong>,此时无法在路由表中匹配，则走<code>default</code>，对应第三条，他的<code>Gateway</code>对应<code>192.168.0.1</code>，<code>192.168.0.1</code>其实就是我们的<code>路由器</code>。</li>
</ul>
<hr>
<blockquote>
<p>上面有提到判断<code>网络号</code>相同，这个我们怎么来做呢？</p>
</blockquote>
<hr>
<h3 id="如何判断两个IP地址网络号相同"><a href="#如何判断两个IP地址网络号相同" class="headerlink" title="如何判断两个IP地址网络号相同"></a>如何判断两个IP地址网络号相同</h3><h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">最大网络数</th>
<th style="text-align:center">IP地址范围</th>
<th style="text-align:center">最大主机数</th>
<th style="text-align:center">私有IP地址范围 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">126（2^7-2)</td>
<td style="text-align:center">0.0.0.0-127.255.255.255</td>
<td style="text-align:center">16777214</td>
<td style="text-align:center">10.0.0.0-10.255.255.255</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">16384(2^14)</td>
<td style="text-align:center">128.0.0.0-191.255.255.255</td>
<td style="text-align:center">65534</td>
<td style="text-align:center">172.16.0.0-172.31.255.255</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">2097152(2^21)</td>
<td style="text-align:center">192.0.0.0-223.255.255.255</td>
<td style="text-align:center">254</td>
<td style="text-align:center">192.168.0.0-192.168.255.255</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>IP 地址分为五个级别，分别为A类、B类、C类、D类、E类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。D、E类属特殊地址。</strong></li>
<li><strong>A 类 IP 地址是首位以 “0” 开头的地址</strong>。从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。</li>
<li><strong>B 类 IP 地址是前两位 “10” 的地址，一般是公网</strong>。从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。</li>
<li><strong>C 类 IP 地址是前三位为 “110” 的地址</strong>。从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。</li>
</ul>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><ul>
<li>为了<code>细分</code>更小力度的网络。</li>
<li>他让A、B、C类地址的主机地址部分用作<code>子网地址</code>，可以将原网络分为<code>多个</code>物理网络的一种<code>机制</code>。</li>
<li>每类的都有自己默认的网络地址</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">子网掩码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">255.0.0.0</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">255.255.0.0</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">255.255.255.0</td>
</tr>
</tbody>
</table>
<ul>
<li>通过和IP地址进行<code>与</code>运算(1&amp;0=0;0&amp;0=0;1&amp;1=1)来得到<code>网络号</code>，这里的<code>与</code>操作需要将IP地址转为<code>二进制</code>在进行<code>与</code>。</li>
</ul>
<h4 id="为什么细分了网络？"><a href="#为什么细分了网络？" class="headerlink" title="为什么细分了网络？"></a>为什么细分了网络？</h4><p><img src="https://user-gold-cdn.xitu.io/2018/8/12/1652e310abecfde0?w=1206&amp;h=886&amp;f=png&amp;s=77790" alt=""></p>
<p><strong>从上面的图，我们可以看出，每类地址的网络分段</strong></p>
<ul>
<li><strong>题目</strong><ul>
<li>1、10.0.0.1和10.1.1.1的网络号相同吗？</li>
<li>2、172.16.0.1和172.16.1.1的网络号呢？</li>
<li>3、192.168.10.103和192.168.0.102呢？</li>
</ul>
</li>
<li><strong>答案</strong><ul>
<li>1、相同。首先我们知道这两个IP地址同属A类，再将他们和默认子网掩码<code>(255.0.0.0)</code>相<code>与</code>，得到结果两个都是<code>10.0.0.0</code>，这就是他们的网络号，也正好符合图中的前8位，10转为二进制就是<code>00001010</code></li>
<li>2、同理可得，属于B类，相同，并且网络号为<code>172.16.0.0</code>。</li>
<li>3、属于C类，网络号不同，分别为<code>192.168.10.0</code>和<code>192.168.0.0</code>。</li>
</ul>
</li>
</ul>
<p><strong>上面的题目都是在默认的子网掩码之下，那么如果我们改了子网掩码呢？</strong></p>
<ul>
<li><strong>题目</strong><ul>
<li>1、172.16.0.1和172.16.1.1的子网掩码是255.255.255.0，此时网络号相同吗？</li>
</ul>
</li>
<li><strong>答案</strong><ul>
<li>1、不同，此时我们在算一次，把每个IP地址都和<code>255.255.255.0</code>相<code>与</code>，此时网络号分别为，<code>172.16.0.0</code>和<code>172.16.1.0</code>，则不同。</li>
</ul>
</li>
<li><strong>我们可以看到经过<code>子网掩码</code>，把我们本来相同<code>网段</code>的<code>IP地址</code>，划为不通<code>网段</code>的地址，这样就<code>细分</code>了网络，有更多的<code>物理网络</code>。</strong></li>
</ul>
<h3 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h3><p><strong>当我们的<code>MTU</code>最大传输单元<code>(1500字节，去掉以太网首部，就是1480字节)</code>满足不了我们的需求时，我们就需要<code>IP分片</code>(分成一片片传输)。</strong></p>
<ul>
<li><strong>回顾IP协议组成中的：标志字段、片偏移</strong><ul>
<li><strong>16位标识()</strong>：<code>IP分片</code>时，该值被复制每一个分片中，相当于每个分片的<code>id</code>。</li>
<li><strong>三位标志</strong>：<ul>
<li>首位：保留字段，一般为0。</li>
<li>中间位：不进行<code>IP分片</code>时为0，进行时为1。</li>
<li>末位：假如此时有3片<code>IP分片</code>，前两片末位都为1，最后一片末位为0。</li>
</ul>
</li>
<li><strong>13位片偏移</strong>：该片偏移原始数据包开始处的位置。假如此时5片IP分片，那么第一片的13位片偏移为1，第二片为2，让路由知道<code>先后顺序</code>。</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/12/1652e87cee53fc37?w=2190&amp;h=818&amp;f=jpeg&amp;s=337284" alt=""></p>
<ul>
<li><strong>错误处理</strong><ul>
<li>当<code>IP分片</code>时，只丢失<code>一片</code>数据，也需要<code>重传</code>整个IP数据报。</li>
<li>当给定数据报的第一个数据报片到达时，开始<code>定时器</code>，<code>过期</code>丢弃所有数据报片。</li>
</ul>
</li>
</ul>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><ul>
<li><strong>属于IP协议的<code>一部分</code>。</strong></li>
<li><strong>确认 IP 包<code>是否</code>成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，<code>改善</code>网络设置等。</strong></li>
<li><strong>IP包首部有一个字段<code>TTL</code>，每经过一个路由器就会<code>减1</code>，直到减到0时IP报就会被丢弃。</strong></li>
<li><strong>此时，IP路由器将会发送一个ICMP超时的消息给发送端，通知该包已被<code>丢弃</code>。</strong></li>
<li><strong><code>traceroute</code>命令的原理就是通过ICMP超时消息来显示发送主机到达特定主机之前经历了多少路由器。</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/12/1652ed1de92dcfdd?w=1298&amp;h=554&amp;f=jpeg&amp;s=182578" alt=""></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>处理数据报在网络中的行为（路由选择）。</strong></li>
<li><strong>承载端到端的数据交互方式（两个ip的host之间的传递数据）。</strong></li>
<li><strong>缺点：</strong><ul>
<li>只是保证数据基本达到，数据可能是无序的。</li>
<li>可能是缺失的。</li>
</ul>
</li>
</ul>
<h2 id="传输层（TCP协议）"><a href="#传输层（TCP协议）" class="headerlink" title="传输层（TCP协议）"></a>传输层（TCP协议）</h2><blockquote>
<p>解决IP层的痛点，是一种安全的协议，主要通过<code>连接</code>疏通了整一个通道，安全传输。</p>
</blockquote>
<h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/1652f0f13f0b1761?w=1194&amp;h=1012&amp;f=jpeg&amp;s=106652" alt=""></p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul>
<li><strong>看前三个<code>箭头</code>：</strong><ul>
<li>客户端发送<code>SYN A1</code>来<code>请求建立连接</code>，SYN就是<code>synchronization(同步)</code>，而且此时A1是被传在<code>sequence(序列)</code>中的，此时服务端接收到客户端传来的<code>A1</code>信号。</li>
<li>服务端<code>回应</code>客户端<code>我接收到了</code>，所以发送<code>ACK A2(只是确认应答，所以只需在原有的A1+1=A2)</code>，这里的ACK就是<code>acknowledge(确认)</code>。并且<code>请求客户端建立连接</code>， 此时发送一个信号<code>SYN B1</code>。</li>
<li>客户端接受并<code>确认应答</code>，告知服务端接收到了信号，所以发送<code>ACK B2(因为上次推过来的SYN B1)</code>。</li>
</ul>
</li>
</ul>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul>
<li><strong>看后四个<code>箭头</code>：</strong><ul>
<li>客户端发送结束信号<code>FIN C1</code>。</li>
<li>服务端接收到结束信号，<code>回应接收到了</code>，此时发送信号<code>ACK C2</code>，客户端已经关闭，但是服务器处于<code>半关闭状态(客户端不能向服务器发送请求，服务器还是能接受客户端请求)</code>。</li>
<li>服务端向客户端发送结束信号<code>FIN D1</code>。</li>
<li>客户端接收到结束信号，<code>回应接收到了</code>，此时发送信号<code>ACK D2</code>，服务器也关闭。</li>
</ul>
</li>
</ul>
<h3 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h3><ul>
<li><code>序列号</code>是按照<code>顺序</code>给发送数据的每一个字节<code>（8位字节）</code>都标上号码的编号。接收端查询接收数据TCP首部中的<code>序列号</code>和<code>数据的长度</code>，将自己下一步应该接收的<code>序列号</code>作为<code>确认应答</code>返送回去。通过<code>序列号</code>和<code>确认应答号</code>，TCP能够识别<code>是否</code>已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</li>
</ul>
<h3 id="重发超时的确定"><a href="#重发超时的确定" class="headerlink" title="重发超时的确定"></a>重发超时的确定</h3><ul>
<li><code>重发超时</code>是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行<code>数据重发</code>。最理想的是，找到一个<code>最小时间</code>，它能保证“确认应答一定能在这个时间内返回”。</li>
<li>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其<code>偏差</code>。将这个往返时间和偏差时间相加，<code>重发超时</code>的时间就是比这个总和要稍大一点的值。</li>
<li>在 BSD 的 Unix 以及Windows系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的<code>整数倍</code>。不过，最初其<code>重发超时</code>的默认值一般设置为<code>6秒</code>左右。</li>
<li>数据被重发之后若还是收不到确认应答，则进行<code>再次发送</code>。此时，等待确认应答的时间将会以<code>2倍、4倍</code>的指数函数<code>延长</code>。</li>
<li>此外，数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，<code>强制关闭连接</code>。并且通知应用通信异常<code>强行终止</code>。</li>
</ul>
<h3 id="以段为单位发送数据"><a href="#以段为单位发送数据" class="headerlink" title="以段为单位发送数据"></a>以段为单位发送数据</h3><ul>
<li>在建立<code>TCP</code>连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”<code>（MSS）</code>。最理想的情况是，最大消息长度正好是IP中不会被分片处理的最大数据长度。</li>
<li><code>TCP</code>在传送大量数据时，是以<code>MSS</code>的大小将数据进行分割发送。进行重发时也是以<code>MSS</code>为单位。</li>
<li><code>MSS</code>在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在<code>TCP</code>首部中写入<code>MSS</code>选项，告诉对方自己的接口能够适应的<code>MSS</code> 的大小。然后会在两者之间选择一个较小的值投入使用。</li>
</ul>
<h3 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h3><ul>
<li><code>TCP</code> 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个<code>缺点</code>，就是包的往返时间越长<code>通信性能</code>就越低。</li>
<li>为解决这个问题，TCP引入了<code>窗口</code>这个概念。确认应答不再是以每个<code>分段</code>，而是以更大的<code>单位</code>进行确认，转发时间将会被大幅地<code>缩短</code>。也就是说，发送端主机，在发送了一个段以后<code>不必要</code>一直等待确认应答，而是继续<code>发送</code>。</li>
<li>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。这个机制实现了使用大量的<code>缓冲区</code>，通过对多个段同时进行确认应答的功能。</li>
</ul>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>抽象出<code>连接</code>的概念，在一个TCP连接中，仅有两方<code>彼此通信</code>。</li>
<li>保证了可靠数据传输及正确顺序的<code>数据处理</code>。</li>
<li>提供<code>流量控制</code>（Node.js中的流）</li>
</ul>
<h2 id="应用层（HTTP协议）"><a href="#应用层（HTTP协议）" class="headerlink" title="应用层（HTTP协议）"></a>应用层（HTTP协议）</h2><blockquote>
<p><strong>我会留到下一篇再讲，同时我会结合<code>node</code>来讲解其中的<code>http</code>的应用和原理，敬请期待。</strong></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IP/">IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OSI/">OSI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/">TCP</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-模块化 CommonJS" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/08/模块化 CommonJS/" class="article-date">
  	<time datetime="2018-08-08T03:43:40.000Z" itemprop="datePublished">2018-08-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/08/模块化 CommonJS/">你真的懂模块化吗？教你CommonJS实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="你真的懂模块化吗"><a href="#你真的懂模块化吗" class="headerlink" title="你真的懂模块化吗"></a>你真的懂模块化吗</h1><blockquote>
<p>加紧学习，抓住中心，宁精勿杂，宁专勿多。 —— 周恩来</p>
</blockquote>
<h2 id="模块简史"><a href="#模块简史" class="headerlink" title="模块简史"></a>模块简史</h2><ul>
<li>早期的 JavaScript 往往作为嵌入到 HTML 页面中的用于控制动画与简单的用户交互的脚本语言，我们习惯这样写。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--html--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="comment">// module1 code</span></div><div class="line">    <span class="comment">// module2 code</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><p>所有的嵌入到网页内的 JavaScript 对象都会使用全局的 <code>window</code> 对象来存放未使用 <code>var</code> 定义的变量。这就会导致一个问题，那就是，最后调用的函数或变量取决于我们引入的先后顺序。</p>
</li>
<li><p><code>模块化时代</code>。随着单页应用与富客户端的流行，不断增长的代码库也急需合理的代码分割与依赖管理的解决方案，这也就是我们在软件工程领域所熟悉的<code>模块化（Modularity）</code>。</p>
</li>
<li><p>直接声明依赖（Directly Defined Dependences）、命名空间（Namespace Pattern）、模块模式（Module Pattern）、依赖分离定义（Detached Dependency Definitions）、沙盒（Sandbox）、依赖注入（Dependency Injection）、CommonJS、AMD、UMD、标签化模块（Labeled Modules）、YModules、ES 2015 Modules。这些都是模块化时代的产物。 </p>
</li>
<li><p>问题来了，<code>过度</code>碎片化的模块同样会带来性能的损耗与包体尺寸的增大，这包括了模块加载、模块解析、因为 Webpack 等打包工具包裹模块时封装的过多<code>IIFE</code> 函数导致的 JavaScript 引擎优化失败等。</p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/7/1651267ecfba395f?w=196&amp;h=149&amp;f=jpeg&amp;s=6367" alt=""></p>
<h2 id="那么到底什么是模块化？"><a href="#那么到底什么是模块化？" class="headerlink" title="那么到底什么是模块化？"></a>那么到底什么是模块化？</h2><blockquote>
<p>简而言之，模块化就是将一个大的功能拆分为多个块，每一个块都是<code>独立</code>的，你不需要去担心<code>污染</code>全局变量，命名<code>冲突</code>什么的。</p>
</blockquote>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>封装功能</li>
<li>封闭作用域</li>
<li>可能解决依赖问题</li>
<li>工作效率更高，重构方便</li>
<li>解决命名冲突</li>
<li>…</li>
</ul>
<h3 id="js有模块化吗？"><a href="#js有模块化吗？" class="headerlink" title="js有模块化吗？"></a>js有模块化吗？</h3><ul>
<li>JS没有模块系统，不支持<code>封闭</code>的作用域和依赖管理</li>
<li>没有标准库，没有文件系统和<code>IO流</code>API</li>
<li>也没有包管理系统</li>
</ul>
<h3 id="那怎么实现js的模块化？"><a href="#那怎么实现js的模块化？" class="headerlink" title="那怎么实现js的模块化？"></a>那怎么实现js的模块化？</h3><ul>
<li>CommonJS规范，node是在<code>v8引擎</code>上的javascript运行时，作为服务端的，不能没有模块化的功能，于是就创造CommonJS规范，现在的node用的是CommonJS2。CommonJS2和CommonJS1的区别也在下面。属于<code>动态同步加载</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CommonJS2也可以通过这种方式导出</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">1</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// CommonJS1只能通过这种方式</span></div><div class="line">exports.a = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</div><div class="line"><span class="built_in">module</span>.a <span class="comment">// -&gt; log 1</span></div></pre></td></tr></table></figure>
<ul>
<li>AMD &amp;&amp; CMD。AMD是<code>RequireJS</code>提出的，主要是<code>依赖前置</code>。CMD是<code>SeaJS</code>提出的，主要是就近依赖（只要用到才会导入），两者用法接近。属于<code>异步加载</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file lib/greeting.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> helloInLang = &#123;</div><div class="line">        <span class="attr">en</span>: <span class="string">'Hello world!'</span>,</div><div class="line">        <span class="attr">es</span>: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">        <span class="attr">ru</span>: <span class="string">'Привет мир!'</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> helloInLang[lang];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line">define([<span class="string">'./lib/greeting'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">greeting</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> phrase = greeting.sayHello(<span class="string">'en'</span>);</div><div class="line">    <span class="built_in">document</span>.write(phrase);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>UMD。因为AMD中无法使用CommonJS，所以出来了一个UMD，可在UMD中同时使用AMD和CommonJS。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">define</span>) </span>&#123;</div><div class="line">    define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> helloInLang = <span class="string">'hello'</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> helloInLang[lang];</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;);</div><div class="line">&#125;(</div><div class="line">    <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="built_in">module</span>.exports &amp;&amp; <span class="keyword">typeof</span> define !== <span class="string">'function'</span> ?</div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">factory</span>) </span>&#123; <span class="built_in">module</span>.exports = factory(); &#125; :</div><div class="line">    define</div><div class="line">));</div></pre></td></tr></table></figure>
<h2 id="CommonJS实现"><a href="#CommonJS实现" class="headerlink" title="CommonJS实现"></a>CommonJS实现</h2><ul>
<li>首先我们这里说的CommonJS是CommonJS2，我们需要了解到它的特性。</li>
<li>模块引用时会找到<code>绝对路径</code></li>
<li>模块加载过会有<code>缓存</code>，把文件名作为key，module作为value</li>
<li>node实现模块化就是增加了一个闭包，并且自执行这个<code>闭包（runInThisContext）</code></li>
<li>模块加载时是<code>同步</code>操作</li>
<li>默认会加后缀<code>js</code>,<code>json</code>,…</li>
<li>不同模块下的变量不会相互<code>冲突</code></li>
</ul>
<h3 id="闭包实现-其实CommonJS中每个模块都是一个闭包，所以里面的变量互不影响"><a href="#闭包实现-其实CommonJS中每个模块都是一个闭包，所以里面的变量互不影响" class="headerlink" title="闭包实现(其实CommonJS中每个模块都是一个闭包，所以里面的变量互不影响)"></a>闭包实现(其实CommonJS中每个模块都是一个闭包，所以里面的变量互不影响)</h3><ul>
<li>我们可以在vscode中创建一个arguments.js项目</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//arguments就是参数列表</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</div></pre></td></tr></table></figure>
<ul>
<li>此时在node环境下执行该文件，就会输出如下</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&#123; '0': &#123;&#125;,</div><div class="line">  '1': </div><div class="line">   &#123; [Function: require]</div><div class="line">     resolve: &#123; [Function: resolve] paths: [Function: paths] &#125;,</div><div class="line">     main: </div><div class="line">      Module &#123;</div><div class="line">        id: '.',</div><div class="line">        exports: &#123;&#125;,</div><div class="line">        parent: null,</div><div class="line">        filename: '/Users/chenxufeng/Desktop/笔记/node/arguments.js',</div><div class="line">        loaded: false,</div><div class="line">        children: [],</div><div class="line">        paths: [Array] &#125;,</div><div class="line">     extensions: &#123; '.js': [Function], '.json': [Function], '.node': [Function] &#125;,</div><div class="line">     cache: &#123; '/Users/chenxufeng/Desktop/笔记/node/arguments.js': [Object] &#125; &#125;,</div><div class="line">  '2': </div><div class="line">   Module &#123;</div><div class="line">     id: '.',</div><div class="line">     exports: &#123;&#125;,</div><div class="line">     parent: null,</div><div class="line">     filename: '/Users/chenxufeng/Desktop/笔记/node/arguments.js',</div><div class="line">     loaded: false,</div><div class="line">     children: [],</div><div class="line">     paths: </div><div class="line">      [ '/Users/chenxufeng/Desktop/笔记/node/node_modules',</div><div class="line">        '/Users/chenxufeng/Desktop/笔记/node_modules',</div><div class="line">        '/Users/chenxufeng/Desktop/node_modules',</div><div class="line">        '/Users/chenxufeng/node_modules',</div><div class="line">        '/Users/node_modules',</div><div class="line">        '/node_modules' ] &#125;,</div><div class="line">  '3': '/Users/chenxufeng/Desktop/笔记/node/arguments.js',</div><div class="line">  '4': '/Users/chenxufeng/Desktop/笔记/node' &#125;</div></pre></td></tr></table></figure>
<ul>
<li>其实每个模块外面都包了这么一层闭包，所以外面的require才能获取到module.exports的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//exports内存中指向的就是module.exports指向的那块空间</span></div><div class="line"><span class="comment">//require一个方法</span></div><div class="line"><span class="comment">//Module模块类</span></div><div class="line"><span class="comment">//__filename该文件绝对路径</span></div><div class="line"><span class="comment">//__dirname该文件父文件夹的绝对路径</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">exports,require,Module,__filename,__dirname</span>)</span>&#123;</div><div class="line">  <span class="built_in">module</span>.exports = exports = <span class="keyword">this</span> = &#123;&#125;</div><div class="line">  <span class="comment">//文件中的所有代码</span></div><div class="line">  </div><div class="line"></div><div class="line">  <span class="comment">//不能改变exports指向，因为返回的是module.exports，所以是个&#123;&#125;</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>所以我们require的时候其实就相当于执行了这么一个闭包，然后返回的就是我们的module.exports</strong></p>
<h3 id="require是怎么样的？"><a href="#require是怎么样的？" class="headerlink" title="require是怎么样的？"></a>require是怎么样的？</h3><ul>
<li>每个模块都会带一个require方法</li>
<li>动态加载(v8执行到这一步才会去加载此模块)</li>
<li>不同模块的类别，有不同的加载方式，一般有三种常用后缀<ul>
<li>后缀名为.js的JavaScript脚本文件,需要先读入内存再运行</li>
<li>后缀名为.json的JSON文件,fs 读入内存 转化成JSON对象</li>
<li>后缀名为.node的经过编译后的二进制C/C++扩展模块文件,可以直接使用</li>
</ul>
</li>
<li>查找第三方模块<ul>
<li>如果require函数只指定名称则视为从node_modules下面加载文件，这样的话你可以移动模块而不需要修改引用的模块路径。</li>
<li>第三方模块的查询路径包括module.paths和全局目录。</li>
</ul>
</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/7/1651221feb8ab9bb?w=524&amp;h=815&amp;f=png&amp;s=32263" alt=""></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote>
<p>下面我通过步骤讲解<code>require</code>整个的一个实现</p>
</blockquote>
<h4 id="根据路径找是否有缓存"><a href="#根据路径找是否有缓存" class="headerlink" title="根据路径找是否有缓存"></a>根据路径找是否有缓存</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//require方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">req</span>(<span class="params">moduleId</span>)</span>&#123;</div><div class="line">  <span class="comment">//解析绝对路径的方法，返回一个绝对路径</span></div><div class="line">  <span class="keyword">let</span> p = Module._resolveFileName(moduleId)</div><div class="line">  <span class="comment">//查看是否有缓存</span></div><div class="line">  <span class="keyword">if</span>(Module._catcheModule[p])&#123;</div><div class="line">    <span class="comment">//有缓存直接返回对应模块的exports</span></div><div class="line">    <span class="keyword">return</span> Module._catcheModule[p].exports</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//没有缓存就生成一个</span></div><div class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(p)</div><div class="line">  <span class="comment">//把他放入缓存中</span></div><div class="line">  Module._catcheModule[p] = <span class="built_in">module</span></div><div class="line">  <span class="comment">//加载模块</span></div><div class="line">  <span class="built_in">module</span>.exports = <span class="built_in">module</span>.load(p)</div><div class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>上面有很多方法都还没有，不急，我们慢慢实现</p>
</blockquote>
<h4 id="创建Module类，并添加-resolveFileName和-catcheModule"><a href="#创建Module类，并添加-resolveFileName和-catcheModule" class="headerlink" title="创建Module类，并添加_resolveFileName和_catcheModule"></a>创建<code>Module类</code>，并添加<code>_resolveFileName</code>和<code>_catcheModule</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//node原生的模块，用来读写文件(fileSystem)</span></div><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="comment">//node原生的模块，用来解析文件路径</span></div><div class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</div><div class="line"><span class="comment">//Module类，就相当于我们的模块(因为node环境不支持es6的class，这里用function)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">p</span>)</span>&#123;</div><div class="line">  <span class="comment">//当前模块的标识</span></div><div class="line">  <span class="keyword">this</span>.id = p</div><div class="line">  <span class="comment">//没个模块都有一个exports属性</span></div><div class="line">  <span class="keyword">this</span>.exports = &#123;&#125;</div><div class="line">  <span class="comment">//这个模块默认没有加载完</span></div><div class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span></div><div class="line">  <span class="comment">//模块加载方法(这个我们到时候再实现)</span></div><div class="line">  <span class="keyword">this</span>.load = <span class="function"><span class="keyword">function</span>(<span class="params">filepath</span>)</span>&#123;</div><div class="line">    <span class="comment">//判断文件是json还是 node还是js</span></div><div class="line">    <span class="keyword">let</span> ext = path.extname(filepath)</div><div class="line">    <span class="comment">//返回一个exports</span></div><div class="line">    <span class="keyword">return</span> Module._extensions[ext](<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//以绝对路径为key存储一个module</span></div><div class="line">Module._catcheModule = &#123;&#125;</div><div class="line"><span class="comment">// 解析绝对路径的方法，返回一个绝对路径</span></div><div class="line">Module._resolveFileName = <span class="function"><span class="keyword">function</span>(<span class="params">moduleId</span>)</span>&#123;</div><div class="line">  <span class="comment">//获取moduleId的绝对路径</span></div><div class="line">  <span class="keyword">let</span> p = path.resolve(moduleId)</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//同步地测试 path 指定的文件或目录的用户权限</span></div><div class="line">    fs.accessSync(p)      </div><div class="line">    <span class="keyword">return</span> p</div><div class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">    <span class="built_in">console</span>.log(e)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>此时会有一个问题，如果我们没有传文件后缀，就会读取不到</p>
</blockquote>
<h4 id="给Module添加一个加载策略，并且在-resolveFileName中再加点东西"><a href="#给Module添加一个加载策略，并且在-resolveFileName中再加点东西" class="headerlink" title="给Module添加一个加载策略，并且在_resolveFileName中再加点东西"></a>给Module添加一个<code>加载策略</code>，并且在<code>_resolveFileName</code>中再加点东西</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//所有的加载策略</span></div><div class="line">Module._extensions = &#123;</div><div class="line">  <span class="string">'.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module</span>)</span>&#123;</div><div class="line">    <span class="comment">//每个文件的加载逻辑不一样，这个我们后面再写</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">'.json'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module</span>)</span>&#123;</div><div class="line">  &#125;,</div><div class="line">  <span class="string">'.node'</span>: <span class="string">'xxx'</span>,</div><div class="line">&#125;</div><div class="line">Module._resolveFileName = <span class="function"><span class="keyword">function</span>(<span class="params">moduleId</span>)</span>&#123;</div><div class="line">  <span class="comment">//对象中所有的key做成一个数组[]</span></div><div class="line">  <span class="keyword">let</span> arr = <span class="built_in">Object</span>.keys(Module._extensions)</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">    <span class="keyword">let</span> file = p+arr[i]</div><div class="line">    <span class="comment">//因为整个模块读取是个同步过程，所以得用sync，这里判断有没有这个文件存在</span></div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">      fs.accessSync(file)      </div><div class="line">      <span class="keyword">return</span> p</div><div class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">      <span class="built_in">console</span>.log(e)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>此时，我们能够找到文件的绝对路径，并把他丢给Module实例上的<code>load</code>方法</p>
</blockquote>
<h4 id="load方法实现"><a href="#load方法实现" class="headerlink" title="load方法实现"></a>load方法实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//node原生的模块，用来读写文件(fileSystem)</span></div><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="comment">//node原生的模块，用来解析文件路径</span></div><div class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</div><div class="line"><span class="comment">//提供了一系列 API 用于在 V8 虚拟机环境中编译和运行代码。</span></div><div class="line"><span class="keyword">let</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>)</div><div class="line"><span class="comment">//Module类，就相当于我们的模块(因为node环境不支持es6的class，这里用function)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">p</span>)</span>&#123;</div><div class="line">  <span class="comment">//当前模块的标识</span></div><div class="line">  <span class="keyword">this</span>.id = p</div><div class="line">  <span class="comment">//没个模块都有一个exports属性</span></div><div class="line">  <span class="keyword">this</span>.exports = &#123;&#125;</div><div class="line">  <span class="comment">//这个模块默认没有加载完</span></div><div class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span></div><div class="line">  <span class="comment">//模块加载方法</span></div><div class="line">  <span class="keyword">this</span>.load = <span class="function"><span class="keyword">function</span>(<span class="params">filepath</span>)</span>&#123;</div><div class="line">    <span class="comment">//判断文件后缀是json还是 node还是js</span></div><div class="line">    <span class="keyword">let</span> ext = path.extname(filepath)</div><div class="line">    <span class="keyword">return</span> Module._extensions[ext](<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//js文件加载的包装类</span></div><div class="line">Module._wrapper = [<span class="string">'(function(exports,require,module,__dirname,__filename)&#123;'</span>,<span class="string">'\n&#125;)'</span>]</div><div class="line"><span class="comment">//所有的加载策略</span></div><div class="line">Module._extensions = &#123;</div><div class="line">   <span class="comment">//这里的module参数是就是Module的实例</span></div><div class="line">  <span class="string">'.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> fn = Module._wrapper[<span class="number">0</span>] + fs.readFileSync(<span class="built_in">module</span>.id,<span class="string">'utf8'</span>) + Module._wrapper[<span class="number">1</span>]</div><div class="line">    <span class="comment">//执行包装后的方法 把js文件中的导出引入module的exports中</span></div><div class="line">    <span class="comment">//模块中的this === module.exports === &#123;&#125; exports也只是module.exports的别名</span></div><div class="line">    <span class="comment">//runInThisContext：虚拟机会产生一个干净的作用域来跑其中的代码，类似于沙箱sandbox</span></div><div class="line">    vm.runInThisContext(fn).call(<span class="built_in">module</span>.exports,<span class="built_in">module</span>.exports,req,<span class="built_in">module</span>)</div><div class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</div><div class="line">  &#125;,</div><div class="line">  <span class="string">'.json'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module</span>)</span>&#123;</div><div class="line">    <span class="comment">//同步读取文件中的内容并把它转为JSON对象</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(fs.readFileSync(<span class="built_in">module</span>.id,<span class="string">'utf8'</span>))</div><div class="line">  &#125;,</div><div class="line">  <span class="string">'.node'</span>: <span class="string">'xxx'</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>此时我们的代码已经全部完成</p>
</blockquote>
<ul>
<li>我们随便找个文件试一下，当然如果是vscode下的话，req的路径参数需要在根目录下，这是一个坑。</li>
<li>如果是vscode，就可以下一个插件<code>Code Runner</code>，可在vscode右键直接运行js文件，在node环境中。</li>
<li>我们拿之前的arguments.js来实验</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/7/16512599085c82c6?w=1168&amp;h=760&amp;f=jpeg&amp;s=91123" alt=""></p>
<ul>
<li>成功输出！！</li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//node原生的模块，用来读写文件(fileSystem)</span></div><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="comment">//node原生的模块，用来解析文件路径</span></div><div class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</div><div class="line"><span class="comment">//提供了一系列 API 用于在 V8 虚拟机环境中编译和运行代码。</span></div><div class="line"><span class="keyword">let</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>)</div><div class="line"><span class="comment">//Module类，就相当于我们的模块(因为node环境不支持es6的class，这里用function)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">p</span>)</span>&#123;</div><div class="line">  <span class="comment">//当前模块的标识</span></div><div class="line">  <span class="keyword">this</span>.id = p</div><div class="line">  <span class="comment">//没个模块都有一个exports属性</span></div><div class="line">  <span class="keyword">this</span>.exports = &#123;&#125;</div><div class="line">  <span class="comment">//这个模块默认没有加载完</span></div><div class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span></div><div class="line">  <span class="comment">//模块加载方法</span></div><div class="line">  <span class="keyword">this</span>.load = <span class="function"><span class="keyword">function</span>(<span class="params">filepath</span>)</span>&#123;</div><div class="line">    <span class="comment">//判断文件是json还是 node还是js</span></div><div class="line">    <span class="keyword">let</span> ext = path.extname(filepath)</div><div class="line">    <span class="keyword">return</span> Module._extensions[ext](<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//js文件加载的包装类</span></div><div class="line">Module._wrapper = [<span class="string">'(function(exports,require,module,__dirname,__filename)&#123;'</span>,<span class="string">'\n&#125;)'</span>]</div><div class="line"><span class="comment">//所有的加载策略</span></div><div class="line">Module._extensions = &#123;</div><div class="line">  <span class="string">'.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> fn = Module._wrapper[<span class="number">0</span>] + fs.readFileSync(<span class="built_in">module</span>.id,<span class="string">'utf8'</span>) + Module._wrapper[<span class="number">1</span>]</div><div class="line">    <span class="comment">//执行包装后的方法 把js文件中的导出引入module的exports中</span></div><div class="line">    <span class="comment">//模块中的this === module.exports === &#123;&#125;  exports也只是module.exports的别名</span></div><div class="line">    vm.runInThisContext(fn).call(<span class="built_in">module</span>.exports,<span class="built_in">module</span>.exports,req,<span class="built_in">module</span>)</div><div class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</div><div class="line">  &#125;,</div><div class="line">  <span class="string">'.json'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(fs.readFileSync(<span class="built_in">module</span>.id,<span class="string">'utf8'</span>))</div><div class="line">  &#125;,</div><div class="line">  <span class="string">'.node'</span>: <span class="string">'xxx'</span>,</div><div class="line">&#125;</div><div class="line"><span class="comment">//以绝对路径为key存储一个module</span></div><div class="line">Module._catcheModule = &#123;&#125;</div><div class="line"><span class="comment">// 解析绝对路径的方法，返回一个绝对路径</span></div><div class="line">Module._resolveFileName = <span class="function"><span class="keyword">function</span>(<span class="params">moduleId</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> p = path.resolve(moduleId)</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    fs.accessSync(p)      </div><div class="line">    <span class="keyword">return</span> p</div><div class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">    <span class="built_in">console</span>.log(e)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//对象中所有的key做成一个数组[]</span></div><div class="line">  <span class="keyword">let</span> arr = <span class="built_in">Object</span>.keys(Module._extensions)</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">    <span class="keyword">let</span> file = p+arr[i]</div><div class="line">    <span class="comment">//因为整个模块读取是个同步过程，所以得用sync，这里判断有没有这个文件存在</span></div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">      fs.accessSync(file)      </div><div class="line">      <span class="keyword">return</span> file</div><div class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">      <span class="built_in">console</span>.log(e)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//require方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">req</span>(<span class="params">moduleId</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> p = Module._resolveFileName(moduleId)</div><div class="line">  <span class="keyword">if</span>(Module._catcheModule[p])&#123;</div><div class="line">    <span class="comment">//模块已存在</span></div><div class="line">    <span class="keyword">return</span> Module._catcheModule[p].exports</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//没有缓存就生成一个</span></div><div class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(p)</div><div class="line">  Module._catcheModule[p] = <span class="built_in">module</span></div><div class="line">  <span class="comment">//加载模块</span></div><div class="line">  <span class="built_in">module</span>.exports = <span class="built_in">module</span>.load(p)</div><div class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CommonJS/">CommonJS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ReactSSR" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/20/ReactSSR/" class="article-date">
  	<time datetime="2018-07-20T05:00:40.000Z" itemprop="datePublished">2018-07-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/20/ReactSSR/">React服务端渲染+pm2自动化部署</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/4251486-55c53184b57770de.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15315912157248fdea6bb73.jpeg"></p>
<p><strong>本文是直接着手SSR部分的并通过实战讲述自己遇到的一些问题和方案，需要大家有一定的React,node和webpack基础能力。skr，skr。</strong></p>
<h1 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h1><blockquote>
<p><code>Server Slide Rendering</code>服务端渲染,又简写为<code>SSR</code>，他一般被用在我们的<code>SPA（Single-Page Application）</code>，即单页应用。</p>
</blockquote>
<h2 id="为什么要用SSR？"><a href="#为什么要用SSR？" class="headerlink" title="为什么要用SSR？"></a>为什么要用SSR？</h2><p>首先我们需要知道SSR对于SPA的<code>好处</code>，<code>优势</code>是什么。</p>
<ul>
<li>更好的<code>SEO（Search Engine Optimization）</code>，<code>SEO</code>是搜索引擎优化，简而言之就是针对百度这些搜索引擎，可以让他们搜索到我们的应用。这里可能会有误区，就是我也可以在index.html上写<code>SEO</code>，为什么会不起作用。因为React、Vue的原理是<strong>客户端渲染</strong>，通过浏览器去加载js、css，有一个时间上的<code>延迟</code>，而搜索引擎不会管你的<code>延迟</code>，他就觉得你如果没加载出来就是没有的，所以是搜不到的。</li>
<li>解决一开始的<code>白屏渲染</code>，上面讲了React的渲染原理，而<strong>SSR服务端渲染</strong>是通过服务端请求数据，因为服务端内网的请求快，性能好所以会更快的加载所有的文件，最后把下载渲染后的页面返回给客户端。</li>
</ul>
<h2 id="上面提到了服务端渲染和客户端渲染，那么它们的区别是什么呢？"><a href="#上面提到了服务端渲染和客户端渲染，那么它们的区别是什么呢？" class="headerlink" title="上面提到了服务端渲染和客户端渲染，那么它们的区别是什么呢？"></a>上面提到了服务端渲染和客户端渲染，那么它们的区别是什么呢？</h2><p><strong>客户端渲染路线：</strong></p>
<ol>
<li>请求一个html  </li>
<li>服务端返回一个html  </li>
<li>浏览器下载html里面的js/css文件  </li>
<li>等待js文件下载完成  </li>
<li>等待js加载并初始化完成  </li>
<li>js代码终于可以运行，由js代码向后端请求数据( ajax/fetch )  </li>
<li>等待后端数据返回  </li>
<li>react-dom( 客户端 )从无到完整地，把数据渲染为响应页面</li>
</ol>
<p><strong>服务端渲染路线：</strong></p>
<ol>
<li>请求一个html  </li>
<li>服务端请求数据( 内网请求快 )  </li>
<li>服务器初始渲染（服务端性能好，较快）  </li>
<li>服务端返回已经有正确内容的页面  </li>
<li>客户端请求js/css文件  </li>
<li>等待js文件下载完成  </li>
<li>等待js加载并初始化完成  </li>
<li>react-dom( 客户端 )把剩下一部分渲染完成( 内容小，渲染快 )</li>
</ol>
<blockquote>
<p>其主要区别就在于，客户端从<code>无到有的</code>渲染，服务端是先在服务端<code>渲染一部分</code>，在再客户端<code>渲染一小部分</code>。</p>
</blockquote>
<h3 id="我们怎么去做服务端渲染？"><a href="#我们怎么去做服务端渲染？" class="headerlink" title="我们怎么去做服务端渲染？"></a>我们怎么去做服务端渲染？</h3><p>我们这里是用express框架，node做中间层进行服务端渲染。通过将<code>首页进行同构处理</code>，让服务端，通过调用<code>ReactDOMServer.renderToNodeStream</code>方法把<code>Virtual DOM</code>转换成<code>HTML字符串</code>返回给客户端，从而达到服务端渲染的目的。</p>
<p><strong>这里项目起步是已经做完前端和后端，是把已经写好的React Demo直接拿来用</strong></p>
<h1 id="服务端渲染开始"><a href="#服务端渲染开始" class="headerlink" title="服务端渲染开始"></a>服务端渲染开始</h1><p>既然是首页SSR，首先我们要把首页对应的<code>index.js</code>抽离出来放入我们服务端对应的<code>server.js</code>，那么<code>index.js</code>中组件对应的<code>静态css和js文件</code>我们需要打包出来。</p>
<h2 id="用webpack打包文件到build文件夹"><a href="#用webpack打包文件到build文件夹" class="headerlink" title="用webpack打包文件到build文件夹"></a>用webpack打包文件到build文件夹</h2><p>我们来运行<code>npm run build</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/1644f56948725d9f?w=1148&amp;h=592&amp;f=jpeg&amp;s=129956" alt=""></p>
<p><strong>我们可以看到<code>两个重要的文件夹</code>，一个是js文件夹，一个是css文件夹，他就是我们项目的js和css<code>静态资源文件</code></strong></p>
<h2 id="将打包后的build文件能在服务端server-js中访问到"><a href="#将打包后的build文件能在服务端server-js中访问到" class="headerlink" title="将打包后的build文件能在服务端server.js中访问到"></a>将打包后的<code>build</code>文件能在服务端<code>server.js</code>中访问到</h2><p><strong>因为是服务端，我们需要用到express</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span></div><div class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'../src/reducer'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> userRouter <span class="keyword">from</span> <span class="string">'./routes/user'</span></div><div class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'body-parser'</span></div><div class="line"><span class="keyword">import</span> cookieParser <span class="keyword">from</span> <span class="string">'cookie-parser'</span></div><div class="line"><span class="keyword">import</span> model <span class="keyword">from</span> <span class="string">'./model'</span></div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></div><div class="line"><span class="keyword">import</span> https <span class="keyword">from</span> <span class="string">'http'</span></div><div class="line"><span class="keyword">import</span> socketIo <span class="keyword">from</span> <span class="string">'socket.io'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> Chat = model.getModel(<span class="string">'chat'</span>)</div><div class="line"><span class="comment">//新建app</span></div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"></div><div class="line"><span class="comment">//work with express</span></div><div class="line"><span class="keyword">const</span> server = https.Server(app)</div><div class="line"><span class="keyword">const</span> io = socketIo(server)</div><div class="line">io.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</div><div class="line">  socket.on(<span class="string">'sendmsg'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> &#123;<span class="keyword">from</span>,to,msg&#125; = data</div><div class="line">    <span class="keyword">let</span> chatid = [<span class="keyword">from</span>,to].sort().join(<span class="string">'_'</span>)</div><div class="line">    Chat.create(&#123;chatid,<span class="keyword">from</span>,to,<span class="attr">content</span>:msg&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e,d</span>)</span>&#123;</div><div class="line">      io.emit(<span class="string">'recvmsg'</span>,<span class="built_in">Object</span>.assign(&#123;&#125;,d._doc))</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// console.log(data)</span></div><div class="line">    <span class="comment">// //广播给全局</span></div><div class="line">    <span class="comment">// io.emit('recvmsg',data)</span></div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.use(cookieParser())</div><div class="line">app.use(bodyParser.json())</div><div class="line">app.use(<span class="string">'/user'</span>,userRouter)</div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(req.url.startsWith(<span class="string">'/user/'</span>) || req.url.startsWith(<span class="string">'/static/'</span>))&#123;</div><div class="line">    <span class="keyword">return</span> next()</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果访问url根路径是user或者static就返回打包后的主页面</span></div><div class="line">  <span class="keyword">return</span> res.sendFile(path.resolve(<span class="string">'build/index.html'</span>))</div><div class="line">&#125;)</div><div class="line"><span class="comment">//映射build文件路径，项目上要使用</span></div><div class="line">app.use(<span class="string">'/'</span>,express.static(path.resolve(<span class="string">'build'</span>)))</div><div class="line"></div><div class="line"></div><div class="line">server.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'开启成功'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>主要看上面的<code>app.use(&#39;/&#39;,express.static(path.resolve(&#39;build&#39;)))</code>和<code>res.sendFile(path.resolve(&#39;build/index.html&#39;))</code>这两段代码。</li>
<li>他们把打包后的主页放入服务端代码中返回给客户端。</li>
<li>因为上面我用了<code>import</code>代码，所以我们在开发环境中需要用到<code>babel-cli</code>里的<code>babel-node</code>来编译。</li>
<li>安装<code>npm --registry https://registry.npm.taobao.org</code> i babel-cli -S`，大家如果觉得这样切换源麻烦，可以下个<a href="https://www.npmjs.com/package/nrm" target="_blank" rel="external">nrm</a>，360度无死角切换各种源，好用！</li>
<li>我们需要修改<code>package.json</code>的启动服务器的<code>npm scripts</code>。<code>&quot;server&quot;: &quot;NODE_ENV=test nodemon --exec babel-node server/server.js&quot;</code></li>
<li><code>cross-env</code>跨平台设置node环境变量的插件。</li>
<li>nodemon和supervisor一样是watch服务端文件，只要一改变就会重新运行，相当于<code>热重载</code>。nodemon<code>更轻量</code></li>
<li>最后我们来跑一下<code>npm run server</code>,就能看到服务端跑起来了。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/1644f684849a3656?w=562&amp;h=994&amp;f=jpeg&amp;s=58584" alt=""></p>
<h2 id="ReactDOMServer-renderToString-ReactDOMServer-renderToNodeStream"><a href="#ReactDOMServer-renderToString-ReactDOMServer-renderToNodeStream" class="headerlink" title="ReactDOMServer.renderToString/ReactDOMServer.renderToNodeStream"></a>ReactDOMServer.renderToString/ReactDOMServer.renderToNodeStream</h2><ul>
<li>这里我们先讲一下在<code>浏览器中</code>，<code>React.createElement</code>把React的类进行<code>实例化</code>，实例化后的组件可以进行<code>mount</code>，最后通过R<code>eact.render</code>渲染到我们的客户端浏览器界面。</li>
<li>而在服务器中我们可以通过 <code>renderToString</code>或者<code>renderToNodeStream</code>方法把React实例化的组件，直接渲染生成html标签。那么这俩个有什么区别呢？</li>
<li><code>renderToNodeStream</code>是React 16最新发布的东西，它支持直接渲染到节点流。渲染到流可以减少你的内容的第一个字节<code>（TTFB）</code>的时间，在文档的下一部分生成之前，将文档的开头至结尾发送到浏览器。 当内容从服务器流式传输时，浏览器将开始解析HTML文档。速度是renderToString的<code>三倍</code>，所以我们在这里使用<code>renderToNodeStream</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123;renderToStaticMarkup,renderToNodeStream&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> &#123;StaticRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  createStore,</div><div class="line">  applyMiddleware,</div><div class="line">  <span class="comment">//组合函数用的</span></div><div class="line">  compose</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/App'</span></div><div class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'../src/reducer'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> userRouter <span class="keyword">from</span> <span class="string">'./routes/user'</span></div><div class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'body-parser'</span></div><div class="line"><span class="keyword">import</span> cookieParser <span class="keyword">from</span> <span class="string">'cookie-parser'</span></div><div class="line"><span class="keyword">import</span> model <span class="keyword">from</span> <span class="string">'./model'</span></div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></div><div class="line"><span class="keyword">import</span> https <span class="keyword">from</span> <span class="string">'http'</span></div><div class="line"><span class="keyword">import</span> socketIo <span class="keyword">from</span> <span class="string">'socket.io'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Chat = model.getModel(<span class="string">'chat'</span>)</div><div class="line"><span class="comment">//新建app</span></div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"></div><div class="line"><span class="comment">//work with express</span></div><div class="line"><span class="keyword">const</span> server = https.Server(app)</div><div class="line"><span class="keyword">const</span> io = socketIo(server)</div><div class="line">io.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</div><div class="line">  socket.on(<span class="string">'sendmsg'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> &#123;<span class="keyword">from</span>,to,msg&#125; = data</div><div class="line">    <span class="keyword">let</span> chatid = [<span class="keyword">from</span>,to].sort().join(<span class="string">'_'</span>)</div><div class="line">    Chat.create(&#123;chatid,<span class="keyword">from</span>,to,<span class="attr">content</span>:msg&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e,d</span>)</span>&#123;</div><div class="line">      io.emit(<span class="string">'recvmsg'</span>,<span class="built_in">Object</span>.assign(&#123;&#125;,d._doc))</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// console.log(data)</span></div><div class="line">    <span class="comment">// //广播给全局</span></div><div class="line">    <span class="comment">// io.emit('recvmsg',data)</span></div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">app.use(cookieParser())</div><div class="line">app.use(bodyParser.json())</div><div class="line">app.use(<span class="string">'/user'</span>,userRouter)</div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(req.url.startsWith(<span class="string">'/user/'</span>) || req.url.startsWith(<span class="string">'/static/'</span>))&#123;</div><div class="line">    <span class="keyword">return</span> next()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> store = createStore(reducers,compose(</div><div class="line">    applyMiddleware(thunk)</div><div class="line">  ))</div><div class="line">  <span class="comment">//这个 context 对象包含了渲染的结果</span></div><div class="line">  <span class="keyword">let</span> context = &#123;&#125;</div><div class="line">  <span class="keyword">const</span> root = (&lt;Provider store=&#123;store&#125;&gt;</div><div class="line">                    &lt;StaticRouter</div><div class="line">                      location=&#123;req.url&#125;</div><div class="line">                      context=&#123;context&#125;</div><div class="line">                      &gt;</div><div class="line">                        &lt;App&gt;&lt;/App&gt;</div><div class="line">                    &lt;/StaticRouter&gt;</div><div class="line">                &lt;/Provider&gt;)</div><div class="line">  <span class="keyword">const</span> markupStream = renderToNodeStream(root)</div><div class="line">  markupStream.pipe(res,&#123;<span class="attr">end</span>:<span class="literal">false</span>&#125;)</div><div class="line">  markupStream.on(<span class="string">'end'</span>,()=&gt;&#123;</div><div class="line">    res.end()</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//映射build文件路径，项目上要使用</span></div><div class="line">app.use(<span class="string">'/'</span>,express.static(path.resolve(<span class="string">'build'</span>)))</div><div class="line"></div><div class="line"></div><div class="line">server.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'开启成功'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>此时将服务端renderToNodeStream后的代码返回给前端，但是这个时候还是不行，我们执行一下<code>npm run server</code>，可以看到报错了。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/1644f96e7d492e64?w=1138&amp;h=572&amp;f=jpeg&amp;s=170355" alt=""></p>
<h2 id="css-modules-require-hook-asset-require-hook"><a href="#css-modules-require-hook-asset-require-hook" class="headerlink" title="css-modules-require-hook/asset-require-hook"></a>css-modules-require-hook/asset-require-hook</h2><h3 id="css-modules-require-hook"><a href="#css-modules-require-hook" class="headerlink" title="css-modules-require-hook"></a>css-modules-require-hook</h3><ul>
<li>因为服务端此时<code>不认识</code>我们的css文件，我们需要安装一个包，来让服务端处理css文件。</li>
<li><code>npm i css-modules-require-hook -S</code>安装在生产环境下。</li>
<li>在项目根目录创建一个<code>crmh.conf.js</code>钩子文件进行配置,看下图。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/1644f9c1c32b5e66?w=306&amp;h=886&amp;f=jpeg&amp;s=56016" alt=""></p>
<p><strong>写入代码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// css-modules-require-hook </span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">generateScopedName</span>: <span class="string">'[name]__[local]___[hash:base64:5]'</span>,</div><div class="line">  <span class="comment">//下面的代码在本项目中暂时用不到，但是以下配置在我另一个项目中有用到，我来讲一下他的配置</span></div><div class="line">  <span class="comment">//扩展名</span></div><div class="line">  <span class="comment">//extensions: ['.scss','.css'],</span></div><div class="line">  <span class="comment">//钩子，这里主要做一些预处理的scss或者less文件</span></div><div class="line">  <span class="comment">//preprocessCss: (data, filename) =&gt;</span></div><div class="line">  <span class="comment">//    require('node-sass').renderSync(&#123;</span></div><div class="line">  <span class="comment">//        data,</span></div><div class="line">  <span class="comment">//        file: filename</span></div><div class="line">  <span class="comment">//    &#125;).css,</span></div><div class="line">  <span class="comment">//是否导出css类名，主要用于CSSModule</span></div><div class="line">  <span class="comment">//camelCase: true,</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>修改我们的<code>server.js</code>文件,添加<code>import csshook from &#39;css-modules-require-hook/preset&#39;</code>,<strong>注意⚠️</strong>，<code>一定要把这行代码放在导入App模块之前</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> csshook <span class="keyword">from</span> <span class="string">'css-modules-require-hook/preset'</span></div><div class="line"><span class="comment">//我们的首页入口</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/App'</span></div></pre></td></tr></table></figure>
<p><strong>此时在运行<code>server.js</code>，会发现又报了个错。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/1644fb97d437ed71?w=1130&amp;h=260&amp;f=jpeg&amp;s=46396" alt=""></p>
<h3 id="asset-require-hook"><a href="#asset-require-hook" class="headerlink" title="asset-require-hook"></a>asset-require-hook</h3><ul>
<li>这个错误是因为服务端没有处理前端代码需要的图片</li>
<li>需要安装<code>npm i asset-require-hook -S</code>，这个插件用来让服务端处理图片,<strong>注意⚠️</strong>，<code>前提是客户端代码，引用图片都需要require</code></li>
<li>在<code>server.js</code>写入代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//解决图片问题，客户端代码引用图片都需要require</span></div><div class="line"><span class="keyword">import</span> assethook <span class="keyword">from</span> <span class="string">'asset-require-hook'</span></div><div class="line">assethook(&#123;</div><div class="line">  <span class="attr">extensions</span>:[<span class="string">'png'</span>],</div><div class="line">  <span class="comment">//图片大小下于10000的图片会直接base64编码</span></div><div class="line">  limit: <span class="number">10000</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>运行之后发现又报错了，这个很简单，因为我们只有image的引用名字，却<code>没有地址</code></strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/1644fc3965492fef?w=1952&amp;h=996&amp;f=jpeg&amp;s=200831" alt=""></p>
<ul>
<li>所以此时要在外面加个壳，把之前build之后的<code>静态js、css文件</code>引入进去，添加html、head这些标签。来看完整代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></div><div class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123;renderToString,renderToStaticMarkup,renderToNodeStream&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span></div><div class="line"></div><div class="line"><span class="comment">//引入css文件和js文件</span></div><div class="line"><span class="keyword">import</span> staticPath <span class="keyword">from</span> <span class="string">'../build/asset-manifest.json'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> &#123;StaticRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  createStore,</div><div class="line">  applyMiddleware,</div><div class="line">  <span class="comment">//组合函数用的</span></div><div class="line">  compose</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="comment">//解决服务端渲染的图片问题 必须放在App之前</span></div><div class="line"><span class="keyword">import</span> csshook <span class="keyword">from</span> <span class="string">'css-modules-require-hook/preset'</span></div><div class="line"><span class="comment">//解决图片问题，需要require</span></div><div class="line"><span class="keyword">import</span> assethook <span class="keyword">from</span> <span class="string">'asset-require-hook'</span></div><div class="line">assethook(&#123;</div><div class="line">  <span class="attr">extensions</span>:[<span class="string">'png'</span>],</div><div class="line">  <span class="attr">limit</span>: <span class="number">10000</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/App'</span></div><div class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'../src/reducer'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> userRouter <span class="keyword">from</span> <span class="string">'./routes/user'</span></div><div class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'body-parser'</span></div><div class="line"><span class="keyword">import</span> cookieParser <span class="keyword">from</span> <span class="string">'cookie-parser'</span></div><div class="line"><span class="keyword">import</span> model <span class="keyword">from</span> <span class="string">'./model'</span></div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></div><div class="line"><span class="keyword">import</span> https <span class="keyword">from</span> <span class="string">'http'</span></div><div class="line"><span class="keyword">import</span> socketIo <span class="keyword">from</span> <span class="string">'socket.io'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Chat = model.getModel(<span class="string">'chat'</span>)</div><div class="line"><span class="comment">//新建app</span></div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"></div><div class="line"><span class="comment">//work with express</span></div><div class="line"><span class="keyword">const</span> server = https.Server(app)</div><div class="line"><span class="keyword">const</span> io = socketIo(server)</div><div class="line">io.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</div><div class="line">  socket.on(<span class="string">'sendmsg'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> &#123;<span class="keyword">from</span>,to,msg&#125; = data</div><div class="line">    <span class="keyword">let</span> chatid = [<span class="keyword">from</span>,to].sort().join(<span class="string">'_'</span>)</div><div class="line">    Chat.create(&#123;chatid,<span class="keyword">from</span>,to,<span class="attr">content</span>:msg&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e,d</span>)</span>&#123;</div><div class="line">      io.emit(<span class="string">'recvmsg'</span>,<span class="built_in">Object</span>.assign(&#123;&#125;,d._doc))</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// console.log(data)</span></div><div class="line">    <span class="comment">// //广播给全局</span></div><div class="line">    <span class="comment">// io.emit('recvmsg',data)</span></div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">app.use(cookieParser())</div><div class="line">app.use(bodyParser.json())</div><div class="line">app.use(<span class="string">'/user'</span>,userRouter)</div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(req.url.startsWith(<span class="string">'/user/'</span>) || req.url.startsWith(<span class="string">'/static/'</span>))&#123;</div><div class="line">    <span class="keyword">return</span> next()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> store = createStore(reducers,compose(</div><div class="line">    applyMiddleware(thunk)</div><div class="line">  ))</div><div class="line">  <span class="keyword">const</span> obj = &#123;</div><div class="line">    <span class="string">'/msg'</span>:<span class="string">'聊天消息列表'</span>,</div><div class="line">    <span class="string">'/me'</span>:<span class="string">'个人中心列表'</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//这个 context 对象包含了渲染的结果</span></div><div class="line">  <span class="keyword">let</span> context = &#123;&#125;</div><div class="line">  res.write(<span class="string">`&lt;!DOCTYPE html&gt;</span></div><div class="line">  &lt;html lang="en"&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">      &lt;meta charset="utf-8"&gt;</div><div class="line">      &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt;</div><div class="line">      &lt;meta name="theme-color" content="#000000"&gt;</div><div class="line">      &lt;meta name="description" content="<span class="subst">$&#123;obj[req.url]&#125;</span>"/&gt;</div><div class="line">      &lt;meta name="keywords" content="SSR"&gt;</div><div class="line">      &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json"&gt;</div><div class="line">      &lt;link rel="stylesheet" href="/<span class="subst">$&#123;staticPath[<span class="string">'main.css'</span>]&#125;</span>"&gt;</div><div class="line">      &lt;title&gt;React App&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">      &lt;noscript&gt;</div><div class="line">        You need to enable JavaScript to run this app.</div><div class="line">      &lt;/noscript&gt;</div><div class="line">      &lt;div id="root"&gt;`)</div><div class="line">  <span class="keyword">const</span> root = (&lt;Provider store=&#123;store&#125;&gt;</div><div class="line">                    &lt;StaticRouter</div><div class="line">                      location=&#123;req.url&#125;</div><div class="line">                      context=&#123;context&#125;</div><div class="line">                      &gt;</div><div class="line">                        &lt;App&gt;&lt;/App&gt;</div><div class="line">                    &lt;/StaticRouter&gt;</div><div class="line">                &lt;/Provider&gt;)</div><div class="line">  <span class="keyword">const</span> markupStream = renderToNodeStream(root)</div><div class="line">  markupStream.pipe(res,&#123;<span class="attr">end</span>:<span class="literal">false</span>&#125;)</div><div class="line">  markupStream.on(<span class="string">'end'</span>,()=&gt;&#123;</div><div class="line">    res.write(<span class="string">`&lt;/div&gt;</span></div><div class="line">          &lt;script src="/<span class="subst">$&#123;staticPath[<span class="string">'main.js'</span>]&#125;</span>"&gt;&lt;/script&gt;</div><div class="line">        &lt;/body&gt;</div><div class="line">      &lt;/html&gt;`)</div><div class="line">    res.end()</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//映射build文件路径，项目上要使用</span></div><div class="line">app.use(<span class="string">'/'</span>,express.static(path.resolve(<span class="string">'build'</span>)))</div><div class="line"></div><div class="line"></div><div class="line">server.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'开启成功'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>这个时候我们可以在html标签里加上SEO的meta<code>&lt;meta name=&quot;keywords&quot; content=&quot;SSR&quot;&gt;</code></li>
<li>最后还要把客户端的<code>index.js</code>文件中的渲染机制改成<code>hydrate</code>，不用<code>render</code>，他们之间的区别可以看这个（传送门☞<a href="https://www.colabug.com/2385573.html" target="_blank" rel="external">render !== hydrate</a>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ReactDOM.hydrate(</div><div class="line">    (&lt;Provider store=&#123;store&#125;&gt;</div><div class="line">        &lt;BrowserRouter&gt;</div><div class="line">            &lt;App&gt;&lt;/App&gt;</div><div class="line">        &lt;/BrowserRouter&gt;</div><div class="line">    &lt;/Provider&gt;),</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<p><strong>到此为止我们开发模式下的SSR搭建完毕，接下来生产模式的坑我来讲一下。</strong></p>
<h1 id="生产环境SSR准备"><a href="#生产环境SSR准备" class="headerlink" title="生产环境SSR准备"></a>生产环境SSR准备</h1><blockquote>
<p>我们上面所讲的只是<strong>开发模式下的SSR</strong>，因为我们是通过<code>babel-node</code>编译<code>jsx和es6代码</code>的，只要一脱离<code>babel-node</code>就会全错,所以我们需要webpack打包服务端代码</p>
</blockquote>
<p><strong>我们需要创建一个<code>webserver.config.js</code>，用来打包server的代码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>),</div><div class="line">    fs = <span class="built_in">require</span>(<span class="string">'fs'</span>),</div><div class="line">    webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>),</div><div class="line">    autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>),</div><div class="line">    HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>),</div><div class="line">    ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</div><div class="line">    cssFilename = <span class="string">'static/css/[name].[contenthash:8].css'</span>;</div><div class="line">    CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</div><div class="line">    nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>);</div><div class="line"></div><div class="line">serverConfig = &#123;</div><div class="line">  <span class="attr">context</span>: path.resolve(__dirname, <span class="string">'..'</span>),</div><div class="line">  <span class="attr">entry</span>: &#123;<span class="attr">server</span>: <span class="string">'./server/server'</span>&#125;,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">      <span class="attr">libraryTarget</span>: <span class="string">'commonjs2'</span>,</div><div class="line">      <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'../build/server'</span>),</div><div class="line">      <span class="attr">filename</span>: <span class="string">'static/js/[name].js'</span>,</div><div class="line">      <span class="attr">chunkFilename</span>: <span class="string">'static/js/chunk.[name].js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// target: 'node' 指明构建出的代码是要运行在node环境里.</span></div><div class="line">  <span class="comment">// 不把 Node.js 内置的模块打包进输出文件中，例如 fs net 模块等</span></div><div class="line">  target: <span class="string">'node'</span>,</div><div class="line">  <span class="comment">//指定在node环境中是否要这些模块 </span></div><div class="line">  node: &#123;</div><div class="line">      <span class="attr">__filename</span>: <span class="literal">true</span>,</div><div class="line">      <span class="attr">__dirname</span>: <span class="literal">true</span>,</div><div class="line">      <span class="comment">// module:true</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">      <span class="attr">loaders</span>: [&#123;</div><div class="line">          <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">          <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</div><div class="line">          <span class="attr">loader</span>: <span class="string">'babel-loader?cacheDirectory=true'</span>,</div><div class="line">          <span class="attr">options</span>: &#123;</div><div class="line">              <span class="attr">presets</span>: [<span class="string">'es2015'</span>, <span class="string">'react-app'</span>, <span class="string">'stage-0'</span>],</div><div class="line">              <span class="attr">plugins</span>: [<span class="string">'add-module-exports'</span>,</div><div class="line">              [</div><div class="line">                <span class="string">"import"</span>,</div><div class="line">                &#123;</div><div class="line">                  <span class="string">"libraryName"</span>: <span class="string">"antd-mobile"</span>,</div><div class="line">                  <span class="string">"style"</span>: <span class="string">"css"</span></div><div class="line">                &#125;</div><div class="line">              ],<span class="string">"transform-decorators-legacy"</span>]</div><div class="line">          &#125;,</div><div class="line">      &#125;,&#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</div><div class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules|antd-mobile\.css/</span>,            </div><div class="line">        <span class="attr">loader</span>: ExtractTextPlugin.extract(</div><div class="line">          <span class="built_in">Object</span>.assign(</div><div class="line">            &#123;</div><div class="line">              <span class="attr">fallback</span>: &#123;</div><div class="line">                <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'style-loader'</span>),</div><div class="line">                <span class="attr">options</span>: &#123;</div><div class="line">                  <span class="attr">hmr</span>: <span class="literal">false</span>,</div><div class="line">                &#125;,</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">use</span>: [</div><div class="line">                &#123;</div><div class="line">                  <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'css-loader'</span>),</div><div class="line">                  <span class="attr">options</span>: &#123;</div><div class="line">                    <span class="attr">importLoaders</span>: <span class="number">1</span>,</div><div class="line">                    <span class="attr">minimize</span>: <span class="literal">true</span>,</div><div class="line">                    <span class="attr">modules</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">localIdentName</span>:<span class="string">"[name]-[local]-[hash:base64:8]"</span>,</div><div class="line">                    <span class="comment">// sourceMap: shouldUseSourceMap,</span></div><div class="line">                  &#125;,</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                  <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'postcss-loader'</span>),</div><div class="line">                  <span class="attr">options</span>: &#123;</div><div class="line">                    <span class="attr">ident</span>: <span class="string">'postcss'</span>,</div><div class="line">                    <span class="attr">plugins</span>: <span class="function"><span class="params">()</span> =&gt;</span> [</div><div class="line">                      <span class="built_in">require</span>(<span class="string">'postcss-flexbugs-fixes'</span>),</div><div class="line">                      autoprefixer(&#123;</div><div class="line">                        <span class="attr">browsers</span>: [</div><div class="line">                          <span class="string">'&gt;1%'</span>,</div><div class="line">                          <span class="string">'last 4 versions'</span>,</div><div class="line">                          <span class="string">'Firefox ESR'</span>,</div><div class="line">                          <span class="string">'not ie &lt; 9'</span>, <span class="comment">// React doesn't support IE8 anyway</span></div><div class="line">                        ],</div><div class="line">                        <span class="attr">flexbox</span>: <span class="string">'no-2009'</span>,</div><div class="line">                      &#125;),</div><div class="line">                    ],</div><div class="line">                  &#125;,</div><div class="line">                &#125;,</div><div class="line">              ],</div><div class="line">            &#125;,</div><div class="line">          )</div><div class="line">        ),</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</div><div class="line">        <span class="attr">include</span>: <span class="regexp">/node_modules|antd-mobile\.css/</span>,</div><div class="line">        <span class="attr">use</span>: ExtractTextPlugin.extract(&#123;</div><div class="line">          <span class="attr">fallback</span>: <span class="built_in">require</span>.resolve(<span class="string">'style-loader'</span>),</div><div class="line">          <span class="attr">use</span>: [&#123;</div><div class="line">            <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'css-loader'</span>),</div><div class="line">            <span class="attr">options</span>: &#123;</div><div class="line">              <span class="attr">modules</span>:<span class="literal">false</span></div><div class="line">            &#125;,</div><div class="line">          &#125;]</div><div class="line">        &#125;)</div><div class="line">      &#125;, &#123;</div><div class="line">          <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif|webp)$/</span>,</div><div class="line">          <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'url-loader'</span>),</div><div class="line">            <span class="attr">options</span>: &#123;</div><div class="line">              <span class="attr">limit</span>: <span class="number">10000</span>,</div><div class="line">              <span class="attr">name</span>: <span class="string">'static/media/[name].[hash:8].[ext]'</span>,</div><div class="line">            &#125;,</div><div class="line">      &#125;, &#123;</div><div class="line">          <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,</div><div class="line">          <span class="attr">loader</span>: <span class="string">'json-loader'</span>,</div><div class="line">      &#125;]</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 不把 node_modules 目录下的第三方模块打包进输出文件中,</span></div><div class="line">  externals: [nodeExternals()],</div><div class="line">  <span class="attr">resolve</span>: &#123;<span class="attr">extensions</span>: [<span class="string">'*'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.scss'</span>]&#125;,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">      <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'../build/server'</span>]),</div><div class="line">      <span class="keyword">new</span> webpack.optimize.OccurrenceOrderPlugin(),</div><div class="line">      <span class="comment">//把第三方库从js文件中分离出来</span></div><div class="line">      <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">        <span class="comment">//抽离相应chunk的共同node_module</span></div><div class="line">        minChunks(<span class="built_in">module</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="regexp">/node_modules/</span>.test(<span class="built_in">module</span>.context);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//从要抽离的chunk中的子chunk抽离相同的模块</span></div><div class="line">        children: <span class="literal">true</span>,</div><div class="line">        <span class="comment">//是否异步抽离公共模块，参数boolean||string</span></div><div class="line">        <span class="keyword">async</span>: <span class="literal">false</span>,</div><div class="line">      &#125;),</div><div class="line">      <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">        <span class="attr">children</span>:<span class="literal">true</span>,</div><div class="line">        <span class="comment">//若参数是string即为抽离出来后的文件名</span></div><div class="line">        <span class="keyword">async</span>: <span class="string">'shine'</span>,</div><div class="line">        <span class="comment">//最小打包的文件模块数，即要抽离的公共模块中的公共数，比如三个chunk只有1个用到就不算公共的            </span></div><div class="line">        <span class="comment">//若为Infinity，则会把webpack runtime的代码放入其中（webpack 不再自动抽离公共模块）</span></div><div class="line">        minChunks:<span class="number">2</span></div><div class="line">      &#125;),</div><div class="line">      <span class="comment">//压缩</span></div><div class="line">      <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</div><div class="line">      <span class="comment">//分离css文件</span></div><div class="line">      <span class="keyword">new</span> ExtractTextPlugin(&#123;</div><div class="line">        <span class="attr">filename</span>: cssFilename,</div><div class="line">      &#125;),</div><div class="line">      <span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/^\.\/locale$/</span>, /moment$/),</div><div class="line">  ],</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports =  serverConfig</div></pre></td></tr></table></figure>
<p><strong>重点⚠️</strong></p>
<ul>
<li>指定target，打包出来的代码运行在哪里</li>
<li>指定externals不要把<code>node_modules</code>包打包，因为此项目运行在服务端，直接用外面的<code>node_modules</code>就行。不然打包后会很大。</li>
<li>loader中用babel对js的处理</li>
</ul>
<blockquote>
<p>ok，现在来我们改一下package.json的<code>npm scripts</code>，添加一个<code>packServer</code>,顺便改一下<code>build</code>的scripts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"clean"</span>: <span class="string">"rm -rf build/"</span>,</div><div class="line">  <span class="string">"dev"</span>: <span class="string">"node scripts/start.js"</span>,</div><div class="line">  <span class="string">"start"</span>: <span class="string">"cross-env NODE_ENV=development npm run server &amp; npm run dev"</span>,</div><div class="line">  <span class="string">"build"</span>: <span class="string">"npm run clean &amp;&amp; node scripts/build.js &amp;&amp; npm run packServer"</span>,</div><div class="line">  <span class="string">"test"</span>: <span class="string">"nodemon scripts/test.js --env=jsdom"</span>,</div><div class="line">  <span class="string">"server"</span>: <span class="string">"cross-env NODE_ENV=test nodemon --exec babel-node server/server.js"</span>,</div><div class="line">  <span class="string">"gulp"</span>: <span class="string">"cross-env NODE_ENV=production gulp"</span>,</div><div class="line">  <span class="string">"packServer"</span>: <span class="string">"cross-env NODE_ENV=production webpack --config ./config/webserver.config.js"</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<ul>
<li><code>packServer</code>指定了生产环境，这在之后会用到。</li>
<li><code>build</code>是先clean掉build文件夹，在去打包<code>客户端的代码</code>，打包完之后再去打包<code>服务端的代码</code></li>
</ul>
<p><strong>那么到这里为止我们差不多可以自己试试了</strong></p>
<ul>
<li>先<code>npm run build</code>,会生成打包后的build文件夹，里面包含了我们的<code>服务端和客户端代码</code></li>
<li>找到打包后的node文件运行它，在<code>build/server/static/js</code>目录下，可直接node文件启动。这就解决了我们生产环境下的问题。</li>
</ul>
<h1 id="pm2，服务器自动部署"><a href="#pm2，服务器自动部署" class="headerlink" title="pm2，服务器自动部署"></a>pm2，服务器自动部署</h1><p><strong>现在我们要把我们的项目部署到服务器上，并用pm2守护进程。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/25/164d2256089a8fcf?w=224&amp;h=224&amp;f=jpeg&amp;s=5358" alt=""></p>
<ul>
<li>首先我们得有一台云服务器，这里我是在<a href="https://www.aliyun.com/?spm=5176.11034346.765261.1.smqqWK" target="_blank" rel="external">阿里云</a>买的一台<code>ubuntu 14.04</code></li>
<li>需要一个已经备案后的域名，域名也可以在<a href="https://www.aliyun.com/?spm=5176.11034346.765261.1.smqqWK" target="_blank" rel="external">阿里云</a>买。当然也可以不用，可以直接服务器地址访问。</li>
<li>ok让我们开始吧。</li>
</ul>
<h2 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h2><ul>
<li>在部署到服务器之前我们代码中还有些东西需要修改,修改mongod的连接地址.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> env = process.env.NODE_ENV || <span class="string">'development'</span></div><div class="line"><span class="comment">//当生产环境时，需要改变mongodb的连接端口，根据你服务器的mongodb端口来，我这里是19999</span></div><div class="line"><span class="keyword">const</span> BASE_URL = env == <span class="string">'development'</span>?<span class="string">"mongodb://localhost:27017/chat"</span>:<span class="string">"mongodb://127.0.0.1:19999/chat"</span>;</div></pre></td></tr></table></figure>
<ul>
<li>修改客户端<code>socket.io</code>的链接地址<code>const socket = io(&#39;ws://host:port&#39;)</code>，改成你自己的服务器地址和端口号</li>
<li>我们需要将自己的项目上传至<a href="https://gitee.com/" target="_blank" rel="external">码云</a>。这里我使用<a href="https://gitee.com/" target="_blank" rel="external">码云</a>，主要是因为<a href="https://gitee.com/" target="_blank" rel="external">码云</a>的私仓是免费的。</li>
<li>我们需要进入服务器的<code>ssh目录</code>下复制<code>id_rsa.pub</code>里的公钥放在码云的<code>ssh公钥</code>中,可进入<code>设置</code>,具体看图</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/164500836f1ab210?w=904&amp;h=1232&amp;f=jpeg&amp;s=85014" alt=""></p>
<ul>
<li>我们也要把自己电脑上的<code>ssh公钥</code>在码云中设置，我这里是mac，在自己的用户目录下，可以按<code>cmd+shift+.</code>看隐藏文件（如果你设置过了，这一步就不要了）。</li>
<li>服务器安装git,mongodb,pm2,nginx<code>（如果服务器已经安装过了，就不需要了）</code></li>
<li>需要开启mongodb</li>
<li>我们在项目根目录新建一个<code>ecosystem.json</code>文件，这个文件是pm2的配置文件，具体的我就不说了，大家如果感兴趣可以去官网看看，（传送门☞<a href="http://pm2.keymetrics.io/" target="_blank" rel="external">pm2官网</a>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"apps"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="comment">//应用名称</span></div><div class="line">      <span class="string">"name"</span>: <span class="string">"chat"</span>,</div><div class="line">      <span class="comment">//执行文件的路径</span></div><div class="line">      <span class="string">"script"</span>: <span class="string">"./build/server/static/js/server.js"</span>,</div><div class="line">      <span class="string">"env"</span>: &#123;</div><div class="line">        <span class="string">"COMMON_VARIABLE"</span>: <span class="string">"true"</span></div><div class="line">      &#125;,</div><div class="line">      <span class="string">"env_production"</span>: &#123;</div><div class="line">        <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  <span class="string">"deploy"</span>: &#123;</div><div class="line">    <span class="string">"production"</span>: &#123;</div><div class="line">      <span class="comment">//服务器用户</span></div><div class="line">      <span class="string">"user"</span>: <span class="string">"xxx"</span>,</div><div class="line">      <span class="comment">//服务器地址</span></div><div class="line">      <span class="string">"host"</span>: [<span class="string">"xxx"</span>],</div><div class="line">      <span class="comment">//服务器端口</span></div><div class="line">      <span class="string">"port"</span>: <span class="string">"xxx"</span>,</div><div class="line">      <span class="string">"ref"</span>: <span class="string">"origin/master"</span>,</div><div class="line">      <span class="comment">//这里填你的项目git ssh</span></div><div class="line">      <span class="string">"repo"</span>: <span class="string">"xxx"</span>,</div><div class="line">      <span class="comment">//服务器的存放项目路径</span></div><div class="line">      <span class="string">"path"</span>: <span class="string">"/www/chat/production"</span>,</div><div class="line">      <span class="string">"ssh_options"</span>: <span class="string">"StrictHostKeyChecking=no"</span>,</div><div class="line">      <span class="comment">//钩子</span></div><div class="line">      <span class="string">"post-deploy"</span>: <span class="string">"npm --registry https://registry.npm.taobao.org install &amp;&amp; npm run build &amp;&amp; pm2 startOrRestart ecosystem.json --env production"</span>,</div><div class="line">      <span class="string">"env"</span>: &#123;</div><div class="line">        <span class="comment">//环境</span></div><div class="line">        <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在服务器新建项目目录新建<code>/www/chat/</code>文件夹。</li>
<li>在本地电脑执行 <code>pm2 deploy ecosystem.json production setup</code></li>
<li>这里大家肯定会报错，这是我故意埋的坑，因为<code>chat</code>文件夹的权限不够，需要进入服务器的<code>www</code>文件夹，执行<code>sudo chmod 777 chat</code>。</li>
<li>进入服务器的.bashrc文件，注视掉上面的几行代码</li>
<li><code>source .bashrc</code>重新载入一下<code>.bashrc</code>文件</li>
<li>开启pm2服务 pm2 deploy ecosystem.json production</li>
<li>这里可能有的人会报错，主要原因是本地电脑的pm2的权限问题，需要找到pm2文件夹，<code>chmod 666 pm2</code></li>
<li>如果上述问题都解决了最后会如图所示</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/164504fa410ade72?w=1124&amp;h=824&amp;f=jpeg&amp;s=203875" alt=""></p>
<ul>
<li>最后我们可以进入服务器，<code>pm2 list</code>,看到成功跑起来了</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/164505303ec8211b?w=848&amp;h=210&amp;f=jpeg&amp;s=42625" alt=""></p>
<ul>
<li>如果应用在不断的<code>重启</code>，说明开启<code>失败</code>了，需要<code>pm2 logs</code>看看日志</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/30/16450529b006f32f?w=798&amp;h=544&amp;f=jpeg&amp;s=51991" alt=""></p>
<ul>
<li>我们可以访问<code>服务器地址:8088</code>,并看到应用跑起来了</li>
</ul>
<h2 id="域名代理"><a href="#域名代理" class="headerlink" title="域名代理"></a>域名代理</h2><ul>
<li>我们进入阿里云控制台解析自己的域名（传送门☞<a href="https://dc.console.aliyun.com/" target="_blank" rel="external">阿里云</a>）</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c7b38d024b452?w=2124&amp;h=528&amp;f=jpeg&amp;s=131660" alt=""></p>
<ul>
<li>添加一条记录</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c7b7a31fbab82?w=1322&amp;h=1016&amp;f=jpeg&amp;s=100685" alt=""></p>
<ul>
<li>回到服务器，我们修改nginx配置文件，通过反向代理，让我们通过域名也可以访问他</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">upstream</span> chat &#123;</div><div class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8088</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="section">server</span> &#123;</div><div class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</div><div class="line">  <span class="attribute">server_name</span> www.webman.vip;</div><div class="line"></div><div class="line">  <span class="attribute">location</span> / &#123;</div><div class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</div><div class="line">    <span class="attribute">proxy_set_header</span> X-Forward-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</div><div class="line">    <span class="attribute">proxy_set_header</span> X-Nginx-Proxy <span class="literal">true</span>;</div><div class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</div><div class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">"Upgrade"</span>;</div><div class="line"></div><div class="line">    <span class="attribute">proxy_pass</span> http://chat;</div><div class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment"># 静态文件地址</span></div><div class="line">  <span class="attribute">location</span> <span class="regexp">~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt)</span>&#123;</div><div class="line">    <span class="attribute">root</span> /www/website/production/current/build;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>在服务器执行<code>sudo nginx -s reload</code>，重启nginx。此时我们就可以通过我们的域名地址访问到我们的应用了。</p>
</li>
<li><p>这里可能访问会<code>404</code>，这个时候我们需要看一下我们服务器的防火墙，<code>sudo vi /etc/iptables.up.rules</code>,修改mongodb的对外端口，并且重启防火墙<code>sudo iptables-restore &lt; /etc/iptables.up.rules</code></p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-A INPUT <span class="_">-s</span> 127.0.0.1 -p tcp --destination-port 8088 -m state --state NEW,ESTABLISHED -j ACCEPT</div><div class="line">-A OUTPUT <span class="_">-d</span> 127.0.0.1 -p tcp --source-port 8088 -m state --state ESTABLISHED -j ACCEPT</div></pre></td></tr></table></figure>
<ul>
<li>查看阿里云控制台的安全组是否开了对应的端口</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c7d6b7f85a503?w=1198&amp;h=1334&amp;f=jpeg&amp;s=120070" alt=""></p>
<ul>
<li><p>最后最后！！！，终于成功了。可以点击链接查看一下。    <a href="https://www.webman.vip" target="_blank" rel="external">走你！</a></p>
</li>
<li><p>当然下次如果你想直接更新项目，可以在项目对应的路径提交到<code>git</code>上，然后再使用<code>pm2 deploy ecosystem.json production</code>即可在服务器上<code>自动部署</code>。</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SSR/">SSR</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-stream" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/14/stream/" class="article-date">
  	<time datetime="2018-07-14T04:00:40.000Z" itemprop="datePublished">2018-07-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/14/stream/">渴望力量吗？少年！流的原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="流-stream-，看一个人流不流逼，就看你对流的理解了"><a href="#流-stream-，看一个人流不流逼，就看你对流的理解了" class="headerlink" title="流(stream)，看一个人流不流逼，就看你对流的理解了"></a>流(stream)，看一个人流不流逼，就看你对流的理解了</h2><blockquote>
<p>学习本无底，前进莫徬徨</p>
</blockquote>
<p>今天跟大家分享的是node.js中的流(<code>stream</code>)。它的作用大家应该都在平常使用node的时候看到过，比如：</p>
<ul>
<li><code>gulp</code>中的pipe就是流的一种方法，通过可写流和可读流的配合，达到不占用多余缓存的一种读写方式。</li>
<li>express和koa中的res和req也是流，res是<code>可写流</code>，req是<code>可读流</code>，他们都是通过封装node中的net模块的socket(<code>双工流</code>，即可写、可读流)而来的。</li>
<li>。。。</li>
</ul>
<p>可能很多时候大家都知道怎么用，但不了解它的原理，很尴尬，就像这样</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16491e3c412fbd6f?w=300&amp;h=217&amp;f=gif&amp;s=471574" alt=""></p>
<h2 id="何谓流？"><a href="#何谓流？" class="headerlink" title="何谓流？"></a>何谓流？</h2><ul>
<li>流是一组有序的，有起点和终点的字节数据传输手段。</li>
<li>它不关心文件的整体内容，只关注是否从文件中读到了数据，以及读到数据之后的处理。</li>
<li>流是一个抽象接口，被 Node 中的很多对象所实现。比如HTTP 服务器request和response对象都是流。</li>
<li>流被分为<code>Readable</code>(可读流)、<code>Writable</code>(可写流)、<code>Duplex</code>(双工流)、<code>Transform</code>(转换流)</li>
</ul>
<h2 id="流中的是什么？"><a href="#流中的是什么？" class="headerlink" title="流中的是什么？"></a>流中的是什么？</h2><ul>
<li><code>二进制模式</code>:每个分块都是buffer、string对象。</li>
<li><code>对象模式</code>:流内部处理的是一系列普通对象。</li>
</ul>
<h2 id="可读流"><a href="#可读流" class="headerlink" title="可读流"></a>可读流</h2><blockquote>
<p>可读流分为<code>flowing</code>和<code>paused</code>两种模式</p>
</blockquote>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>path</code>:读取的文件的路径</li>
<li><code>option</code>:<ul>
<li><code>highWaterMark</code>:水位线，一次可读的字节，一般默认是<code>64k</code></li>
<li><code>flags</code>:标识，打开文件要做的操作，默认是<code>r</code></li>
<li><code>encoding</code>:编码，默认为buffer</li>
<li><code>start</code>:开始读取的索引位置</li>
<li><code>end</code>:结束读取的索引位置(包括结束位置)</li>
<li><code>autoClose</code>:读取完毕是否关闭，默认为true</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>)</div><div class="line"><span class="comment">//读取的时候默认读64k </span></div><div class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(<span class="string">'./a.txt'</span>,&#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">2</span>,<span class="comment">//一次读的字节 默认64k</span></div><div class="line">  flags: <span class="string">'r'</span>,      <span class="comment">//标示 r为读 w为写</span></div><div class="line">  autoClose: <span class="literal">true</span>, <span class="comment">//默认读取完毕后自动关闭</span></div><div class="line">  start: <span class="number">0</span>,</div><div class="line">  <span class="attr">end</span>: <span class="number">5</span>,          <span class="comment">//流是闭合区间包start，也包end 默认是读完</span></div><div class="line">  encoding: <span class="string">'utf8'</span> <span class="comment">//默认编码是buffer</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="data-切换到流动模式，可以流出数据"><a href="#data-切换到流动模式，可以流出数据" class="headerlink" title="data:切换到流动模式，可以流出数据"></a><code>data</code>:切换到流动模式，可以流出数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="open-流打开文件的时候会触发此监听"><a href="#open-流打开文件的时候会触发此监听" class="headerlink" title="open:流打开文件的时候会触发此监听"></a><code>open</code>:流打开文件的时候会触发此监听</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'文件被打开'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="error-流出错的时候，监听错误信息"><a href="#error-流出错的时候，监听错误信息" class="headerlink" title="error:流出错的时候，监听错误信息"></a><code>error</code>:流出错的时候，监听错误信息</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="end-流读取完成，触发end"><a href="#end-流读取完成，触发end" class="headerlink" title="end:流读取完成，触发end"></a><code>end</code>:流读取完成，触发end</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'读取完成'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="close-关闭流，触发"><a href="#close-关闭流，触发" class="headerlink" title="close:关闭流，触发"></a><code>close</code>:关闭流，触发</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rs.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'关闭'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="pause-暂停流-改变流的flowing，不读取数据了-；resume-恢复流-改变流的flowing-继续读取数据"><a href="#pause-暂停流-改变流的flowing，不读取数据了-；resume-恢复流-改变流的flowing-继续读取数据" class="headerlink" title="pause:暂停流(改变流的flowing，不读取数据了)；resume:恢复流(改变流的flowing,继续读取数据)"></a><code>pause</code>:暂停流(改变流的flowing，不读取数据了)；<code>resume</code>:恢复流(改变流的flowing,继续读取数据)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//流通过一次后，停止流动，过了2s后再动</span></div><div class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    rs.pause();</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    rs.resume();</div><div class="line">&#125;,<span class="number">2000</span>);</div></pre></td></tr></table></figure>
<h4 id="fs-read-可读流底层调用的就是这个方法，最原生的读方法"><a href="#fs-read-可读流底层调用的就是这个方法，最原生的读方法" class="headerlink" title="fs.read():可读流底层调用的就是这个方法，最原生的读方法"></a><code>fs.read()</code>:可读流底层调用的就是这个方法，最原生的读方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//fd文件描述符，一般通过fs.open中获取</span></div><div class="line"><span class="comment">//buffer是读取后的数据放入的缓存目标</span></div><div class="line"><span class="comment">//0，从buffer的0位置开始放入</span></div><div class="line"><span class="comment">//BUFFER_SIZE，每次放BUFFER_SIZE这么长的长度</span></div><div class="line"><span class="comment">//index，每次从文件的index的位置开始读</span></div><div class="line"><span class="comment">//bytesRead，真实读到的个数</span></div><div class="line">fs.read(fd,buffer,<span class="number">0</span>,BUFFER_SIZE,index,<span class="function"><span class="keyword">function</span>(<span class="params">err,bytesRead</span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="那让我们自己来实现一个可爱的读流吧！"><a href="#那让我们自己来实现一个可爱的读流吧！" class="headerlink" title="那让我们自己来实现一个可爱的读流吧！"></a>那让我们自己来实现一个<code>可爱</code>的读流吧！</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/164920492aaecdf9?w=419&amp;h=233&amp;f=gif&amp;s=1680530" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(path,options = &#123;&#125;)&#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.path = path</div><div class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span>*<span class="number">1024</span></div><div class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span></div><div class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span></div><div class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start     <span class="comment">//会随着读取的位置改变</span></div><div class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.end = options.end || <span class="literal">null</span></div><div class="line">    <span class="comment">//默认null就是buffer</span></div><div class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">//参数的问题</span></div><div class="line">    <span class="keyword">this</span>.flowing = <span class="literal">null</span> <span class="comment">//非流动模式</span></div><div class="line">    <span class="comment">//创建个buffer用来存储每次读出来的数据</span></div><div class="line">    <span class="keyword">this</span>.buffer = Buffer.alloc(<span class="keyword">this</span>.highWaterMark)</div><div class="line">    <span class="comment">//打开这个文件</span></div><div class="line">    <span class="keyword">this</span>.open()</div><div class="line">    <span class="comment">//此方法默认同步调用 每次设置on监听事件时都会调用之前所有的newListener事件</span></div><div class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>,(type)=&gt;&#123;<span class="comment">// 等待着他监听data事件</span></div><div class="line">      <span class="keyword">if</span>(type === <span class="string">'data'</span>)&#123;</div><div class="line">        <span class="keyword">this</span>.flowing = <span class="literal">true</span></div><div class="line">        <span class="comment">//开始读取 客户已经监听的data事件</span></div><div class="line">        <span class="keyword">this</span>.read()</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//默认第一次调用read方法时fd还没获取 所以不能直接读</span></div><div class="line">  read()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="comment">//等待着触发open事件后fd肯定拿到了 再去执行read方法</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>,()=&gt;&#123;<span class="keyword">this</span>.read()&#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//每次读的时候都要判断一下下次读几个 如果没有end就根据highWaterMark来(读所有的) 如果有且大于highWaterMark就根据highWaterMark来 如果小于highWaterMark就根据end来</span></div><div class="line">    <span class="keyword">let</span> howMuchToRead = <span class="keyword">this</span>.end?<span class="built_in">Math</span>.min(<span class="keyword">this</span>.end - <span class="keyword">this</span>.pos + <span class="number">1</span>,<span class="keyword">this</span>.highWaterMark):<span class="keyword">this</span>.highWaterMark</div><div class="line">    fs.read(<span class="keyword">this</span>.fd,<span class="keyword">this</span>.buffer,<span class="number">0</span>,howMuchToRead,<span class="keyword">this</span>.pos,(err,byteRead)=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.pos += byteRead</div><div class="line">      <span class="keyword">let</span> b = <span class="keyword">this</span>.encoding?<span class="keyword">this</span>.buffer.slice(<span class="number">0</span>,byteRead).toString(<span class="keyword">this</span>.encoding):<span class="keyword">this</span>.buffer.slice(<span class="number">0</span>,byteRead)</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'data'</span>,b)</div><div class="line">      <span class="comment">//如果读取到的数量和highWaterMark一样 说明还得继续读</span></div><div class="line">      <span class="keyword">if</span>((byteRead === <span class="keyword">this</span>.highWaterMark)&amp;&amp;<span class="keyword">this</span>.flowing)&#123;</div><div class="line">        <span class="keyword">this</span>.read()</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(byteRead &lt; <span class="keyword">this</span>.highWaterMark)&#123;</div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'end'</span>)</div><div class="line">        <span class="keyword">this</span>.destory()</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  destory()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果文件被打开过 就关闭文件并且触发close事件</span></div><div class="line">    fs.close(<span class="keyword">this</span>.fd,()=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  pause()&#123;</div><div class="line">    <span class="keyword">this</span>.flowing = <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  resume()&#123;</div><div class="line">    <span class="keyword">this</span>.flowing = <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.read()</div><div class="line">  &#125;</div><div class="line">  open()&#123;</div><div class="line">    <span class="comment">//fd表示的就是当前this.path的这个文件，从3开始(number类型)</span></div><div class="line">    fs.open(<span class="keyword">this</span>.path,<span class="keyword">this</span>.flags,(err,fd)=&gt;&#123;</div><div class="line">      <span class="comment">//有可能fd这个文件不存在 需要做处理</span></div><div class="line">      <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="comment">//如果有自动关闭 则帮他销毁</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autoClose)&#123;</div><div class="line">          <span class="comment">//销毁（关闭文件，触发关闭文件事件）</span></div><div class="line">          <span class="keyword">this</span>.destory()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有错误 就会触发error事件</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'error'</span>,err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//保存文件描述符</span></div><div class="line">      <span class="keyword">this</span>.fd = fd</div><div class="line">      <span class="comment">//当文件打开成功时触发open事件</span></div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Readable"><a href="#Readable" class="headerlink" title="Readable"></a>Readable</h3><blockquote>
<p>这个方法是可读流的一种<code>暂停模式</code>，他的模式可以参考为读<code>流是往水杯倒水的人，Readable是喝水的人，他们之间存在着一种联系，只要Readable喝掉一点水，读流就会继续往里倒</code>。</p>
</blockquote>
<h4 id="Readable是什么？"><a href="#Readable是什么？" class="headerlink" title="Readable是什么？"></a>Readable是什么？</h4><ul>
<li>他会在刚开始监听Readable的时候就触发流的，此时流就会读取一次数据，之后<code>流会监听,如果有人读过流(喝过水)，并且减少，就会再去读一次(倒点水)</code></li>
<li>主要可以用来做<code>行读取器(LineReader)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> read = <span class="built_in">require</span>(<span class="string">'./ReadableStream'</span>)</div><div class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./a.txt'</span>, &#123;</div><div class="line">  <span class="comment">//每次读7个</span></div><div class="line">  highWaterMark: <span class="number">7</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">//如果读流第一次全部读下来并且小于highWaterMark，就会再读一次(再触发一次readable事件)</span></div><div class="line"><span class="comment">//如果rs.read()不加参数，一次性读完，会从缓存区再读一次，为null</span></div><div class="line"><span class="comment">//如果readable每次都刚好读完(即rs.read()的参数刚好和highWaterMark相等)，就会一直触发readable事件，如果最后不足他想喝的数，他就会先触发一次null，最后把剩下的喝完</span></div><div class="line"><span class="comment">//一开始缓存区为0的时候也会默认调一次readable事件</span></div><div class="line">rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> result = rs.read(<span class="number">2</span>)</div><div class="line">  <span class="built_in">console</span>.log(result)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>实战：行读取器(平常我们的文件可能有回车、换行，此时如果要每次想读一行的数据，就得用到<code>readable</code>)</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="comment">//如果要将内容全部读出就用on('data')，精确读取就用on('readable')</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineReader</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(path) &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.rs = fs.createReadStream(path)</div><div class="line">    <span class="comment">//回车符的十六进制</span></div><div class="line">    <span class="keyword">let</span> RETURN = <span class="number">0x0d</span></div><div class="line">    <span class="comment">//换行符的十六进制</span></div><div class="line">    <span class="keyword">let</span> LINE = <span class="number">0x0a</span></div><div class="line">    <span class="keyword">let</span> arr = []</div><div class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, (type) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (type === <span class="string">'newLine'</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</div><div class="line">          <span class="keyword">let</span> char</div><div class="line">          <span class="comment">//每次读一个，当读完的时候会返回null，终止循环</span></div><div class="line">          <span class="keyword">while</span> (char = <span class="keyword">this</span>.rs.read(<span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">switch</span> (char[<span class="number">0</span>]) &#123;</div><div class="line">              <span class="keyword">case</span> RETURN:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">              <span class="comment">//Mac下只有换行符，windows下是回车符和换行符，需要根据不同的转换。因为我这里是Mac</span></div><div class="line">              <span class="keyword">case</span> LINE:</div><div class="line">                <span class="comment">//如果是换行符就把数组转换为字符串</span></div><div class="line">                <span class="keyword">let</span> r = Buffer.from(arr).toString(<span class="string">'utf8'</span>)</div><div class="line">                <span class="comment">//把数组清空</span></div><div class="line">                arr.length = <span class="number">0</span></div><div class="line">                <span class="comment">//触发newLine事件，把得到的一行数据输出</span></div><div class="line">                <span class="keyword">this</span>.emit(<span class="string">'newLine'</span>, r)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">              <span class="keyword">default</span>:</div><div class="line">                <span class="comment">//如果不是换行符，就放入数组中</span></div><div class="line">                arr.push(char[<span class="number">0</span>])</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">//以上只能取出之前的换行符前的代码，最后一行的后面没有换行符，所以需要特殊处理。当读流读完需要触发end事件时</span></div><div class="line">    <span class="keyword">this</span>.rs.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">      <span class="comment">//取出最后一行数据，转成字符串</span></div><div class="line">      <span class="keyword">let</span> r = Buffer.from(arr).toString(<span class="string">'utf8'</span>)</div><div class="line">      arr.length = <span class="number">0</span></div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'newLine'</span>, r)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> lineReader = <span class="keyword">new</span> LineReader(<span class="string">'./a.txt'</span>)</div><div class="line">lineReader.on(<span class="string">'newLine'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>那么Readable到底是怎样的存在呢？我们接下来实现他的源码，看看内部到底怎么回事</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(path,options = &#123;&#125;)&#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.path = path</div><div class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span>*<span class="number">1024</span></div><div class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span></div><div class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span></div><div class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start     <span class="comment">//会随着读取的位置改变</span></div><div class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.end = options.end || <span class="literal">null</span></div><div class="line">    <span class="comment">//默认null就是buffer</span></div><div class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">//参数的问题</span></div><div class="line">    <span class="keyword">this</span>.reading = <span class="literal">false</span> <span class="comment">//非流动模式</span></div><div class="line">    <span class="comment">//创建个buffer用来存储每次读出来的数据</span></div><div class="line">    <span class="keyword">this</span>.buffers = []</div><div class="line">    <span class="comment">//缓存区长度</span></div><div class="line">    <span class="keyword">this</span>.len = <span class="number">0</span></div><div class="line">    <span class="comment">//是否要触发readable事件</span></div><div class="line">    <span class="keyword">this</span>.emittedReadable = <span class="literal">false</span></div><div class="line">    <span class="comment">//触发open获取文件的fd标识符</span></div><div class="line">    <span class="keyword">this</span>.open()</div><div class="line">    <span class="comment">//此方法默认同步调用 每次设置on监听事件时都会调用之前所有的newListener事件</span></div><div class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>,(type)=&gt;&#123;<span class="comment">// 等待着他监听data事件</span></div><div class="line">      <span class="keyword">if</span>(type === <span class="string">'readable'</span>)&#123;</div><div class="line">        <span class="comment">//开始读取 客户已经监听的data事件</span></div><div class="line">        <span class="keyword">this</span>.read()</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//readable真正的源码中的方法，计算出和n最接近的2的幂次数</span></div><div class="line">  computeNewHighWaterMark(n) &#123;</div><div class="line">    n--;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    n++;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">  &#125;</div><div class="line">  read(n)&#123;</div><div class="line">    <span class="comment">//当读的数量大于水平线，会通过取2的幂次取比他大和最接近的数</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.len &lt; n)&#123;</div><div class="line">      <span class="keyword">this</span>.highWaterMark = <span class="keyword">this</span>.computeNewHighWaterMark(n)</div><div class="line">      <span class="comment">//重新触发readbale的callback，所以第一次会触发null</span></div><div class="line">      <span class="keyword">this</span>.emittedReadable = <span class="literal">true</span></div><div class="line">      <span class="comment">//重新读新的水位线</span></div><div class="line">      <span class="keyword">this</span>._read()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//真正读取到的</span></div><div class="line">    <span class="keyword">let</span> buffer = <span class="literal">null</span></div><div class="line">    <span class="comment">//说明缓存里有这么多，取出来</span></div><div class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span> &amp;&amp; n&lt;=<span class="keyword">this</span>.len)&#123;</div><div class="line">      <span class="comment">//定义一个buffer</span></div><div class="line">      buffer = Buffer.alloc(n)</div><div class="line">      <span class="keyword">let</span> buf</div><div class="line">      <span class="keyword">let</span> flag = <span class="literal">true</span></div><div class="line">      <span class="keyword">let</span> index = <span class="number">0</span></div><div class="line">      <span class="comment">//[buffer&lt;1,2,3,4&gt;,buffer&lt;1,2,3,4&gt;,buffer&lt;1,2,3,4&gt;]</span></div><div class="line">      <span class="comment">//每次取出缓存前的第一个buffer</span></div><div class="line">      <span class="keyword">while</span>(flag &amp;&amp; (buf = <span class="keyword">this</span>.buffers.shift()))&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;buf.length;i++)&#123;</div><div class="line">          <span class="comment">//把取出的一个buffer中的数据放入新定义的buffer中</span></div><div class="line">          buffer[index++] = buf[i]</div><div class="line">          <span class="comment">//当buffer的长度和n(参数)长度一样时，停止循环</span></div><div class="line">          <span class="keyword">if</span>(index === n)&#123;</div><div class="line">            flag = <span class="literal">false</span></div><div class="line">            <span class="comment">//维护缓存，因为可能缓存中的buffer长度大于n，当取出n的长度时，还会剩下其余的buffer，我们需要切割buf并且放到缓存数组之前</span></div><div class="line">            <span class="keyword">this</span>.len -= n</div><div class="line">            <span class="keyword">let</span> r = buf.slice(i+<span class="number">1</span>)</div><div class="line">            <span class="keyword">if</span>(r.length)&#123;</div><div class="line">              <span class="keyword">this</span>.buffers.unshift(r)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果缓存区没有东西，等会读完需要触发readable事件</span></div><div class="line">    <span class="comment">//这里会有一种状况，就是如果每次Readable读取的数量正好等于highWaterMark(流读取到缓存的长度)，就会每次都等于0，每次都触发Readable事件，就会每次读，读到没有为止，最后还会触发一下null</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.len === <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">this</span>.emittedReadable = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.len &lt; <span class="keyword">this</span>.highWaterMark)&#123;</div><div class="line">      <span class="comment">//默认，一开始的时候开始读取</span></div><div class="line">      <span class="keyword">if</span>(!<span class="keyword">this</span>.reading)&#123;</div><div class="line">        <span class="keyword">this</span>.reading = <span class="literal">true</span></div><div class="line">        <span class="comment">//真正多读取操作</span></div><div class="line">        <span class="keyword">this</span>._read()</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> buffer&amp;&amp;buffer.toString()</div><div class="line">  &#125;</div><div class="line">  _read()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="comment">//等待着触发open事件后fd肯定拿到了 再去执行read方法</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>,()=&gt;&#123;<span class="keyword">this</span>._read()&#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//先读这么多buffer</span></div><div class="line">    <span class="keyword">let</span> buffer = Buffer.alloc(<span class="keyword">this</span>.highWaterMark)</div><div class="line">    fs.read(<span class="keyword">this</span>.fd,buffer,<span class="number">0</span>,buffer.length,<span class="keyword">this</span>.pos,(err,byteRead)=&gt;&#123;</div><div class="line">      <span class="keyword">if</span>(byteRead &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="comment">//当第一次读到数据后，改变reading的状态，如果触发read事件，可能还会在触发第二次_read</span></div><div class="line">        <span class="keyword">this</span>.reading = <span class="literal">false</span></div><div class="line">        <span class="comment">//每次读到数据增加缓存取得长度</span></div><div class="line">        <span class="keyword">this</span>.len += byteRead</div><div class="line">        <span class="comment">//每次读取之后，会增加读取的文件的读取开始位置</span></div><div class="line">        <span class="keyword">this</span>.pos += byteRead</div><div class="line">        <span class="comment">//将读到的buffer放入缓存区buffers中</span></div><div class="line">        <span class="keyword">this</span>.buffers.push(buffer.slice(<span class="number">0</span>,byteRead))</div><div class="line">        <span class="comment">//触发readable</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.emittedReadable)&#123;</div><div class="line">          <span class="keyword">this</span>.emittedReadable = <span class="literal">false</span></div><div class="line">          <span class="comment">//可以读取了，默认开始的时候杯子填满了</span></div><div class="line">          <span class="keyword">this</span>.emit(<span class="string">'readable'</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//没读到就出发end事件</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'end'</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  destory()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果文件被打开过 就关闭文件并且触发close事件</span></div><div class="line">    fs.close(<span class="keyword">this</span>.fd,()=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  open()&#123;</div><div class="line">    <span class="comment">//fd表示的就是当前this.path的这个文件，从3开始(number类型)</span></div><div class="line">    fs.open(<span class="keyword">this</span>.path,<span class="keyword">this</span>.flags,(err,fd)=&gt;&#123;</div><div class="line">      <span class="comment">//有可能fd这个文件不存在 需要做处理</span></div><div class="line">      <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="comment">//如果有自动关闭 则帮他销毁</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autoClose)&#123;</div><div class="line">          <span class="comment">//销毁（关闭文件，触发关闭文件事件）</span></div><div class="line">          <span class="keyword">this</span>.destory()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有错误 就会触发error事件</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'error'</span>,err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//保存文件描述符</span></div><div class="line">      <span class="keyword">this</span>.fd = fd</div><div class="line">      <span class="comment">//当文件打开成功时触发open事件</span></div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Readable和读流的data的区别就是，Readable可以控制自己从缓存区读多少和控制读的次数，而data是每次读取都清空缓存，读多少输出多少</li>
<li>我们可以看一下下面这个例子</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./a.txt'</span>)</div><div class="line">rs.on(<span class="string">'data'</span>,(data)=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(data)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//因为上面的data事件把数据读了，清空缓存区。所以导致下面的readable读出为null</span></div><div class="line">rs.on(<span class="string">'readable'</span>,()=&gt;&#123;</div><div class="line">  <span class="keyword">let</span> result = r.read(<span class="number">1</span>)</div><div class="line">  <span class="built_in">console</span>.log(result)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="自定义可读流"><a href="#自定义可读流" class="headerlink" title="自定义可读流"></a>自定义可读流</h3><p><strong>因为<code>createReadStream</code>内部调用了<code>ReadStream</code>类，<code>ReadStream</code>又实现了<code>Readable</code>接口,<code>ReadStream</code>实现了<code>_read()</code>方法,所以我们通过自定义一个类继承<code>stream</code>模块的<code>Readable</code>，并在<code>原型</code>上自定义一个<code>_read()</code>就可以自定义自己的可读流</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; Readable &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRead</span> <span class="keyword">extends</span> <span class="title">Readable</span></span>&#123;</div><div class="line">  <span class="comment">//流需要一个_read方法，方法中push什么，外面就接收什么</span></div><div class="line">  _read()&#123;</div><div class="line">    <span class="comment">//push方法就是上面_read方法中的push一样，把数据放入缓存区中</span></div><div class="line">    <span class="keyword">this</span>.push(<span class="string">'100'</span>)</div><div class="line">    <span class="comment">//如果push了null就表示没有东西可读了，停止(如果不写，就会一直push上面的值，死循环)</span></div><div class="line">    <span class="keyword">this</span>.push(<span class="literal">null</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="可写流"><a href="#可写流" class="headerlink" title="可写流"></a>可写流</h2><ul>
<li>如果文件不存在会创建，如果有内容会被清空</li>
<li>读取到highWaterMark的时候就会输出</li>
<li>第一次是真的写到文件 后面就是写入缓存区 再从缓存区里面去取</li>
</ul>
<h3 id="参数-和可读流的类似"><a href="#参数-和可读流的类似" class="headerlink" title="参数(和可读流的类似)"></a>参数(和可读流的类似)</h3><ul>
<li><code>path</code>:写入的文件的路径</li>
<li><code>option</code>:<ul>
<li><code>highWaterMark</code>:水位线，一次可写入缓存中的字节，一般默认是<code>64k</code></li>
<li><code>flags</code>:标识，写入文件要做的操作，默认是<code>w</code></li>
<li><code>encoding</code>:编码，默认为buffer</li>
<li><code>start</code>:开始写入的索引位置</li>
<li><code>end</code>:结束写入的索引位置(包括结束位置)</li>
<li><code>autoClose</code>:写入完毕是否关闭，默认为true</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>)</div><div class="line"><span class="comment">//读取的时候默认读64k </span></div><div class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(<span class="string">'./a.txt'</span>,&#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">2</span>,<span class="comment">//一次读的字节 默认64k</span></div><div class="line">  flags: <span class="string">'r'</span>,      <span class="comment">//标示 r为读 w为写</span></div><div class="line">  autoClose: <span class="literal">true</span>, <span class="comment">//默认读取完毕后自动关闭</span></div><div class="line">  start: <span class="number">0</span>,</div><div class="line">  <span class="attr">end</span>: <span class="number">5</span>,          <span class="comment">//流是闭合区间包start，也包end 默认是读完</span></div><div class="line">  encoding: <span class="string">'utf8'</span> <span class="comment">//默认编码是buffer</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="write"><a href="#write" class="headerlink" title="write"></a><code>write</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> ws = fs.createWriteStream(<span class="string">'./d.txt'</span>,&#123;</div><div class="line">  <span class="attr">flags</span>: <span class="string">'w'</span>,</div><div class="line">  <span class="attr">encoding</span>: <span class="string">'utf8'</span>,</div><div class="line">  <span class="attr">start</span>: <span class="number">0</span>,</div><div class="line">  <span class="comment">//write的highWaterMark只是用来触发是不是干了</span></div><div class="line">  highWaterMark: <span class="number">3</span> <span class="comment">//写是默认16k</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">//返回boolean 每当write一次都会在ws中吃下一个馒头 当吃下的馒头数量达到highWaterMark时 就会返回false 吃不下了会把其余放入缓存 其余状态返回true</span></div><div class="line"><span class="comment">//write只能放string或者buffer</span></div><div class="line">flag = ws.write(<span class="string">'1'</span>,<span class="string">'utf8'</span>,()=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(i)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="drain"><a href="#drain" class="headerlink" title="drain"></a><code>drain</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//drain只有嘴塞满了 吃完（包括内存中的，就是地下的）才会触发 这里是两个条件 一个是必须是吃下highWaterMark个馒头 并且在吃完的时候才会callback</span></div><div class="line">ws.on(<span class="string">'drain'</span>,()=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'干了'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16491a2ce2f22b41?w=1976&amp;h=1128&amp;f=jpeg&amp;s=170261" alt=""></p>
<h4 id="fs-write-可读流底层调用的就是这个方法，最原生的读方法"><a href="#fs-write-可读流底层调用的就是这个方法，最原生的读方法" class="headerlink" title="fs.write():可读流底层调用的就是这个方法，最原生的读方法"></a><code>fs.write()</code>:可读流底层调用的就是这个方法，最原生的读方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//wfd文件描述符，一般通过fs.open中获取</span></div><div class="line"><span class="comment">//buffer，要取数据的缓存源</span></div><div class="line"><span class="comment">//0，从buffer的0位置开始取</span></div><div class="line"><span class="comment">//BUFFER_SIZE，每次取BUFFER_SIZE这么长的长度</span></div><div class="line"><span class="comment">//index，每次写入文件的index的位置</span></div><div class="line"><span class="comment">//bytesRead，真实写入的个数</span></div><div class="line">fs.write(wfd,buffer,<span class="number">0</span>,bytesRead,index,<span class="function"><span class="keyword">function</span>(<span class="params">err,bytesWrite</span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="通过代码实现"><a href="#通过代码实现" class="headerlink" title="通过代码实现"></a>通过代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="comment">//只有第一次write的时候直接用_write写入文件 其余都是放到cache中 但是len超过了highWaterMark就会返回false告知需要drain 很占缓存</span></div><div class="line"><span class="comment">//从第一次的_write开始 回去一直通过clearBuffer递归_write写入文件 如果cache中没有了要写入的东西 会根据needDrain来判断是否触发干点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(path,options = &#123;&#125;)&#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.path = path</div><div class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span>*<span class="number">1024</span></div><div class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span></div><div class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span></div><div class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start</div><div class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="number">0o666</span></div><div class="line">    <span class="comment">//默认null就是buffer</span></div><div class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">//打开这个文件</span></div><div class="line">    <span class="keyword">this</span>.open()</div><div class="line"></div><div class="line">    <span class="comment">//写文件的时候需要哪些参数</span></div><div class="line">    <span class="comment">//第一次写入的时候 是给highWaterMark个馒头 他会硬着头皮写到文件中 之后才会把多余吃不下的放到缓存中</span></div><div class="line">    <span class="keyword">this</span>.writing = <span class="literal">false</span></div><div class="line">    <span class="comment">//缓存数组</span></div><div class="line">    <span class="keyword">this</span>.cache = []</div><div class="line">    <span class="keyword">this</span>.callbackList = []</div><div class="line">    <span class="comment">//数组长度</span></div><div class="line">    <span class="keyword">this</span>.len = <span class="number">0</span></div><div class="line">    <span class="comment">//是否触发drain事件</span></div><div class="line">    <span class="keyword">this</span>.needDrain = <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  clearBuffer()&#123;</div><div class="line">    <span class="comment">//取缓存中最上面的一个</span></div><div class="line">    <span class="keyword">let</span> buffer = <span class="keyword">this</span>.cache.shift()</div><div class="line">    <span class="keyword">if</span>(buffer)&#123;</div><div class="line">      <span class="comment">//有buffer的情况下</span></div><div class="line">      <span class="keyword">this</span>._write(buffer.chunk,buffer.encoding,()=&gt;<span class="keyword">this</span>.clearBuffer(),buffer.callback)</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">//没有的话 先看看需不需要drain</span></div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.needDrain)&#123;</div><div class="line">        <span class="comment">//触发drain 并初始化所有状态</span></div><div class="line">        <span class="keyword">this</span>.writing = <span class="literal">false</span></div><div class="line">        <span class="keyword">this</span>.needDrain = <span class="literal">false</span></div><div class="line">        <span class="keyword">this</span>.callbackList.shift()()</div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'drain'</span>)</div><div class="line">        </div><div class="line">      &#125;</div><div class="line">      <span class="keyword">this</span>.callbackList.map(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</div><div class="line">        v()</div><div class="line">      &#125;)</div><div class="line">      <span class="keyword">this</span>.callbackList.length = <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  _write(chunk,encoding,clearBuffer,callback)&#123;</div><div class="line">    <span class="comment">//因为write方法是同步调用的 所以可能还没获取到fd</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="comment">//直接在open的时间对象上注册一个一次性事件 当open被emit的时候会被调用</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>,()=&gt;<span class="keyword">this</span>._write(chunk,encoding,clearBuffer,callback))</div><div class="line">    &#125;</div><div class="line">    fs.write(<span class="keyword">this</span>.fd,chunk,<span class="number">0</span>,chunk.length,<span class="keyword">this</span>.pos,(err,byteWrite)=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.pos += byteWrite</div><div class="line">      <span class="comment">//每次写完 相应减少内存中的数量</span></div><div class="line">      <span class="keyword">this</span>.len -= byteWrite</div><div class="line">      <span class="keyword">if</span>(callback) <span class="keyword">this</span>.callbackList.push(callback)</div><div class="line">      <span class="comment">//第一次写完</span></div><div class="line">      clearBuffer()</div><div class="line">      </div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//写入方法</span></div><div class="line">  write(chunk,encoding=<span class="keyword">this</span>.encoding,callback)&#123;</div><div class="line">    <span class="comment">//判断chunk必须是字符串或者buffer 为了统一都变成buffer</span></div><div class="line">    chunk = Buffer.isBuffer(chunk)?chunk:Buffer.from(chunk,encoding)</div><div class="line">    <span class="comment">//维护缓存的长度 3</span></div><div class="line">    <span class="keyword">this</span>.len += chunk.length</div><div class="line">    <span class="keyword">let</span> ret = <span class="keyword">this</span>.len &lt; <span class="keyword">this</span>.highWaterMark</div><div class="line">    <span class="keyword">if</span>(!ret)&#123;</div><div class="line">      <span class="comment">//表示要触发drain事件</span></div><div class="line">      <span class="keyword">this</span>.needDrain = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//正在写入的应该放到内存中</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.writing)&#123;</div><div class="line">      <span class="keyword">this</span>.cache.push(&#123;</div><div class="line">        chunk,</div><div class="line">        encoding,</div><div class="line">        callback</div><div class="line">      &#125;)</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">//这里是第一次写的时候</span></div><div class="line">      <span class="keyword">this</span>.writing = <span class="literal">true</span></div><div class="line">      <span class="comment">//专门实现写的方法</span></div><div class="line">      <span class="keyword">this</span>._write(chunk,encoding,()=&gt;<span class="keyword">this</span>.clearBuffer(),callback)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// console.log(ret)</span></div><div class="line">    <span class="comment">//能不能继续写了 false代表下次写的时候更占内存</span></div><div class="line">    <span class="keyword">return</span> ret</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  destory()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd != <span class="string">'number'</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果文件被打开过 就关闭文件并且触发close事件</span></div><div class="line">    fs.close(<span class="keyword">this</span>.fd,()=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  open()&#123;</div><div class="line">    <span class="comment">//fd表示的就是当前this.path的这个文件，从3开始(number类型)</span></div><div class="line">    fs.open(<span class="keyword">this</span>.path,<span class="keyword">this</span>.flags,(err,fd)=&gt;&#123;</div><div class="line">      <span class="comment">//有可能fd这个文件不存在 需要做处理</span></div><div class="line">      <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="comment">//如果有自动关闭 则帮他销毁</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autoClose)&#123;</div><div class="line">          <span class="comment">//销毁（关闭文件，出发关闭文件事件）</span></div><div class="line">          <span class="keyword">this</span>.destory()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有错误 就会触发error事件</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'error'</span>,err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//保存文件描述符</span></div><div class="line">      <span class="keyword">this</span>.fd = fd</div><div class="line">      <span class="comment">//当文件打开成功时触发open事件</span></div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自定义可写流"><a href="#自定义可写流" class="headerlink" title="自定义可写流"></a>自定义可写流</h3><p><strong>因为<code>createWriteStream</code>内部调用了<code>WriteStream</code>类，<code>WriteStream</code>又实现了<code>Writable</code>接口,<code>WriteStream</code>实现了<code>_write()</code>方法,所以我们通过自定义一个类继承<code>stream</code>模块的<code>Writable</code>，并在<code>原型</code>上自定义一个<code>_write()</code>就可以自定义自己的可写流</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; Writable &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWrite</span> <span class="keyword">extends</span> <span class="title">Writable</span></span>&#123;</div><div class="line">  _write(chunk,encoding,callback)&#123;</div><div class="line">    <span class="comment">//write()的第一个参数，写入的数据</span></div><div class="line">    <span class="built_in">console</span>.log(chunk)</div><div class="line">    <span class="comment">//这个callback，就相当于我们上面的clearBuffer方法，如果不执行callback就不会继续从缓存中取出写</span></div><div class="line">    callback()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> write = <span class="keyword">new</span> MyWrite()</div><div class="line">write.write(<span class="string">'1'</span>,<span class="string">'utf8'</span>,()=&gt;&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><blockquote>
<p>管道流，是可读流上的方法，至于为什么放到这里，主要是因为需要2个流的基础知识，是可读流配合可写流的一种<code>传输方式</code>。如果用原来的读写，因为写比较<code>耗时</code>，所以会<code>多读少写</code>，<code>耗内存</code>，但用了<code>pipe</code>就不会了，始终用<code>规定</code>的内存。</p>
</blockquote>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="comment">//pipe方法叫管道 可以控制速率</span></div><div class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./d.txt'</span>,&#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">4</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">let</span> ws = fs.createWriteStream(<span class="string">'./e,txt'</span>,&#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">1</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">//会监听rs的on('data')将读取到的数据,通过ws.write的方法写入文件</span></div><div class="line"><span class="comment">//调用写的一个方法 返回boolean类型</span></div><div class="line"><span class="comment">//如果返回false就调用rs的pause方法 暂停读取</span></div><div class="line"><span class="comment">//等待可写流 写入完毕在监听drain resume rs</span></div><div class="line">rs.pipe(ws) <span class="comment">//会控制速率 防止淹没可用内存</span></div></pre></td></tr></table></figure>
<h3 id="自己实现一下"><a href="#自己实现一下" class="headerlink" title="自己实现一下"></a>自己实现一下</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="comment">//这两个是上面自己写的ReadStream和WriteStream</span></div><div class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>)</div><div class="line"><span class="keyword">let</span> WriteStream = <span class="built_in">require</span>(<span class="string">'./WriteStream'</span>)</div><div class="line"></div><div class="line"><span class="comment">//如果用原来的读写，因为写比较耗时，所以会多读少写，耗内存</span></div><div class="line">ReadStream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">'data'</span>,(data)=&gt;&#123;</div><div class="line">    <span class="keyword">let</span> flag = dest.write(data)</div><div class="line">    <span class="comment">//如果写入的时候嘴巴吃满了就不继续读了，暂停</span></div><div class="line">    <span class="keyword">if</span>(!flag)&#123;</div><div class="line">      <span class="keyword">this</span>.pause()</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="comment">//如果写的时候嘴巴里的吃完了，就会继续读</span></div><div class="line">  dest.on(<span class="string">'drain'</span>,()=&gt;&#123;</div><div class="line">    <span class="keyword">this</span>.resume()</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">'end'</span>,()=&gt;&#123;</div><div class="line">    <span class="keyword">this</span>.destory()</div><div class="line">    <span class="comment">//清空缓存中的数据</span></div><div class="line">    fs.fsync(dest.fd,()=&gt;&#123;</div><div class="line">      dest.destory()</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="双工流"><a href="#双工流" class="headerlink" title="双工流"></a>双工流</h2><blockquote>
<p>有了双工流，我们可以在同一个对象上<code>同时实现可读和可写</code>，就好像同时继承这两个接口。 重要的是双工流的可读性和可写性操作<code>完全独立</code>于彼此。这仅仅是将两个特性组合成一个对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; Duplex &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>)</div><div class="line"><span class="comment">//双工流，可读可写</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDuplex</span> <span class="keyword">extends</span> <span class="title">Duplex</span></span>&#123;</div><div class="line">  _read()&#123;</div><div class="line">    <span class="keyword">this</span>.push(<span class="string">'hello'</span>)</div><div class="line">    <span class="keyword">this</span>.push(<span class="literal">null</span>)</div><div class="line">  &#125;</div><div class="line">  _write(chunk,encoding,clearBuffer)&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk)</div><div class="line">    clearBuffer()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myDuplex = <span class="keyword">new</span> MyDuplex()</div><div class="line"><span class="comment">//process.stdin是node自带的process进程中的可读流，会监听命令行的输入</span></div><div class="line"><span class="comment">//process.stdout是node自带的process进程中的可写流，会监听并输出在命令行中</span></div><div class="line"><span class="comment">//所以这里的意思就是在命令行先输出hello，然后我们输入什么他就出来对应的buffer(先作为可读流出来)</span></div><div class="line">process.stdin.pipe(myDuplex).pipe(process.stdout)</div></pre></td></tr></table></figure>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><blockquote>
<p>转换流的输出是从输入中<code>计算</code>出来的。对于转换流，我们不必实现<code>read</code>或<code>write</code>的方法，我们只需要实现一个<code>transform</code>方法，将两者结合起来。它有<code>write</code>方法的意思，我们也可以用它来<code>push</code>数据。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; Transform &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span></span>&#123;</div><div class="line">  _transform(chunk,encoding,callback)&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk.toString().toUpperCase())</div><div class="line">    callback()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> myTransform = <span class="keyword">new</span> MyTransform()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform2</span> <span class="keyword">extends</span> <span class="title">Transform</span></span>&#123;</div><div class="line">  _transform(chunk,encoding,callback)&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk.toString().toUpperCase())</div><div class="line">    <span class="keyword">this</span>.push(<span class="string">'1'</span>)</div><div class="line">    <span class="comment">// this.push(null)</span></div><div class="line">    callback()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> myTransform2 = <span class="keyword">new</span> MyTransform2()</div><div class="line"></div><div class="line"><span class="comment">//此时myTransform2被作为可写流触发_transform，输出输入的大写字符后，会通过可读流push字符到下一个转换流中</span></div><div class="line"><span class="comment">//当写入的时候才会触发transform的值，此时才会push，所以后面的pipe拿到的chunk是前面的push的值</span></div><div class="line">process.stdin.pipe(myTransform2).pipe(myTransform)</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="可读流-1"><a href="#可读流-1" class="headerlink" title="可读流"></a>可读流</h3><ul>
<li>在 flowing 模式下， 可读流自动从系统底层读取数据，并通过 EventEmitter 接口的事件尽快将数据提供给应用。</li>
<li>在 paused 模式下，必须显式调用 stream.read() 方法来从流中读取数据片段。</li>
<li>所有初始工作模式为 paused 的 Readable 流，可以通过下面三种途径切换到 flowing 模式：<ul>
<li>监听 ‘data’ 事件</li>
<li>调用 stream.resume() 方法</li>
<li>调用 stream.pipe() 方法将数据发送到 Writable</li>
</ul>
</li>
<li>可读流可以通过下面途径切换到 paused 模式：<ul>
<li>如果不存在管道目标（pipe destination），可以通过调用 stream.pause() 方法实现。</li>
<li>如果存在管道目标，可以通过取消 ‘data’ 事件监听，并调用 stream.unpipe() 方法移除所有管道目标来实现。</li>
</ul>
</li>
</ul>
<h3 id="可写流-1"><a href="#可写流-1" class="headerlink" title="可写流"></a>可写流</h3><ul>
<li>需要知道只有在<code>嘴</code>真正的吃满了，并且等到把嘴里的和地上的馒头(缓存中的)都吃下了才会触发<code>drain</code>事件</li>
<li>第一次写入会直接写入文件中，后面会从缓存中一个个取</li>
</ul>
<h3 id="双工流-1"><a href="#双工流-1" class="headerlink" title="双工流"></a>双工流</h3><ul>
<li>只是对可写可读流的一种应用，既可作为可读流，也能作为可写流，并且作为可读或者可写时时<code>隔离</code>的</li>
</ul>
<h3 id="转换流-1"><a href="#转换流-1" class="headerlink" title="转换流"></a>转换流</h3><ul>
<li>一般转换流是边输入边输出的，而且一般只有触发了写入操作时才会进入<code>_transform</code>方法中。跟双工流的区别就是，他的可读可写是在<code>一起</code>的。</li>
</ul>
<p><strong>OK,讲完收工，从此你就是<code>流</code>魔王</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/13/164920c158bb431a?w=198&amp;h=130&amp;f=jpeg&amp;s=7736" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/">node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stream/">stream</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/流/">流</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-node事件环" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/14/node事件环/" class="article-date">
  	<time datetime="2018-07-14T04:00:40.000Z" itemprop="datePublished">2018-07-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/14/node事件环/">node基础面试事件环？微任务、宏任务？一篇带你飞</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-gold-cdn.xitu.io/2018/6/29/16449b3ca264a461?w=228&amp;h=221&amp;f=png&amp;s=8299" alt=""></p>
<blockquote>
<p>培育能力的事必须继续不断地去做，又必须随时改善学习方法，提高学习效率，才会成功。 —— 叶圣陶</p>
</blockquote>
<h1 id="一、我们为什么要使用node，它的好处是什么？"><a href="#一、我们为什么要使用node，它的好处是什么？" class="headerlink" title="一、我们为什么要使用node，它的好处是什么？"></a>一、我们为什么要使用node，它的好处是什么？</h1><blockquote>
<p>Node的首要目标是提供一种简单的，用于创建高性能服务器的开发工具。还要解决web服务器高并发的用户请求。</p>
</blockquote>
<h2 id="解决高并发？"><a href="#解决高并发？" class="headerlink" title="解决高并发？"></a>解决高并发？</h2><p>我们这里来举个例子，我们node和java相比，在同样的请求下谁更占优一点。看图</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644973520f8be20?w=2288&amp;h=1222&amp;f=jpeg&amp;s=224747" alt=""></p>
<ul>
<li>当用户请求量增高时，node相对于java有更好的处理<code>并发</code>性能，它可以快速通过主线程绑定事件。java每次都要创建一个线程，虽然java现在有个<code>线程池</code>的概念，可以控制线程的复用和数量。</li>
<li>异步i/o操作，node可以更快的操作数据库。java访问数据库会遇到一个并行的问题，需要添加一个锁的概念。我们这里可以打个比方，下课去饮水机接水喝，java是一下子有喝多人去接水喝，需要等待，node是每次都只去一个人接水喝。</li>
<li>密集型CPU运算指的是逻辑处理运算、压缩、解压、加密、解密，node遇到CPU密集型运算时会阻塞主线程<code>(单线程)</code>，导致其下面的时间无法快速绑定，所以<code>node不适用于大型密集型CPU运算案例</code>，而java却很适合。</li>
</ul>
<h2 id="node在web端场景？"><a href="#node在web端场景？" class="headerlink" title="node在web端场景？"></a>node在web端场景？</h2><p>web端场景主要是<code>用户的请求</code>或者<code>读取静态资源</code>什么的，很适合node开发。应用场景主要有<code>聊天服务器</code>，<code>电子商务网站</code>等等这些高并发的应用。</p>
<h1 id="二、node是什么？"><a href="#二、node是什么？" class="headerlink" title="二、node是什么？"></a>二、node是什么？</h1><p><strong>Node.js是一个基于 Chrome V8 引擎的JavaScript<code>运行环境(runtime)</code>,Node不是一门语言，是让js运行在后端的<code>运行时</code>,并且不包括javascript全集,因为在服务端中不包含<code>DOM</code>和<code>BOM</code>,Node也提供了一些新的模块例如<code>http,fs</code>模块等。Node.js 使用了<code>事件驱动、非阻塞式 I/O</code>的模型，使其轻量又高效并且Node.js 的包管理器 <code>npm</code>，是全球最大的开源库生态系统。</strong></p>
<blockquote>
<p>总而言之，言而总之，它只是一个运行时，一个运行环境。</p>
</blockquote>
<h2 id="node特性"><a href="#node特性" class="headerlink" title="node特性"></a>node特性</h2><ul>
<li>主线程是单线程（异步），将后续的逻辑写成函数，传入到当前执行的函数中，当执行的函数得到了结果后，执行传入的函数<code>（回调函数）</code>。</li>
<li>五个人同时吃一碗饭（异步）。</li>
<li>阻塞不能异步（现在假定数据库是厨师，服务员是node，顾客是请求，一般是厨师做菜让一个服务员递给多个用户，如果厨师邀请服务员聊天，就会导致阻塞，并且是针对内核说的）。</li>
<li>i/o操作，读写操作，异步读写（能用异步绝不用同步） <code>非阻塞式i/o</code>，即可以异步读写。</li>
<li>event-driven<code>事件驱动</code>（发布订阅）。</li>
</ul>
<h2 id="node的进程与线程"><a href="#node的进程与线程" class="headerlink" title="node的进程与线程"></a>node的进程与线程</h2><blockquote>
<p><code>进程</code>是操作系统分配资源和调度任务的基本单位,<code>线程</code>是建立在进程上的一次程序运行单位，一个进程上可以有多个线程。</p>
</blockquote>
<p><strong>在此之前我们先来看看浏览器的进程机制</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/16449b3ca248f42b?w=2880&amp;h=1800&amp;f=png&amp;s=194399" alt=""></p>
<p>自上而下，分别是：</p>
<ul>
<li><strong>用户界面</strong>–包括地址栏、书签菜单等</li>
<li><strong>浏览器引擎</strong>–用户界面和渲染引擎之间的传送指令（浏览器的主进程）</li>
<li><strong>渲染引擎</strong>–浏览器的内核，如（webkit，Gecko）</li>
<li><strong>其他</strong>–网络请求，js线程和ui线程</li>
</ul>
<blockquote>
<p>从我们的角度来看，我们更关心的是浏览器的<code>渲染引擎</code>，让我们往下看。</p>
</blockquote>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><ul>
<li>渲染引擎是<code>多线程</code>的，包含ui线程和js线程。ui线程和js线程会<strong>互斥</strong>，因为js线程的运行结果会影响ui线程，ui更新会被保存在队列，直到js线程空闲，则被取出来更新。</li>
<li>js单线程是单线程的，为什么呢？假如js是多线程的，那么操作DOM就是多线程操作，那样的话就会很<strong>混乱</strong>，DOM不知道该听谁的，而这里的单线程指得是主线程是单线程的，他同样可以有异步线程，通过队列存放这些线程，而主线程依旧是单线程，这个我们后面再讲。所以在node中js也是单线程的。</li>
<li>单线程的好处就是节约内存，不需要再切换的时候执行上下文，也不用管锁的概念，因为我们每次都通过一个。</li>
</ul>
<h1 id="三、浏览器中的Event-Loop"><a href="#三、浏览器中的Event-Loop" class="headerlink" title="三、浏览器中的Event Loop"></a>三、浏览器中的Event Loop</h1><p>这里我先要说一下浏览器的事件环，可能有人会说，你这篇文章明明是讲node的怎么会扯到浏览器。首先他们都是以js为底层语言的不同运行时，有其相似之处，再者多学一点也不怕面试官多问。好了我废话不多说，开始。</p>
<h2 id="首先我们需要知道堆，栈和队列的关系和意义。"><a href="#首先我们需要知道堆，栈和队列的关系和意义。" class="headerlink" title="首先我们需要知道堆，栈和队列的关系和意义。"></a>首先我们需要知道堆，栈和队列的关系和意义。</h2><ul>
<li>堆（heap）：堆是存放对象的一个空间（Object、function）</li>
<li>队列（loop）：是指存放所有异步请求操作的结果，直到有一个异步操作完成它的使命，就会在loop中添加一个事件，<code>队列是先进先出的</code>，比如下面的图，最先进队列的会先被打出去</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644a173bb4f6bd4?w=400&amp;h=225&amp;f=gif&amp;s=3690752" alt="隔山打牛！"></p>
<ul>
<li>栈（stack）：栈本身是存储基础的变量，比如1，2，3，还有引用的变量，这里可能有人会问你上面的堆不是存放引用类型的对象吗，怎么变栈里去了。这里我要解释一下，因为栈里面的存放的<code>引用变量</code>是指向堆里的引用对象的<strong>地址</strong>，<strong>只是一串地址</strong>。这里栈代表的是执行栈，我们js的主线程。<code>栈是先进后出的</code>，先进后出就是相当于喝水的水杯，我们倒水进去，理论上喝到的水是最后进水杯的。我们可以看代码，<strong>follow me</strong>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>)</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>)    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'c'</span>)</div><div class="line">    &#125;</div><div class="line">    c()</div><div class="line">  &#125;</div><div class="line">  b()</div><div class="line">&#125;</div><div class="line">a()</div><div class="line"></div><div class="line"><span class="comment">//这段代码是输出a,b,c,执行栈中的顺序的c，b，a，如果是遵循先进先出，就是输出c，b，a。所以栈先进后出这个特性大家要牢记。</span></div></pre></td></tr></table></figure>
<p>OK,现在大家已经知道堆，栈和队列的关系，现在我们来看一张图。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644a2d1744a0431?w=500&amp;h=438&amp;f=jpeg&amp;s=26999" alt=""></p>
<p>我分析一下这张图</p>
<ul>
<li>我们的同步任务在主线程上运行会形成一个执行栈</li>
<li>如果碰到异步任务，比如<code>setTimeout、onClick</code>等等的一些操作，我们会将他的执行结果放入队列，此期间主线程不阻塞</li>
<li>等到主线程中的所有同步任务执行完毕，就会通过<code>event loop</code>在队列里面从头开始取，在执行栈中执行</li>
<li><code>event loop</code>永远不会断</li>
<li>以上的这一整个流程就是<code>Event Loop</code>（事件循环机制）</li>
</ul>
<h2 id="微任务、宏任务？"><a href="#微任务、宏任务？" class="headerlink" title="微任务、宏任务？"></a>微任务、宏任务？</h2><blockquote>
<p>macro-task(宏任务): setTimeout，setImmediate，MessageChannel<br>micro-task(微任务): 原生Promise(有些实现的promise将then方法放到了宏任务中),Object.observe(已废弃), MutationObserver</p>
</blockquote>
<p><strong>微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。那么他们之间到底有什么区别呢</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644a8518a955796?w=1406&amp;h=1230&amp;f=jpeg&amp;s=576887" alt=""></p>
<p><strong>每次执行栈的同步任务执行完毕，就会去任务队列中取出完成的异步任务，队列中又分为<code>microtasks queues和宏任务队列</code>等到把<code>microtasks queues所有的microtasks</code>都执行完毕,注意是<code>所有的</code>,他才会从<code>宏任务队列</code>中取事件。等到把队列中的事件取出<code>一个</code>，放入执行栈执行完成，就算一次循环结束，之后<code>event loop</code>还会继续循环，他会再去<code>microtasks queues</code>执行所有的任务，然后再从<code>宏任务队列</code>里面取<code>一个</code>，如此反复循环。</strong></p>
<ul>
<li>同步任务执行完</li>
<li>去执行<code>microtasks</code>，把所有<code>microtasks queues</code>清空</li>
<li>取出一个<code>macrotasks queues</code>的完成事件，在执行栈执行</li>
<li>再去执行<code>microtasks</code></li>
<li>…</li>
<li>…</li>
<li>…</li>
</ul>
<p>我这么说可能大家会有点懵，不慌，我们来看一道题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</div><div class="line">&#125;,<span class="number">0</span>)</div><div class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</div><div class="line">  resolve()</div><div class="line">&#125;)</div><div class="line">p.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>最后输出结果是Promise1，Promise2，setTimeout1</strong></p>
<ul>
<li>Promise参数中的Promise1是同步执行的，Promise还不是很了解的可以看看我另外一篇文章<a href="https://juejin.im/post/5b32f552f265da59991155f0" target="_blank" rel="external">Promise之你看得懂的Promise</a>,</li>
<li>其次是因为Promise是<code>microtasks</code>，会在同步任务执行完后会去<strong>清空<code>microtasks queues</code></strong>，</li>
<li>最后清空完微任务再去<strong>宏任务队列取值</strong>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)  </div><div class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</div><div class="line">  &#125;,<span class="number">0</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</div><div class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </div><div class="line">  &#125;)</div><div class="line">&#125;,<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><strong>这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2</strong></p>
<ul>
<li>一开始执行栈的同步任务执行完毕，会去<code>microtasks queues</code>找</li>
<li>清空<code>microtasks queues</code>，输出<strong>Promise1</strong>，同时会生成一个异步任务setTimeout1</li>
<li>去<code>宏任务队列</code>查看此时队列是setTimeout1在setTimeout2之前，因为setTimeout1执行栈一开始的时候就开始异步执行,所以输出<strong>setTimeout1</strong>，在执行setTimeout1时会生成Promise2的一个microtasks，放入<code>microtasks queues</code>中</li>
<li>接着又是一个循环，去清空<code>microtasks queues</code>，输出<strong>Promise2</strong></li>
<li>清空完<code>microtasks queues</code>，就又会去宏任务队列取一个，这回取的是<strong>setTimeout2</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644bc7e669cd8b6?w=2020&amp;h=1292&amp;f=png&amp;s=395321" alt=""></p>
<h1 id="四、node中的事件环"><a href="#四、node中的事件环" class="headerlink" title="四、node中的事件环"></a>四、node中的事件环</h1><p>node的事件环相比浏览器就不一样了，我们先来看一张图，他的工作流程</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644ad464210b649?w=800&amp;h=316&amp;f=webp&amp;s=20310" alt=""></p>
<ul>
<li>首先我们能看到我们的js代码<code>（APPLICATION）</code>会先进入v8引擎,v8引擎中主要是一些<code>setTimeout</code>之类的方法。</li>
<li>其次如果我们的代码中执行了nodeApi，比如<code>require(&#39;fs&#39;).read()</code>，node就会交给<code>libuv</code>库处理，这个<code>libuv</code>库是别人写的，他就是node的事件环。</li>
<li><code>libuv</code>库是通过单线程异步的方式来处理事件，我们可以看到<code>work threads</code>是个多线程的队列，通过外面<code>event loop</code>阻塞的方式来进行异步调用。</li>
<li>等到<code>work threads</code>队列中有执行完成的事件，就会通过<code>EXECUTE CALLBACK</code>回调给<code>EVENT QUEUE</code>队列，把它放入队列中。</li>
<li>最后通过事件驱动的方式，取出<code>EVENT QUEUE</code>队列的事件，交给我们的应用</li>
</ul>
<h2 id="node中的event-loop"><a href="#node中的event-loop" class="headerlink" title="node中的event loop"></a>node中的event loop</h2><blockquote>
<p>node中的event loop是在libuv里面的，libuv里面有个事件环机制，他会在启动node时，初始化事件环</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644b17495b10980?w=838&amp;h=992&amp;f=jpeg&amp;s=153226" alt=""></p>
<ul>
<li>这里的每一个阶段都对应着一个<strong>事件队列</strong></li>
<li>每当<code>event loop</code>执行到某个阶段时，都会执行对应的<strong>事件队列</strong>中的事件，依次执行</li>
<li>当该队列执行完毕或者执行数量超过上限，<code>event loop</code>就会执行下一个阶段</li>
<li>每当<code>event loop</code>切换一个执行队列时，就会去清空<code>microtasks queues</code>，然后再切换到下个队列去执行，如此反复</li>
</ul>
<p><strong>这里我们要注意<code>setImmediate</code>是属于check队列的，还有poll队列主要是异步的I/O操作，比如node中的fs.readFile()</strong></p>
<blockquote>
<p>我们来具体看一下他的用法吧</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate1'</span>)</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)    </div><div class="line">  &#125;,<span class="number">0</span>)</div><div class="line">&#125;)</div><div class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>) </div><div class="line">  process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'nextTick1'</span>)&#125;)</div><div class="line">  setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate2'</span>)</div><div class="line">  &#125;)   </div><div class="line">&#125;,<span class="number">0</span>)</div></pre></td></tr></table></figure>
<ul>
<li>首先我们可以看到上面的代码先执行的是<code>setImmediate1</code>,此时<code>event loop</code>在<strong>check队列</strong></li>
<li>然后<code>setImmediate1</code>从队列取出之后，输出<code>setImmediate1</code>，然后会将<code>setTimeout1</code>执行</li>
<li>此时<code>event loop</code>执行完<strong>check队列</strong>之后，开始往下移动，接下来执行的是<strong>timers队列</strong></li>
<li>这里会有问题，我们都知道<code>setTimeout1</code>设置延迟为0的话，其实还是有<strong>4ms</strong>的延迟，那么这里就会有两种情况。先说第一种，此时<code>setTimeout1</code>已经执行完毕<ul>
<li>根据node事件环的规则，我们会执行完所有的事件，即取出<strong>timers队列</strong>中的<code>setTimeout2,setTimeout1</code></li>
<li>此时根据队列先进先出规则，输出顺序为<code>setTimeout2,setTimeout1</code>，在取出<code>setTimeout2</code>时，会将一个<code>process.nextTick</code>执行（执行完了就会被放入<strong>微任务队列</strong>），再将一个<code>setImmediate</code>执行（执行完了就会被放入<strong>check队列</strong>）</li>
<li>到这一步，<code>event loop</code>会再去寻找下个事件队列，此时<code>event loop</code>会发现<strong>微任务队列</strong>有事件<code>process.nextTick</code>，就会去清空它，输出<code>nextTick1</code></li>
<li>最后<code>event loop</code>找到下个有事件的队列<strong>check队列</strong>，执行<code>setImmediate</code>，输出<code>setImmediate2</code></li>
</ul>
</li>
<li>假如这里<code>setTimeout1</code>还未执行完毕（4ms耽误了它的终身大事？）<ul>
<li>此时<code>event loop</code>找到<strong>timers队列</strong>，取出<em>timers队列*</em>中的<code>setTimeout2</code>，输出<code>setTimeout2</code>，把<code>process.nextTick</code>执行，再把<code>setImmediate</code>执行</li>
<li>然后<code>event loop</code>需要去找下一个事件队列，<strong>这里大家要注意一下</strong>，这里会发生2步操作，<strong>1、<code>setTimeout1</code>执行完了，放入timers队列。2、找到微任务队列清空。</strong>，所以此时会先输出<code>nextTick1</code></li>
<li>接下来<code>event loop</code>会找到<strong>check队列</strong>，取出里面已经执行完的<code>setImmediate2</code></li>
<li>最后<code>event loop</code>找到<strong>timers队列</strong>，取出执行完的<code>setTimeout1</code>。<strong>这种情况下<code>event loop</code>比上面要多切换一次</strong></li>
</ul>
</li>
</ul>
<p>所以有两种答案</p>
<ol>
<li><code>setImmediate1,setTimeout2,setTimeout1,nextTick1,setImmediate2</code></li>
<li><code>setImmediate1,setTimeout2,nextTick1,setImmediate2,setTimeout1</code></li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644b640567422fe?w=2880&amp;h=1800&amp;f=png&amp;s=527100" alt=""></p>
<p>这里的图只参考了第一种情况，另一种情况也类似</p>
<h1 id="五、node的同步、异步，阻塞、非阻塞"><a href="#五、node的同步、异步，阻塞、非阻塞" class="headerlink" title="五、node的同步、异步，阻塞、非阻塞"></a>五、node的同步、异步，阻塞、非阻塞</h1><ul>
<li>同步：即为调用者等待被调用者这个过程，如果被调用者一直不反回结果，调用者就会一直等待，这就是同步，<strong>同步有返回值</strong></li>
<li>异步：即为调用者不等待被调用者是否返回，被调用者执行完了就会通过状态、通知或者回调函数给调用者，<strong>异步没有返回值</strong></li>
<li>阻塞：指代当前线程在结果返回之前会被挂起，不会继续执行下去</li>
<li>非阻塞： 即当前线程不管你返回什么，都会继续往下执行</li>
</ul>
<p><strong>有些人可能会搞乱他们之间的关系，<code>同步、异步</code>是被调用者的状态，<code>阻塞、非阻塞</code>是调用者的状态、消息</strong></p>
<p>接下来我们来看看他们的组合会是怎么样的</p>
<table>
<thead>
<tr>
<th>组合</th>
<th style="text-align:left">意义 </th>
</tr>
</thead>
<tbody>
<tr>
<td>同步阻塞</td>
<td style="text-align:left">这就相当于我去饭店吃饭，我需要在厨房等待菜烧好了，才能吃。我是调用者我需要等待上菜于是被阻塞，菜是被调用者做好直接给我是同步</td>
</tr>
<tr>
<td>异步阻塞</td>
<td style="text-align:left">我去饭店吃饭，我需要等待菜烧好了才能吃，但是厨师有事，希望之后处理完事能做好之后通知我去拿，我作为调用者等待就是阻塞的，而菜作为被调用者是做完之后通知我的，所以是异步的，这种方式一般没用。</td>
</tr>
<tr>
<td>同步非阻塞</td>
<td style="text-align:left">我去饭店吃饭，先叫了碗热菜，在厨房等厨师做菜，但我很饿，就开始吃厨房冷菜，我是调用者我没等热菜好就开始吃冷菜，是非阻塞的，菜作为被调用者做好直接给我是同步的，这种方式一般也没人用</td>
</tr>
<tr>
<td>异步非阻塞</td>
<td style="text-align:left">我去饭店吃饭。叫了碗热菜，厨师在做菜，但我很饿，先吃冷菜，厨师做好了通知我去拿，我是调用者我不会等热菜烧好了再吃冷菜，是非阻塞的，菜作为被调用者通知我拿是异步的</td>
</tr>
</tbody>
</table>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>希望大家看了本篇文章都有收获，这样出去面试的时候就不会这样<img src="https://user-gold-cdn.xitu.io/2018/6/29/1644be1f30719d81?w=444&amp;h=250&amp;f=gif&amp;s=4719128" alt=""><br>而是这样。好了，最后希望大家世界杯都能够<strong>逢赌必赢</strong>，自己喜欢的球队也能够<strong>杀进决赛</strong>。<br><img src="https://user-gold-cdn.xitu.io/2018/6/29/1644be34b6bb9dd0?w=367&amp;h=217&amp;f=gif&amp;s=3997305" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/">node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事件环/">事件环</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/宏任务/">宏任务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微任务/">微任务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/web/">web</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 陈旭锋
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>